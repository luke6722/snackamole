<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nez</name>
    </assembly>
    <members>
        <member name="T:Nez.AI.BehaviorTrees.BehaviorTreeReference`1">
            <summary>
            runs an entire BehaviorTree as a child and returns success
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.ExecuteAction`1">
            <summary>
            wraps a Func so that you can avoid having to subclass to create new actions
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.LogAction`1">
            <summary>
            simple task which will output the specified text and return success. It can be used for debugging.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.LogAction`1.Text">
            <summary>
            text to log
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.LogAction`1.IsError">
            <summary>
            is this text an error
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.WaitAction`1">
            <summary>
            Wait a specified amount of time. The task will return running until the task is done waiting. It will return success after the wait
            time has elapsed.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.WaitAction`1.WaitTime">
            <summary>
            the amount of time to wait
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Behavior`1">
            <summary>
            root class for all nodes
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Behavior`1.Invalidate">
            <summary>
            invalidate the status of the node. Composites can override this and invalidate all of their children.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Behavior`1.OnStart">
            <summary>
            called immediately before execution. It is used to setup any variables that need to be reset from the previous run
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Behavior`1.OnEnd">
            <summary>
            called when a task changes state to something other than running
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Behavior`1.Tick(`0)">
            <summary>
            tick handles calling through to update where the actual work is done. It exists so that it can call onStart/onEnd when necessary.
            </summary>
            <param name="context">Context.</param>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.BehaviorTree`1">
            <summary>
            root class used to control a BehaviorTree. Handles storing the context
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.BehaviorTree`1.UpdatePeriod">
            <summary>
            how often the behavior tree should update. An updatePeriod of 0.2 will make the tree update 5 times a second.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.BehaviorTree`1._context">
            <summary>
            The context should contain all the data needed to run the tree
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.BehaviorTree`1._root">
            <summary>
            root node of the tree
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1">
            <summary>
            helper for building a BehaviorTree using a fluent API. Leaf nodes need to first have a parent added. Parents can be Composites or
            Decorators. Decorators are automatically closed when a leaf node is added. Composites must have endComposite called to close them.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1._currentNode">
            <summary>
            Last node created.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1._parentNodeStack">
            <summary>
            Stack nodes that we are build via the fluent API.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1.PushParentNode(Nez.AI.BehaviorTrees.Behavior{`0})">
            <summary>
            pushes a Composite or Decorator on the stack
            </summary>
            <returns>The parent node.</returns>
            <param name="composite">Composite.</param>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1.Action(System.Func{`0,System.Boolean})">
            <summary>
            Like an action node but the function can return true/false and is mapped to success/failure.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1.Conditional(System.Func{`0,System.Boolean})">
            <summary>
            Like a conditional node but the function can return true/false and is mapped to success/failure.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1.SubTree(Nez.AI.BehaviorTrees.BehaviorTree{`0})">
            <summary>
            Splice a sub tree into the parent tree.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.BehaviorTreeBuilder`1.ConditionalDecorator(System.Func{`0,System.Boolean},System.Boolean)">
            <summary>
            Like a conditional decorator node but the function can return true/false and is mapped to success/failure.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.AbortTypes.None">
            <summary>
            no abort type. the current action will always run even if other conditionals change state
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.AbortTypes.LowerPriority">
            <summary>
            If a more important conditional task changes status it can issue an abort that will stop the lower priority tasks from running
            and shift control back to the higher priority branch. This type should be set on Composites that are children of the evaulating
            Composite. The parent Composite will check it's children to see if they have a LowerPriority abort.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.AbortTypes.Self">
            <summary>
            The Conditional task can only abort an Action task if they are both children of the Composite. This AbortType only affects the
            actual Composite that it is set on unlike LowerPriority which affects its parent Composite.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.AbortTypes.Both">
            <summary>
            both LowerPriority and Self aborts are checked
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Composite`1">
            <summary>
            any Composite nodes must subclass this. Provides storage for children and helpers to deal with AbortTypes
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.AddChild(Nez.AI.BehaviorTrees.Behavior{`0})">
            <summary>
            adds a child to this Composite
            </summary>
            <param name="child">Child.</param>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.IsFirstChildConditional">
            <summary>
            returns true if the first child of a Composite is a Conditional. Usef for dealing with conditional aborts.
            </summary>
            <returns><c>true</c>, if first child conditional was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.HasLowerPriorityConditionalAbortInChildren">
            <summary>
            checks the children of the Composite to see if any are a Composite with a LowerPriority AbortType
            </summary>
            <returns><c>true</c>, if lower priority conditional abort in children was hased, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.UpdateLowerPriorityAbortConditional(`0,Nez.AI.BehaviorTrees.TaskStatus)">
            <summary>
            checks any child Composites that have a LowerPriority AbortType and a Conditional as the first child. If it finds one it will tick
            the Conditional and if the status is not equal to statusCheck the _currentChildIndex will be updated, ie the currently running
            Action will be aborted.
            </summary>
            <param name="context">Context.</param>
            <param name="statusCheck">Status check.</param>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.UpdateSelfAbortConditional(`0,Nez.AI.BehaviorTrees.TaskStatus)">
            <summary>
            checks any IConditional children to see if they have changed state
            </summary>
            <param name="context">Context.</param>
            <param name="statusCheck">Status check.</param>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.Composite`1.UpdateConditionalNode(`0,Nez.AI.BehaviorTrees.Behavior{`0})">
            <summary>
            helper that gets the TaskStatus of either a Conditional or a ConditionalDecorator
            </summary>
            <returns>The conditional node.</returns>
            <param name="context">Context.</param>
            <param name="node">Node.</param>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Parallel`1">
            <summary>
            the parallel task will run each child task until a child task returns failure. The difference is that the parallel task will run all of
            its children tasks simultaneously versus running each task one at a time. Like the sequence class, the parallel task will return
            success once all of its children tasks have returned success. If one tasks returns failure the parallel task will end all of the child
            tasks and return failure.
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.ParallelSelector`1">
            <summary>
            Similar to the selector task, the ParallelSelector task will return success as soon as a child task returns success. The difference
            is that the parallel task will run all of its children tasks simultaneously versus running each task one at a time. If one tasks returns
            success the parallel selector task will end all of the child tasks and return success. If every child task returns failure then the
            ParallelSelector task will return failure.
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.RandomSelector`1">
            <summary>
            Same as Selector except it shuffles the children when started
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.RandomSequence`1">
            <summary>
            Same as Sequence except it shuffles the children when started
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Selector`1">
            <summary>
            The selector task is similar to an "or" operation. It will return success as soon as one of its child tasks return success. If a
            child task returns failure then it will sequentially run the next task. If no child task returns success then it will return failure.
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Sequence`1">
            <summary>
            The sequence task is similar to an "and" operation. It will return failure as soon as one of its child tasks return failure. If a
            child task returns success then it will sequentially run the next task. If all child tasks return success then it will return success.
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.ExecuteActionConditional`1">
            <summary>
            wraps an ExecuteAction so that it can be used as a Conditional
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.IConditional`1">
            <summary>
            interface used just to identify if a Behavior is a conditional. it will always be applied to a Behavior which already has the update method.
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.RandomProbability`1">
            <summary>
            returns success when the random probability is above the successProbability probability. It will otherwise return failure.
            successProbability should be between 0 and 1.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.RandomProbability`1._successProbability">
            <summary>
            The chance that the task will return success
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.AlwaysFail`1">
            <summary>
            will always return failure except when the child task is running
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.AlwaysSucceed`1">
            <summary>
            will always return success except when the child task is running
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.ConditionalDecorator`1">
            <summary>
            decorator that will only run its child if a condition is met. By default, the condition will be reevaluated every tick.
            </summary>
        </member>
        <member name="M:Nez.AI.BehaviorTrees.ConditionalDecorator`1.ExecuteConditional(`0,System.Boolean)">
            <summary>
            executes the conditional either following the shouldReevaluate flag or with an option to force an update. Aborts will force the
            update to make sure they get the proper data if a Conditional changes.
            </summary>
            <returns>The conditional.</returns>
            <param name="context">Context.</param>
            <param name="forceUpdate">If set to <c>true</c> force update.</param>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Inverter`1">
            <summary>
            inverts the result of the child node
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.Repeater`1">
            <summary>
            will repeat execution of its child task until the child task has been run a specified number of times. It has the option of
            continuing to execute the child task even if the child task returns a failure.
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.Repeater`1.Count">
            <summary>
            The number of times to repeat the execution of its child task
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.Repeater`1.RepeatForever">
            <summary>
            Allows the repeater to repeat forever
            </summary>
        </member>
        <member name="F:Nez.AI.BehaviorTrees.Repeater`1.EndOnFailure">
            <summary>
            Should the task return if the child task returns a failure
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.UntilFail`1">
            <summary>
            will keep executing its child task until the child task returns failure
            </summary>
        </member>
        <member name="T:Nez.AI.BehaviorTrees.UntilSuccess`1">
            <summary>
            will keep executing its child task until the child task returns success
            </summary>
        </member>
        <member name="T:Nez.AI.FSM.SimpleStateMachine`1">
            <summary>
            Simple state machine with an enum constraint. There are some rules you must follow when using this:
            - before update is called initialState must be set (use the constructor or onAddedToEntity)
            - if you implement update in your subclass you must call base.update()
            
            Note: if you use an enum as the contraint you can avoid allocations/boxing in Mono by doing what the Core
            Emitter does for its enum: pass in a IEqualityComparer to the constructor.
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.State`1.OnInitialized">
            <summary>
            called directly after the machine and context are set allowing the state to do any required setup
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.State`1.Begin">
            <summary>
            called when the state becomes the active state
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.State`1.Reason">
            <summary>
            called before update allowing the state to have one last chance to change state
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.State`1.Update(System.Single)">
            <summary>
            called every frame this state is the active state
            </summary>
            <param name="deltaTime">Delta time.</param>
        </member>
        <member name="M:Nez.AI.FSM.State`1.End">
            <summary>
            called when this state is no longer the active state
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.AddState(Nez.AI.FSM.State{`0})">
            <summary>
            adds the state to the machine
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.Update(System.Single)">
            <summary>
            ticks the state machine with the provided delta time
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.GetState``1">
            <summary>
            Gets a specific state from the machine without having to
            change to it.
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.ChangeState(System.Type)">
            <summary>
            changes the current state
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.ChangeState``1">
            <summary>
            changes the current state
            </summary>
        </member>
        <member name="M:Nez.AI.FSM.StateMachine`1.ChangeToPreviousState">
            <summary>
            changes to the previous state if one exists
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.Action.Name">
            <summary>
            optional name for the Action. Used for debugging purposes
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.Action.Cost">
            <summary>
            The cost of performing the action.  Figure out a weight that suits the action.  Changing it will affect what actions are
            chosen during planning
            </summary>
        </member>
        <member name="M:Nez.AI.GOAP.Action.Validate">
            <summary>
            called before the Planner does its planning. Gives the Action an opportunity to set its score or to opt out if it isnt of use.
            For example, if the Action is to pick up a gun but there are no guns in the world returning false would keep the Action from being
            considered by the ActionPlanner.
            </summary>
        </member>
        <member name="T:Nez.AI.GOAP.ActionPlanner">
            <summary>
            GOAP based on https://github.com/stolk/GPGOAP
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.ActionPlanner.ConditionNames">
            <summary>
            Names associated with all world state atoms
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.ActionPlanner._preConditions">
            <summary>
            Preconditions for all actions
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.ActionPlanner._postConditions">
            <summary>
            Postconditions for all actions (action effects).
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.ActionPlanner._numConditionNames">
            <summary>
            Number of world state atoms.
            </summary>
        </member>
        <member name="M:Nez.AI.GOAP.ActionPlanner.CreateWorldState">
            <summary>
            convenince method for fetching a WorldState object
            </summary>
            <returns>The world state.</returns>
        </member>
        <member name="M:Nez.AI.GOAP.ActionPlanner.Describe">
            <summary>
            Describe the action planner by listing all actions with pre and post conditions. For debugging purpose.
            </summary>
        </member>
        <member name="T:Nez.AI.GOAP.Action`1">
            <summary>
            convenince Action subclass with a typed context. This is useful when an Action requires validation so that it has some way to get
            the data it needs to do the validation.
            </summary>
        </member>
        <member name="T:Nez.AI.GOAP.Agent">
            <summary>
            Agent provides a simple and concise way to use the planner. It is not necessary to use at all since it is just a convenince wrapper
            around the ActionPlanner making it easier to get plans and store the results.
            </summary>
        </member>
        <member name="M:Nez.AI.GOAP.Agent.GetWorldState">
            <summary>
            current WorldState
            </summary>
            <returns>The world state.</returns>
        </member>
        <member name="M:Nez.AI.GOAP.Agent.GetGoalState">
            <summary>
            the goal state that the agent wants to achieve
            </summary>
            <returns>The goal state.</returns>
        </member>
        <member name="F:Nez.AI.GOAP.AStarNode.WorldState">
            <summary>
            The state of the world at this node.
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.AStarNode.CostSoFar">
            <summary>
            The cost so far.
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.AStarNode.HeuristicCost">
            <summary>
            The heuristic for remaining cost (don't overestimate!)
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.AStarNode.CostSoFarAndHeuristicCost">
            <summary>
            costSoFar + heuristicCost (g+h) combined.
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.AStarNode.Action">
            <summary>
            the Action associated with this node
            </summary>
        </member>
        <member name="M:Nez.AI.GOAP.AStar.Plan(Nez.AI.GOAP.ActionPlanner,Nez.AI.GOAP.WorldState,Nez.AI.GOAP.WorldState,System.Collections.Generic.List{Nez.AI.GOAP.AStarNode})">
            <summary>
            Make a plan of actions that will reach desired world state
            </summary>
            <param name="ap">Ap.</param>
            <param name="start">Start.</param>
            <param name="goal">Goal.</param>
            <param name="storage">Storage.</param>
        </member>
        <member name="M:Nez.AI.GOAP.AStar.ReconstructPlan(Nez.AI.GOAP.AStarNode,System.Collections.Generic.List{Nez.AI.GOAP.AStarNode})">
            <summary>
            internal function to reconstruct the plan by tracing from last node to initial node
            </summary>
            <returns>The plan.</returns>
            <param name="goalnode">Goalnode.</param>
        </member>
        <member name="M:Nez.AI.GOAP.AStar.CalculateHeuristic(Nez.AI.GOAP.WorldState,Nez.AI.GOAP.WorldState)">
            <summary>
            This is our heuristic: estimate for remaining distance is the nr of mismatched atoms that matter.
            </summary>
            <returns>The heuristic.</returns>
            <param name="fr">Fr.</param>
            <param name="to">To.</param>
        </member>
        <member name="F:Nez.AI.GOAP.WorldState.Values">
            <summary>
            we use a bitmask shifting on the condition index to flip bits
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.WorldState.DontCare">
            <summary>
            bitmask used to explicitly state false. We need a separate store for negatives because the absense of a value doesnt necessarily mean
            it is false.
            </summary>
        </member>
        <member name="F:Nez.AI.GOAP.WorldState.planner">
            <summary>
            required so that we can get the condition index from the string name
            </summary>
        </member>
        <member name="M:Nez.AI.GOAP.WorldState.Describe(Nez.AI.GOAP.ActionPlanner)">
            <summary>
            for debugging purposes. Provides a human readable string of all the preconditions.
            </summary>
            <param name="planner">Planner.</param>
        </member>
        <member name="T:Nez.AI.Pathfinding.AstarGridGraph">
            <summary>
            basic static grid graph for use with A*. Add walls to the walls HashSet and weighted nodes to the weightedNodes HashSet. This provides
            a very simple grid graph for A* with just two weights: defaultWeight and weightedNodeWeight.
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.AstarGridGraph.#ctor(Nez.Tiled.TmxLayer)">
            <summary>
            creates a WeightedGridGraph from a TiledTileLayer. Present tile are walls and empty tiles are passable.
            </summary>
            <param name="tiledLayer">Tiled layer.</param>
        </member>
        <member name="M:Nez.AI.Pathfinding.AstarGridGraph.IsNodeInBounds(Microsoft.Xna.Framework.Point)">
            <summary>
            ensures the node is in the bounds of the grid graph
            </summary>
            <returns><c>true</c>, if node in bounds was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.Pathfinding.AstarGridGraph.IsNodePassable(Microsoft.Xna.Framework.Point)">
            <summary>
            checks if the node is passable. Walls are impassable.
            </summary>
            <returns><c>true</c>, if node passable was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.Pathfinding.AstarGridGraph.Search(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            convenience shortcut for calling AStarPathfinder.search
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.AStarPathfinder">
            <summary>
            calculates paths given an IAstarGraph and start/goal positions
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.AStarPathfinder.AStarNode`1">
            <summary>
            wraps up the raw data in a small class with the extra fields the PriorityQueue requires
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.AStarPathfinder.Search``1(Nez.AI.Pathfinding.IAstarGraph{``0},``0,``0)">
            <summary>
            gets a path from start to goal if possible. If no path is found null is returned.
            </summary>
            <param name="graph">Graph.</param>
            <param name="start">Start.</param>
            <param name="goal">Goal.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.AI.Pathfinding.AStarPathfinder.RecontructPath``1(System.Collections.Generic.Dictionary{``0,``0},``0,``0)">
            <summary>
            reconstructs a path from the cameFrom Dictionary
            </summary>
            <returns>The path.</returns>
            <param name="cameFrom">Came from.</param>
            <param name="start">Start.</param>
            <param name="goal">Goal.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:Nez.AI.Pathfinding.IAstarGraph`1">
            <summary>
            interface for a graph that can be fed to the AstarPathfinder.search method
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.IAstarGraph`1.GetNeighbors(`0)">
            <summary>
            The getNeighbors method should return any neighbor nodes that can be reached from the passed in node
            </summary>
            <returns>The neighbors.</returns>
            <param name="node">Node.</param>
        </member>
        <member name="M:Nez.AI.Pathfinding.IAstarGraph`1.Cost(`0,`0)">
            <summary>
            calculates the cost to get from 'from' to 'to'
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
        </member>
        <member name="M:Nez.AI.Pathfinding.IAstarGraph`1.Heuristic(`0,`0)">
            <summary>
            calculates the heuristic (estimate) to get from 'node' to 'goal'. See WeightedGridGraph for the common Manhatten method.
            </summary>
            <param name="node">Node.</param>
            <param name="goal">Goal.</param>
        </member>
        <member name="T:Nez.AI.Pathfinding.BreadthFirstPathfinder">
            <summary>
            calculates paths given an IUnweightedGraph and start/goal positions
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.IUnweightedGraph`1">
            <summary>
            interface for a graph that can be fed to the BreadthFirstPathfinder.search method
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.IUnweightedGraph`1.GetNeighbors(`0)">
            <summary>
            The getNeighbors method should return any neighbor nodes that can be reached from the passed in node.
            </summary>
            <returns>The neighbors.</returns>
            <param name="node">Node.</param>
        </member>
        <member name="T:Nez.AI.Pathfinding.UnweightedGraph`1">
            <summary>
            basic implementation of an UnweightedGraph. All edges are cached. This type of graph is best suited for non-grid based graphs.
            Any nodes added as edges must also have an entry as the key in the edges Dictionary.
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.UnweightedGridGraph">
            <summary>
            basic unweighted grid graph for use with the BreadthFirstPathfinder
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.UnweightedGridGraph.Search(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            convenience shortcut for calling BreadthFirstPathfinder.search
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.IWeightedGraph`1">
            <summary>
            interface for a graph that can be fed to the DijkstraPathfinder.search method
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.IWeightedGraph`1.GetNeighbors(`0)">
            <summary>
            The getNeighbors method should return any neighbor nodes that can be reached from the passed in node
            </summary>
            <returns>The neighbors.</returns>
            <param name="node">Node.</param>
        </member>
        <member name="M:Nez.AI.Pathfinding.IWeightedGraph`1.Cost(`0,`0)">
            <summary>
            calculates the cost to get from 'from' to 'to'
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
        </member>
        <member name="T:Nez.AI.Pathfinding.WeightedGridGraph">
            <summary>
            basic grid graph with support for one type of weighted node
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedGridGraph.#ctor(Nez.Tiled.TmxLayer)">
            <summary>
            creates a WeightedGridGraph from a TiledTileLayer. Present tile are walls and empty tiles are passable.
            </summary>
            <param name="tiledLayer">Tiled layer.</param>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedGridGraph.IsNodeInBounds(Microsoft.Xna.Framework.Point)">
            <summary>
            ensures the node is in the bounds of the grid graph
            </summary>
            <returns><c>true</c>, if node in bounds was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedGridGraph.IsNodePassable(Microsoft.Xna.Framework.Point)">
            <summary>
            checks if the node is passable. Walls are impassable.
            </summary>
            <returns><c>true</c>, if node passable was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedGridGraph.Search(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            convenience shortcut for calling AStarPathfinder.search
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.WeightedPathfinder">
            <summary>
            calculates paths given an IWeightedGraph and start/goal positions
            </summary>
        </member>
        <member name="T:Nez.AI.Pathfinding.WeightedPathfinder.WeightedNode`1">
            <summary>
            wraps up the raw data in a small class with the extra fields the PriorityQueue requires
            </summary>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedPathfinder.Search``1(Nez.AI.Pathfinding.IWeightedGraph{``0},``0,``0)">
            <summary>
            gets a path from start to goal if possible. If no path is found null is returned.
            </summary>
            <param name="graph">Graph.</param>
            <param name="start">Start.</param>
            <param name="goal">Goal.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.AI.Pathfinding.WeightedPathfinder.RecontructPath``1(System.Collections.Generic.Dictionary{``0,``0},``0,``0)">
            <summary>
            reconstructs a path from the cameFrom Dictionary
            </summary>
            <returns>The path.</returns>
            <param name="cameFrom">Came from.</param>
            <param name="start">Start.</param>
            <param name="goal">Goal.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:Nez.AI.UtilityAI.ActionExecutor`1">
            <summary>
            wraps an Action for use as an IAction without having to create a new class
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.ActionWithOptions`2">
            <summary>
            Action that encompasses a List of options. The options are passed to Appraisals which score and locate the best option.
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.CompositeAction`1">
            <summary>
            Action that contains a List of Actions that it will execute sequentially
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.IActionOptionAppraisal`2">
            <summary>
            Appraisal for use with an ActionWithOptions
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.LogAction`1">
            <summary>
            Action that logs text
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.ReasonerAction`1">
            <summary>
            Action that calls through to another Reasoner
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.AllOrNothingConsideration`1">
            <summary>
            Only scores if all child Appraisals score above the threshold
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.ActionAppraisal`1">
            <summary>
            wraps a Func for use as an Appraisal without having to create a subclass
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.IAppraisal`1">
            <summary>
            scorer for use with a Consideration
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.FixedScoreConsideration`1">
            <summary>
            always returns a fixed score. Serves double duty as a default Consideration.
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.IConsideration`1">
            <summary>
            encapsulates an Action and generates a score that a Reasoner can use to decide which Consideration to use
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.SumOfChildrenConsideration`1">
            <summary>
            Scores by summing the score of all child Appraisals
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.ThresholdConsideration`1">
            <summary>
            Scores by summing child Appraisals until a child scores below the threshold
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.FirstScoreReasoner`1">
            <summary>
            The first Consideration to score above the score of the Default Consideration is selected
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.HighestScoreReasoner`1">
            <summary>
            The Consideration with the highest score is selected
            </summary>
        </member>
        <member name="T:Nez.AI.UtilityAI.Reasoner`1">
            <summary>
            the root of UtilityAI.
            </summary>
        </member>
        <member name="F:Nez.AI.UtilityAI.UtilityAI`1.UpdatePeriod">
            <summary>
            how often the behavior tree should update. An updatePeriod of 0.2 will make the tree update 5 times a second.
            </summary>
        </member>
        <member name="F:Nez.AI.UtilityAI.UtilityAI`1._context">
            <summary>
            The context should contain all the data needed to run the tree
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteBlendMode">
            <summary>
            Defines the blend mode used by Aseprite layers when blending cels.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Normal">
            <summary>
                Normal blend mode is the standard blend mode that takes the top layer alone without mixing any color from
                the layer beneath it.
                <code>f(a,b) = b</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Multiply">
            <summary>
                Multiply blend mode that takes the RGB component values of each pixel from the top layer and multiplies them
                with the RGB component values of the corresponding pixel from the bottom layer.
                <code>f(a,b) = ab</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Screen">
            <summary>
                Screen blend mode takes the RGB component values of each pixel from the top and bottom layer and inverts 
                them, then multiples the RGB component values of each pixel from the top layer with the RGB component values
                of the corresponding pixel from the bottom layer, then the RGB component value of each resulting pixel is 
                inverted again.
                <code>f(a,b) = 1-(1-a)(1-b)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Overlay">
            <summary>
                Overlay blend combines the Multiply and Screen blend modes based on the tonal value of the bottom layer. If 
                the bottom layer is darker than 50% gray, then the tonal values are multiplied; otherwise, they get 
                screened.  In both cases the resulting value is doubled after.
                <code>f(a,b) = 2ab when a less than 0.5</code>
                <code>f(a,b) = 1-2(1-a)(1-b) when a equal to or greater than 0.5</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Darken">
            <summary>
                Darken blend retains the smallest of each RGB component for each corresponding pixel from the top and bottom
                layer.
                <code>f((r1,g1,b1), (r2,b2,g2)) = [min(r1,r2), min(g1,g2), min(b1,b2)]</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Lighten">
            <summary>
                Lighten blend retains the largest of each RGB component for each corresponding pixel from the top and bottom
                layer.
            <code>f((r1,g1,b1), (r2,b2,g2)) = [max(r1,r2), max(g1,g2), max(b1,b2)]</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.ColorDodge">
            <summary>
                Color Dodge blend divides each pixel from the bottom layer with the corresponding inverted pixel from the
                top layer.
                <code>f(a,b) = a/(1-b)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.ColorBurn">
            <summary>
                Color Burn blend divides each inverted pixel from the bottom layer with the corresponding pixel from the top
                layer, then inverts the resulting value.
            <code>f(a,b) = 1-(1-a)/b</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.HardLight">
            <summary>
                Hard Light blend combines the Multiply and Screen blend modes based on the tonal value of the top layer. 
                If the top layer is darker than 50% gray, then the tonal values are multiplied; otherwise, they get 
                screened.  In both cases the resulting value is doubled after.
                <code>f(a,b) = 2ab when b less than 0.5</code>
                <code>f(a,b) = 1-2(1-a)(1-b) when b equal to or greater than 0.5</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.SoftLight">
            <summary>
                Soft Light blend modulates the tonal values of the bottom layer by the tonal values of the top layer.
                <code>f(a,b) = (2b-1)(a-a^2)+a when b is less than 0.5</code>
                <code>f(a,b) = (2b-1)(sqrt(a)-a)+a when b is equal to or greater than 0.5</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Difference">
            <summary>
                Difference blend returns the absolute value in the difference between RGB component value of each pixel in 
                the top layer from the RGB component value in the corresponding pixel in the bottom layer.
                <code>f(a,b) = |a-b|</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Exclusion">
            <summary>
                Exclusion blend mode takes the sum of the RGB component values of each pixel in the top layer with the RGB
                component value of each corresponding pixel in the bottom layer, then subtracts the doubled product of top 
                and bottom layer.
            <code>f(a,b) = a+b-2ab</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Hue">
            <summary>
                Hue blend mode preserves the luma and chroma of each pixel in the bottom layer and adopts the hue of the
                corresponding pixel in the top layer.
                <code>f((Ha,Sa,La),(Hb,Sb,Lb)) = (Hb, Sa, La)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Saturation">
            <summary>
                Saturation blend mode preserves the luma and hue of each pixel in the bottom layer and adopts the chroma of
                the corresponding pixel in the top layer.
                <code>f((Ha,Sa,La),(Hb,Sb,Lb)) = (Ha, Sb, La)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Color">
            <summary>
                The color blend mode preserves the luma of each pixel in the bottom layer and adopts the hue and chorma of
                corresponding pixel in the top layer.
                <code>f((Ha,Sa,La),(Hb,Sb,Lb)) = (Hb, Sb, La)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Luminosity">
            <summary>
                Luminosity blend mode preserves the hue and chroma of each pixel in the bottom layer and adopts the luma of
                the corresponding pixel in then top layer.
                <code>f((Ha,Sa,La),(Hb,Sb,Lb)) = (Ha, Sa, Lb)</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Addition">
            <summary>
                Addition blend mode adds the RGB component values of each pixel from the top layer with the RGB component 
                values of each corresponding pixel in the bottom layer.
                <code>f(a,b) = a + b</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Subtract">
            <summary>
                Subtract blend mode subtracts the RGB component values of each pixel from the top layer from the RGB 
                component values of each corresponding pixel in the bottom layer.
                <code>f(a,b) = a - b</code>
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteBlendMode.Divide">
            <summary>
                Divide blend mode divides the RGB component values of each pixel from the bottom layer by the RGB component
                values of each corresponding pixel from the top layer.
                <code>f(a,b) = a/b</code>
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteCel">
            <summary>
            Defines a single cel within a frame in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteCel.Layer">
            <summary>
            The layer that this cel exists on.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteCel.Position">
            <summary>
            The x- and y- coordinate position of this cel relative to the bounds of the frame.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteCel.Opacity">
            <summary>
            The opacity level of this cel, in the range of 0 - 255
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteCel.UserData">
            <summary>
            The custom user data tha was set in the properties for this cel in Aseprite.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteColorDepth">
            <summary>
            Defines the color depth mode used by an Aseprite image.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteColorDepth.Indexed">
            <summary>
                Defines that the Aseprite image uses an Indexed mode of 8-bits per pixel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteColorDepth.Grayscale">
            <summary>
            Defines that the Aseprite image uses a Grayscale mode of 16-bits per pixel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteColorDepth.RGBA">
            <summary>
            Defines that the Aseprite image uses an RGBA mode of 32-bits per pixel.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteColorUtils">
            <summary>
            Provides utility methods for working with colors in Aseprite.
            </summary>
        </member>
        <member name="M:Nez.Aseprite.AsepriteColorUtils.Blend(Nez.Aseprite.AsepriteBlendMode,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Int32)">
            <summary>
            Given two colors, blends them using the specified <see cref="T:Nez.Aseprite.AsepriteBlendMode"/>.  
            </summary>
            <remarks>
            The <paramref name="backdrop"/> is the color on the bottom layer and the <paramref name="source"/> is the
            color on the top layer that is blending down to the backdrop.
            </remarks>
            <param name="mode">The blend mode to use when blending the two colors.</param>
            <param name="backdrop">The color on the lowest layer when blending</param>
            <param name="source">The color on the highest layer when blending.</param>
            <param name="opacity">The opacity of the source layer (cel.Opacity * cel.Layer.Opacity)</param>
            <returns>
            A <see cref="T:Microsoft.Xna.Framework.Color"/> value that is the result of blending the two colors given.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the <paramref name="mode"/> parameter is an unknown <see cref="T:Nez.Aseprite.AsepriteBlendMode"/> value.
            </exception>
        </member>
        <member name="T:Nez.Aseprite.AsepriteFile">
            <summary>
            Represents the contents loaded from an Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.CanvasWidth">
            <summary>
            The width, in pixels, defined for the canvas of the Aseprite image.
            </summary>
            <remarks>
            This is also the width of every frame.
            </remarks>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.CanvasHeight">
            <summary>
            The height, in pixels, defined for the canvas of the Aseprite image.
            </summary>
            <remarks>
            This is also the height of every frame.
            </remarks>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.ColorDepth">
            <summary>
            The color depth mode used for the image in Aseprite which defines the total number of bits per pixel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Frames">
            <summary>
            A collection of all frame elements in the Aseprite file.  Order of elements is from first-to-last.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Layers">
            <summary>
            A collection of all layer elements in the Aseprite file.  Order of elements is from bottom-to-top.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Tags">
            <summary>
            A collection of all tag elements from the Aseprite file.  Order of elements is as defined in the Aseprite UI
            from left-to-right.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Slices">
            <summary>
            A collection of all slice elements from the Aseprite file.  Order of elements is in the order they were
            created in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Warnings">
            <summary>
            A collection of any warnings issued when parsing the Aseprite file.  You can use this to see if there were
            any non-fatal errors that occurred while parsing the file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Palette">
            <summary>
            The palette data from the Aseprite file containing the palette information and colors.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteFile.UserData">
            <summary>
            The custom user data that was set in the sprite properties in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFile.Name">
            <summary>
            The name of this Aseprite file (without extension)
            </summary>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFile.ToSpriteAtlas(System.Boolean,System.Int32,System.Int32,System.Int32,System.Nullable{Microsoft.Xna.Framework.Vector2},System.String)">
            <summary>
            Translates the data in this aseprite file to a sprite atlas that can be used in a sprite animator component.
            </summary>
            <param name="onlyVisibleLayers">
            Indicates whether only layers that are visible in the Aseprite file should be included when generating the 
            texture.
            </param>
            <param name="borderPadding">
            Indicates the amount of padding, in transparent pixels, to add to the edge of the generated texture.
            </param>
            <param name="spacing">
            Indicates the amount of padding, in transparent pixels, to add between each frame in the generated texture.
            </param>
            <param name="innerPadding">
            indicates the amount of padding, in transparent pixels, to add around the edges of each frame in the
            generated texture.
            </param>
            <param name="spriteOrigin">
            make the sprite origin something other than sourceRect.GetHalfSize()
            </param>
            <returns>
            A new instance of hte <see cref="T:Nez.Sprites.SpriteAtlas"/> class initialized with the data generated from this Aseprite
            file.
            </returns>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFile.ToSpriteAtlasWithOrigin(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Translates the data in this aseprite file to a sprite atlas that can be used in a sprite animator component.
            </summary>
            <param name="spriteOrigin">
            make the sprite origin something other than sourceRect.GetHalfSize()
            </param>
            <returns>
            A new instance of hte <see cref="T:Nez.Sprites.SpriteAtlas"/> class initialized with the data generated from this Aseprite
            file.
            </returns>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFile.GetTextureFromFrameNumber(System.Int32)">
            <summary>
            generate a Texture2D from a single aseprite frame.
            </summary>
            <param name="frameNumber">
            the number of the frame as show in Aseprite app.
            </param>
            <returns>
            A <see cref="T:Microsoft.Xna.Framework.Graphics.Texture2D"/> instance with the flattened contents of the frame
            </returns>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFile.GetTextureFromFrameTagged(System.String)">
            <summary>
            generate a Texture2D from the first frame in a tagged animation sequence.
            </summary>
            <param name="tagName">
            the tag/name of the animation sequence as show in Aseprite app.
            </param>
            <returns>
            A <see cref="T:Microsoft.Xna.Framework.Graphics.Texture2D"/> instance with the flattened contents of the single animation frame
            </returns>
        </member>
        <member name="T:Nez.Aseprite.AsepriteFrame">
            <summary>
            Represents a single frame in an Aseprite file.  Frames are composed of cels.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFrame.Cels">
            <summary>
            The collection of cel elements that make up this frame.  Order of cels are from the bottom most layer to the
            top most layer within the frame.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFrame.Name">
            <summary>
            The name of this frame.  This name is autogenerated based on the name of the Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFrame.Width">
            <summary>
            The width, in pixels, of this frame.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFrame.Height">
            <summary>
            The height, in pixels, of this frame.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteFrame.Duration">
            <summary>
            The duration, in milliseconds, that this frame should be displayed when used as part of an animation.
            </summary>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFrame.FlattenFrame(System.Boolean,System.Boolean,System.String)">
            <summary>
            Flattens this frame by blending all cel elements into a single iamge.
            </summary>
            <param name="onlyVisibleLayers">
            Indicates whether only cels that are on visible layers should be included when flattening this frame.
            </param>
            <param name="includeBackgroundLayer">
            Indicates whether the cel on the layer marked as the background layer in Aseprite should be included when
            flattening this frame.
            </param>
            <returns>
            A new array of color elements where each element represents the final pixels for this frame once flattened.
            Order of color element starts with the top-left most pixel and is read left-to-right from top-to-bottom.
            </returns>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFrame.FlattenFrameOnLayers(System.Boolean,System.Boolean,System.String[])">
            <summary>
            Flattens this frame by blending all cel elements on the specified layers into a single image.
            </summary>
            <param name="onlyVisibleLayers">
            Indicates whether only cels that are on visible layers should be included when flattening this frame.
            </param>
            <param name="includeBackgroundLayer">
            Indicates whether the cel on the layer marked as the background layer in Aseprite should be included when
            flattening this frame.
            </param>
            <returns>
            A new array of color elements where each element represents the final pixels for this frame once flattened.
            Order of color element starts with the top-left most pixel and is read left-to-right from top-to-bottom.
            </returns>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFrame.ToSprite(System.Boolean,System.Boolean)">
            <summary>
            Translates the data in this frame into a sprite.
            </summary>
            <param name="onlyVisibleLayers">
            Indicates whether only cels that are on visible layers should be included when flattening this frame.
            </param>
            <param name="includeBackgroundLayer">
            Indicates whether the cel on the layer marked as the background layer in Aseprite should be included when
            flattening this frame.
            </param>
            <returns>
            A new instance of the <see cref="T:Nez.Textures.Sprite"/> class initialized by the image data in this frame.
            </returns>
        </member>
        <member name="T:Nez.Aseprite.AsepriteGroupLayer">
            <summary>
            Represents a group layer in an Aseprite file that contains child layers.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteGroupLayer.Children">
            <summary>
            A collection of all child layer elements grouped into this group layer.  Order of layer elements is from
            bottom most layer to top most layer in the group.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteImageCel">
            <summary>
            Represents a single cel in a frame in Aseprite that contains image data.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteImageCel.Width">
            <summary>
            The width, in pixels, of this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteImageCel.Height">
            <summary>
            The height, in pixels, of this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteImageCel.Pixels">
            <summary>
            An array of color elements that represents the pixel data that makes up the image for this cel.  Order of
            the color elements starts with the top-left most pixel and is read left-to-right from top-to-bottom.
            </summary>
        </member>
        <member name="M:Nez.Aseprite.AsepriteImageCel.ToSprite">
            <summary>
            Translates the pixel data of this cel into a new sprite instance.
            </summary>
            <returns>
            A new instance of the <see cref="T:Nez.Textures.Sprite"/> class initialized with a texture generated from the pixel data
            of this cel.
            </returns>
        </member>
        <member name="T:Nez.Aseprite.AsepriteImageLayer">
            <summary>
            Represents a layer in an Aseprite file that image cels are placed on.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteLayer">
            <summary>
            Represents a layer in an Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.IsVisible">
            <summary>
            Indicates whether this layer is visible.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.IsBackgroundLayer">
            <summary>
            Indicates whether this layer was marked as the background layer in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.IsReferenceLayer">
            <summary>
            Indicates whether this layer was marked as a reference layer containing a reference image in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.ChildLevel">
            <summary>
            Indicates the level of this layer in relation to its parent.
            </summary>
            <remarks>
            See <see href="https://github.com/aseprite/aseprite/blob/main/docs/ase-file-specs.md#note1"/> for more
            information.
            </remarks>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.BlendMode">
            <summary>
            Indicates the blend mode used by cels on this layer when cels blend with the cels on the layer below them
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.Opacity">
            <summary>
            Indicates the opacity level set for this layer in Aseprite, in the range of 0 - 255.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLayer.Name">
            <summary>
            The name given this layer in Aseprite.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteLayer.UserData">
            <summary>
            The custom user data that was set in the properties for this layer in Aseprite.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteLinkedCel">
            <summary>
            Represents a cel in an Aseprite file that is linked to another cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLinkedCel.Cel">
            <summary>
            The cel that this cel is linked to.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteLoopDirection">
            <summary>
            Defines the animation direction values set for a tag in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLoopDirection.Forward">
            <summary>
            Defines that the animation for the tag is played in a forward direction from the first frame of animation to
            the last.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLoopDirection.Reverse">
            <summary>
            Defines that hte animation for the tag is played in reverse from the last frame of animation to the first.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLoopDirection.PingPong">
            <summary>
            Defines that the animation for the tag ping-pongs by first going from the first frame of animation to the
            last frame, then playing in reverse from the last frame of animation to the first.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteLoopDirection.PingPongReverse">
            <summary>
            Defines that the animation for the tag ping-pongs by first going in reverse from the last frame of animation
            to the first frame, then playing forward from the first frame of animation to the last.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepritePalette">
            <summary>
            Represents the palette in an Aseprtie file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepritePalette.Colors">
            <summary>
            An array of color elements that contains the colors of this palette.  Order of color elements is the same as
            the order of colors in the palette in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepritePalette.TransparentIndex">
            <summary>
            The index of the color element in this palette that should be interpreted as a transparent color.
            </summary>
            <remarks>
            This value is only valid when the color depth mode of the Aseprite image was set to Indexed.
            </remarks>
        </member>
        <member name="T:Nez.Aseprite.AsepriteSlice">
            <summary>
            Represents a slice element in an Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSlice.Keys">
            <summary>
            A collection of all slice key elements for this slice.  Each key is similar to an animation key frame in
            that it defines the properties of this slice starting on a specified frame.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSlice.IsNinePatch">
            <summary>
            Indicates whether this slice was marked as a nine patch slice in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSlice.HasPivot">
            <summary>
            Indicates whether this slice was marked to have a pivot point in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSlice.Name">
            <summary>
            The name this slice was given in Aseprite.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteSlice.UserData">
            <summary>
            The custom user data that was set in the properties for this slice in Aseprite.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteSliceKey">
            <summary>
            Represents a key for a slice in Aseprite. 
            </summary>
            <remarks>
            A slice key can be thought of like frame keys in animations.  They contain the properties of the slice on a
            specific frame.
            </remarks>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSliceKey.Slice">
            <summary>
            The slice this key is for.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSliceKey.FrameIndex">
            <summary>
            The index of the frame in the Aseprite file that the properties of this key are applied to the slice on.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSliceKey.Bounds">
            <summary>
            A rectangle value that represents the location and size of the slice during this key.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSliceKey.CenterBounds">
            <summary>
            A rectangle value that represents the location and size of the center area of the slice during this key, if
            the slice is a nine patch slice; otherwise, this will be null.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteSliceKey.Pivot">
            <summary>
            A point value that indicates the x- and y-coordinate location relative to the bounds of the slice during
            this key tha the slice should pivot from, if the slice was marked to have a pivot point in Aseprite; 
            otherwise, this will be null.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteTag">
            <summary>
            Represents an animation tag define in the Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTag.From">
            <summary>
            The frame that the animation defined by this tag starts on.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTag.To">
            <summary>
            The frame that the animation defined by this tag ends on.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTag.LoopDirection">
            <summary>
            The loop direction defined for the animation represented by this tag.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTag.Name">
            <summary>
            The name given this tag in Aseprite.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Nez.Aseprite.AsepriteTag.Color" -->
        <member name="P:Nez.Aseprite.AsepriteTag.UserData">
            <summary>
            The custom user data that was set in the properties for this tag in Aseprite.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteTile">
            <summary>
            Represents a single tile in a tilemap cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTile.ID">
            <summary>
            The ID of the tile in the tileset this tile represents.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTile.XFlip">
            <summary>
            A value that indicates if this tile is flipped along the x-axis.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTile.YFlip">
            <summary>
            A value that indicates if this tile is flipped along the y-axis.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTile.Rotate90">
            <summary>
            A value that indicates the amount of 90deg clockwise rotation applied to this tile.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteTilemapCel">
            <summary>
            Represents a single cel in a frame that contains tilemap data.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.Width">
            <summary>
            The width, in tiles, of this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.Height">
            <summary>
            The height, in tiles, of this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.BitsPerTile">
            <summary>
            The total number of bits per tile for each tile in this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.TileIDBitmask">
            <summary>
            The bitmask used to determine the ID of tiles for this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.XFlipBitmask">
            <summary>
            The bitmask used to determine the x-flip property of the tiles in this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.YFlipBitmask">
            <summary>
            The bitmask used to determine the y-flip property of the tiles in this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.RotationBitmask">
            <summary>
            The bitmask used to determine the rotation property of the tiles in this cel.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapCel.Tiles">
            <summary>
            The collection of tiles that make up this cel.  Tile elements are in order of left-to-right, read
            top-to-bottom.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteTilemapLayer">
            <summary>
            Represents a layer in an Aseprite file that tilemap cels are placed on.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTilemapLayer.Tileset">
            <summary>
            The tileset that is used by all tilemap cels on this layer.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteTileset">
            <summary>
            Represents a tileset used by tilemap cels.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.ID">
            <summary>
            The ID of this tileset assigned in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.TileCount">
            <summary>
            The total number of tiles in this tileset.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.TileWidth">
            <summary>
            The width, in tiles, of this tileset.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.TileHeight">
            <summary>
            The height, in tiles, of this tileset.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.Name">
            <summary>
            The name assigned to this tileset in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteTileset.Pixels">
            <summary>
            An array of color elements that represent the pixel data for image of this tileset.  Order of elements is
            from top-left pixel read left-to-right top-to-bottom.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteToSpriteAtlasOptions">
            <summary>
            Defines the options to adhere to when generating a sprite atlas from an Aseprite file.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteToSpriteAtlasOptions.OnlyVisibleLayers">
            <summary>
            Indicates whether only visible layers in the Aseprite file should be processed when generating the sprite
            atlas
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteToSpriteAtlasOptions.BorderPadding">
            <summary>
            The amount of transparent pixels to add between each frame and the edge of the generated texture for the
            sprite atlas.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteToSpriteAtlasOptions.Spacing">
            <summary>
            The amount of transparent pixels to add between each frame of the generated texture for the sprite atlas.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteToSpriteAtlasOptions.InnerPadding">
            <summary>
            The amount of transparent pixels to add to the inside of each frame's edge of the generated texture for the
            sprite atlas.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteUserData">
            <summary>
            Represents the custom user data set for an element in Aseprite.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteUserData.HasText">
            <summary>
            Returns a value tha indicates whether custom text was set for this user data.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.AsepriteUserData.HasColor">
            <summary>
            Returns a value that indicates whether color was set for this user data.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteUserData.Text">
            <summary>
            The text that was set for this user data in Aseprite.
            </summary>
        </member>
        <member name="F:Nez.Aseprite.AsepriteUserData.Color">
            <summary>
            The color that was set for this user data in Aseprite, if a color was set; otherwise, null.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.IAsepriteUserData">
            <summary>
            Represents an element that can contain custom users data in Aseprite.
            </summary>
        </member>
        <member name="P:Nez.Aseprite.IAsepriteUserData.UserData">
            <summary>
            When implemented, contains the custom user data set for the element in Aseprite.
            </summary>
        </member>
        <member name="T:Nez.Aseprite.AsepriteFileLoader">
            <summary>
            Utility class used to load the contents of an Aseprite (.ase/.aseprite) file.
            </summary>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFileLoader.Load(System.String,System.Boolean)">
            <summary>
            Loads an Aseprite (.ase/.aseprite) file and creates an instance with the contents of the file.
            </summary>
            <param name="name">The name of the Aseprite (.ase/.aseprite) file to load</param>
            <param name="premultiplyAlpha">
            Indicates whether color data generated while reading the content of this Aseprite file should be
            premultipled.  Default is false.
            </param>
            <returns>
            A new instance of the <see cref="T:Nez.Aseprite.AsepriteFile"/> class initialized with the contents read from the Aseprite
            file.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if an error occurs while attempting to read the Aseprite file. See exception message for details.
            </exception>
        </member>
        <member name="M:Nez.Aseprite.AsepriteFileLoader.TryLoad(System.String,System.Boolean,Nez.Aseprite.AsepriteFile@)">
            <summary>
            Attempts to load an Aseprite (.ase/.aseprite) file and creates an instance with the contents of the file.
            </summary>
            <remarks>
            Errors occurred while attempting to load the Aseprite file will be logged in <see cref="T:Nez.Debug"/> output.
            </remarks>
            <param name="name">The name of the Aseprite (.ase/.aseprite) file to load</param>
            <param name="premultiplyAlpha">
            Indicates whether color data generated while reading the content of this Aseprite file should be
            premultipled.  Default is false.
            </param>
            <param name="file">
            When this method returns, if <see langword="true"/>, contains the contents of the Aseprite file that was
            loaded; otherwise, <see langword="null"/>.
            </param>
            <returns>
            <see langword="true"/> if the contents of the Aseprite file could be loaded without any issue; otherwise,
            <see langword="false"/>.
            </returns>
        </member>
        <member name="T:Nez.BitmapFonts.BatcherBitmapFontExt">
            <summary>
            provides the full SpriteFont assortment of drawString methods
            </summary>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
            <param name="rotation">A rotation of this string.</param>
            <param name="origin">Center of the rotation. 0,0 by default.</param>
            <param name="scale">A scaling of this string.</param>
            <param name="effects">Modificators for drawing. Can be combined.</param>
            <param name="layerDepth">A depth of the layer of this string.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
            <param name="rotation">A rotation of this string.</param>
            <param name="origin">Center of the rotation. 0,0 by default.</param>
            <param name="scale">A scaling of this string.</param>
            <param name="effects">Modificators for drawing. Can be combined.</param>
            <param name="layerDepth">A depth of the layer of this string.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
            <param name="rotation">A rotation of this string.</param>
            <param name="origin">Center of the rotation. 0,0 by default.</param>
            <param name="scale">A scaling of this string.</param>
            <param name="effects">Modificators for drawing. Can be combined.</param>
            <param name="layerDepth">A depth of the layer of this string.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BatcherBitmapFontExt.DrawString(Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="bitmapFont">A font.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
            <param name="rotation">A rotation of this string.</param>
            <param name="origin">Center of the rotation. 0,0 by default.</param>
            <param name="scale">A scaling of this string.</param>
            <param name="effects">Modificators for drawing. Can be combined.</param>
            <param name="layerDepth">A depth of the layer of this string.</param>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.kNoMaxWidth">
            <summary>
            When used with MeasureString, specifies that no wrapping should occur.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.AlphaChannel">
            <summary>
            alpha channel.
            </summary>
            <remarks>Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if it's set to zero, and 4 if it's set to one.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.BaseHeight">
            <summary>
            number of pixels from the absolute top of the line to the base of the characters.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.BlueChannel">
            <summary>
            blue channel.
            </summary>
            <remarks>Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if it's set to zero, and 4 if it's set to one.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Characters">
            <summary>
            characters that comprise the font.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Charset">
            <summary>
            name of the OEM charset used.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.FamilyName">
            <summary>
            name of the true type font.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.FontSize">
            <summary>
            size of the font.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.GreenChannel">
            <summary>
            green channel.
            </summary>
            <remarks>Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if it's set to zero, and 4 if it's set to one.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Kernings">
            <summary>
            character kernings for the font.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.LineHeight">
            <summary>
            distance in pixels between each line of text.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.OutlineSize">
            <summary>
            outline thickness for the characters.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Packed">
            <summary>
            Gets or sets a value indicating whether the monochrome charaters have been packed into each of the texture channels.
            </summary>
            <remarks>
            When packed, the <see cref="F:Nez.BitmapFonts.BitmapFont.AlphaChannel"/> property describes what is stored in each channel.
            </remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Padding">
            <summary>
            padding for each character.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Pages">
            <summary>
            texture pages for the font.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Textures">
            <summary>
            houses the Textures for each Page, with the same index as the Page.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.RedChannel">
            <summary>
            red channel.
            </summary>
            <remarks>Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if it's set to zero, and 4 if it's set to one.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Smoothed">
            <summary>
            Gets or sets a value indicating whether the font is smoothed.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.Spacing">
            <summary>
            spacing for each character.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.StretchedHeight">
            <summary>
            font height stretch.
            </summary>
            <remarks>100% means no stretch.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.SuperSampling">
            <summary>
            level of super sampling used by the font.
            </summary>
            <remarks>A value of 1 indicates no super sampling is in use.</remarks>
        </member>
        <member name="F:Nez.BitmapFonts.BitmapFont.TextureSize">
            <summary>
            size of the texture images used by the font.
            </summary>
        </member>
        <member name="P:Nez.BitmapFonts.BitmapFont.Item(System.Char)">
            <summary>
            Index to get items within thsi collection using array index syntax.
            </summary>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.GetKerning(System.Char,System.Char)">
            <summary>
            Gets the kerning for the specified character combination.
            </summary>
            <param name="previous">The previous character.</param>
            <param name="current">The current character.</param>
            <returns>
            The spacing between the specified characters.
            </returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.TruncateText(System.String,System.String,System.Single)">
            <summary>
            truncates text and returns a new string with ellipsis appended if necessary. This method ignores all
            line breaks.
            </summary>
            <returns>The text.</returns>
            <param name="text">Text.</param>
            <param name="ellipsis">Ellipsis.</param>
            <param name="maxLineWidth">Max line width.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.MeasureString(Nez.FontCharacterSource@,System.Single)">
            <summary>
            Provides the size, in pixels, of the specified text when drawn with this font, automatically wrapping to keep within the specified with.
            </summary>
            <param name="text">The text to measure.</param>
            <param name="maxWidth">The maximum width.</param>
            <returns>
            The size, in pixels, of <paramref name="text"/> drawn with this font.
            </returns>
            <remarks>The MeasureString method uses the <paramref name="maxWidth"/> parameter to automatically wrap when determining text size.</remarks>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.MeasureInt(System.Int32,System.Boolean)">
            <summary>
                Providers the size, in pixels, of the specified number when drawn with this font.
            </summary>
            <param name="number">The number to measure</param>
            <param name="useDefaultLineHeight">If true, only the lineHeight attribute of the bitmap font will be used to calculate the height.
            If false, the height of the character image and the y offset will be considered when calculating the height.</param>
            <returns>
                The size, in pixels, of <paramref name="number" /> drawn with this font.
            </returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.DrawInto(Nez.Batcher,Nez.FontCharacterSource@,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single,System.Collections.Generic.IDictionary{System.Int32,Microsoft.Xna.Framework.Color})">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            This method variant offers the ability to draw multicolored text by providing a colorMap.
            The colorMap is a dictionary where the key represents the zero-based index at which the text should
            start being displayed in a different color, and the value is the corresponding color.
             
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="text">The text which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask. Will be used as the initial color.</param>
            <param name="rotation">A rotation of this string.</param>
            <param name="origin">Center of the rotation.</param>
            <param name="scale">A scaling of this string.</param>
            <param name="effect">Modificators for drawing. Can be combined.</param>
            <param name="depth">A depth of the layer of this string.</param>
            <param name="colorMap">A dictionary where the key represents the zero-based index at which the text should start being displayed in a different color, and the value is the corresponding color. Must not be null.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.DrawInto(Nez.Batcher,System.Int32,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single,System.Boolean)">
            <summary>
            Submits a number for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="number">The number which will be drawn.</param>
            <param name="position">The drawing location on screen.</param>
            <param name="color">A color mask.</param>
            <param name="rotation">A rotation of this number.</param>
            <param name="origin">Center of the rotation.</param>
            <param name="scale">A scaling of this number.</param>
            <param name="effect">Modificators for drawing. Can be combined.</param>
            <param name="depth">A depth of the layer of this number.</param>
            <param name="useDefaultLineHeight">If true, only the lineHeight attribute of the bitmap font will be used to calculate the height.
            If false, the height of the character image and the y offset will be considered when calculating the height.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.Load(System.IO.Stream)">
            <summary>
            Load font information from the specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <exception cref="T:System.ArgumentException">Thrown when one or more arguments have unsupported or
            illegal values.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when an Invalid Data error condition occurs.</exception>
            <param name="stream">The stream to load.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.Load(System.String)">
            <summary>
            Load font information from the specified file.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the requested file is not present.</exception>
            <param name="filename">The file name to load.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadText(System.String)">
            <summary>
            Loads font information from the specified string.
            </summary>
            <param name="text">String containing the font to load.</param>
            <remarks>The source data must be in BMFont text format.</remarks>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadText(System.IO.Stream)">
            <summary>
            Loads font information from the specified stream.
            </summary>
            <remarks>
            The source data must be in BMFont text format.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <param name="stream">The stream containing the font to load.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadText(System.IO.TextReader)">
            <summary>
            Loads font information from the specified <see cref="T:System.IO.TextReader"/>.
            </summary>
            <remarks>
            The source data must be in BMFont text format.
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <param name="reader">The <strong>TextReader</strong> used to feed the data into the font.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadXml(System.String)">
            <summary>
            Loads font information from the specified string.
            </summary>
            <param name="xml">String containing the font to load.</param>
            <remarks>The source data must be in BMFont XML format.</remarks>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadXml(System.IO.Stream)">
            <summary>
            Loads font information from the specified stream. The source data must be in BMFont XML format.
            </summary>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFont.LoadXml(System.IO.TextReader)">
            <summary>
            Loads font information from the specified <see cref="T:System.IO.TextReader"/>.
            </summary>
        </member>
        <member name="T:Nez.BitmapFonts.BitmapFontEnumerator">
            <summary>
            returned by <seealso cref="M:Nez.BitmapFonts.BitmapFont.GetGlyphs(System.String)"/>, providing a way to iterate over a string. Can be drawn with
            <seealso cref="T:Nez.BitmapFonts.BatcherBitmapFontExt"/> or by iterating and drawing each glyph.
            </summary>
        </member>
        <member name="T:Nez.BitmapFonts.BitmapFontLoader">
            <summary>
            Parsing class for bitmap fonts generated by AngelCode BMFont
            </summary>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.LoadFontFromFile(System.String,System.Boolean)">
            <summary>
            Loads a bitmap font from a file, attempting nto auto detect the file type
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the requested file is not present.</exception>
            <exception cref="T:System.IO.InvalidDataException">Thrown when an Invalid Data error condition occurs.</exception>
            <param name="filename">Name of the file to load.</param>
            <returns>
            A <see cref="T:Nez.BitmapFonts.BitmapFont"/> containing the loaded data.
            </returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.LoadFontFromTextFile(System.String,System.Boolean)">
            <summary>
            Loads a bitmap font from a file containing font data in text format.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the requested file is not present.</exception>
            <param name="filename">Name of the file to load.</param>
            <returns>
            A <see cref="T:Nez.BitmapFonts.BitmapFont"/> containing the loaded data.
            </returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.LoadFontFromXmlFile(System.String,System.Boolean)">
            <summary>
            Loads a bitmap font from a file containing font data in XML format.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown when one or more required arguments are null.</exception>
            <exception cref="T:System.IO.FileNotFoundException">Thrown when the requested file is not present.</exception>
            <param name="filename">Name of the file to load.</param>
            <returns>
            A <see cref="T:Nez.BitmapFonts.BitmapFont"/> containing the loaded data.
            </returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.GetNamedBool(System.String[],System.String,System.Boolean)">
            <summary>
            Returns a boolean from an array of name/value pairs.
            </summary>
            <param name="parts">The array of parts.</param>
            <param name="name">The name of the value to return.</param>
            <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.GetNamedInt(System.String[],System.String,System.Int32)">
            <summary>
            Returns an integer from an array of name/value pairs.
            </summary>
            <param name="parts">The array of parts.</param>
            <param name="name">The name of the value to return.</param>
            <param name="defaultValue">Default value(if the key doesnt exist or can't be parsed)</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.GetNamedString(System.String[],System.String)">
            <summary>
            Returns a string from an array of name/value pairs.
            </summary>
            <param name="parts">The array of parts.</param>
            <param name="name">The name of the value to return.</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.ParsePadding(System.String)">
            <summary>
            Creates a Padding object from a string representation
            </summary>
            <param name="s">The string.</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.ParseInt2(System.String)">
            <summary>
            Creates a Point object from a string representation
            </summary>
            <param name="s">The string.</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.QualifyResourcePaths(Nez.BitmapFonts.BitmapFont,System.String)">
            <summary>
            Updates <see cref="T:Nez.BitmapFonts.Page"/> data with a fully qualified path
            </summary>
            <param name="font">The <see cref="T:Nez.BitmapFonts.BitmapFont"/> to update.</param>
            <param name="resourcePath">The path where texture resources are located.</param>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.Split(System.String,System.Char)">
            <summary>
            Splits the specified string using a given delimiter, ignoring any instances of the delimiter as part of a quoted string.
            </summary>
            <param name="s">The string to split.</param>
            <param name="delimiter">The delimiter.</param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BitmapFontLoader.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts the given collection into an array
            </summary>
            <typeparam name="T">Type of the items in the array</typeparam>
            <param name="values">The values.</param>
            <returns></returns>
        </member>
        <member name="T:Nez.BitmapFonts.BitmapFontReader">
            <summary>
            Legacy MonoGame Pipeline reader. This exists as legacy support to load the embedded Nez default font into the
            new runtime BitmapFont class
            </summary>
        </member>
        <member name="M:Nez.BitmapFonts.BMFontConverter.LoadSpriteFontFromBitmapFont(System.String)">
            <summary>
            Converts a BitmapFont to a SpriteFont
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.BitmapFonts.BMFontConverter.LoadSpriteFontFromBitmapFont(Nez.BitmapFonts.BitmapFont,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            converts a BitmapFont to a SpriteFont
            </summary>
            <param name="font"></param>
            <param name="texture"></param>
            <returns></returns>
        </member>
        <member name="T:Nez.BitmapFonts.Character">
            <summary>
            Represents the definition of a single character in a <see cref="T:Nez.BitmapFonts.BitmapFont"/>
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.Bounds">
            <summary>
            bounds of the character image in the source texture.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.Channel">
            <summary>
            texture channel where the character image is found.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.Char">
            <summary>
            character.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.Offset">
            <summary>
            offset when copying the image from the texture to the screen.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.TexturePage">
            <summary>
            texture page where the character image is found.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Character.XAdvance">
            <summary>
            value used to advance the current position after drawing the character.
            </summary>
        </member>
        <member name="T:Nez.BitmapFonts.Kerning">
            <summary>
            Represents the font kerning between two characters.
            </summary>
        </member>
        <member name="F:Nez.BitmapFonts.Kerning.Amount">
            <summary>
            Gets or sets how much the x position should be adjusted when drawing the second character immediately following the first.
            </summary>
        </member>
        <member name="T:Nez.BitmapFonts.Padding">
            <summary>
            Represents padding or margin information associated with an element.
            </summary>
        </member>
        <member name="T:Nez.BitmapFonts.Page">
            <summary>
            Represents a texture page.
            </summary>
        </member>
        <member name="M:Nez.ParticleDesigner.ParticleEmitterConfigLoader.Load(System.String)">
            <summary>
            parses a ParticleDesigner pex file or one exported from the Nez.Samples exporter or from Particle Editor:
            http://onebyonedesign.com/flash/particleeditor/
            </summary>
        </member>
        <member name="M:Nez.ParticleDesigner.ParticleEmitterConfigLoader.GetIntElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            for some reason, some pex exporters export ints like maxParticles as floats. This mess guards against that.
            </summary>
        </member>
        <member name="T:Nez.Systems.NezContentManager">
            <summary>
            ContentManager subclass that also manages Effects from ogl files. Adds asynchronous loading of assets as well.
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadTexture(System.String,System.Boolean)">
            <summary>
            loads a Texture2D either from xnb or directly from a png/jpg. Note that xnb files should not contain the .xnb file
            extension or be preceded by "Content" in the path. png/jpg files should have the file extension and have an absolute
            path or a path starting with "Content".
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadSoundEffect(System.String)">
            <summary>
            loads a SoundEffect either from xnb or directly from a wav. Note that xnb files should not contain the .xnb file
            extension or be preceded by "Content" in the path. wav files should have the file extension and have an absolute
            path or a path starting with "Content".
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadTiledMap(System.String)">
            <summary>
            loads a Tiled map
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadParticleEmitterConfig(System.String)">
            <summary>
            Loads a ParticleDesigner pex file
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadSpriteAtlas(System.String,System.Boolean)">
            <summary>
            Loads a SpriteAtlas created with the Sprite Atlas Packer tool
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadBitmapFont(System.String,System.Boolean)">
            <summary>
            Loads a BitmapFont
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadAsepriteFile(System.String)">
            <summary>
            Loads the contents of an Aseprite (.ase/.aseprite) file.
            </summary>
            <param name="name">The content path name of the Aseprite file to load.</param>
            <returns>
            A new instance of the <see cref="T:Nez.Aseprite.AsepriteFile"/> class initialized with the data read from the Aseprite
            file.
            </returns>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadJson(System.String)">
            <summary>
            loads a json file into a string.
            </summary>
            <returns>The json string.</returns>
            <param name="name">The json filename.</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadEffect(System.String)">
            <summary>
            loads an ogl effect directly from file and handles disposing of it when the ContentManager is disposed. Name should be the path
            relative to the Content folder or including the Content folder.
            </summary>
            <returns>The effect.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadNezEffect``1">
            <summary>
            loads an embedded Nez effect. These are any of the Effect subclasses in the Nez/Graphics/Effects folder.
            Note that this will return a unique instance if you attempt to load the same Effect twice to avoid Effect duplication.
            </summary>
            <returns>The nez effect.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadEffect``1(System.String)">
            <summary>
            loads an ogl effect directly from file and handles disposing of it when the ContentManager is disposed. Name should the the path
            relative to the Content folder or including the Content folder. Effects must have a constructor that accepts GraphicsDevice and
            byte[]. Note that this will return a unique instance if you attempt to load the same Effect twice to avoid Effect duplication.
            </summary>
            <returns>The effect.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadEffect``1(System.String,System.Byte[])">
            <summary>
            loads an ogl effect directly from its bytes and handles disposing of it when the ContentManager is disposed. Name should the the path
            relative to the Content folder or including the Content folder. Effects must have a constructor that accepts GraphicsDevice and
            byte[]. Note that this will return a unique instance if you attempt to load the same Effect twice to avoid Effect duplication.
            </summary>
            <returns>The effect.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadMonoGameEffect``1">
            <summary>
            loads and manages any Effect that is built-in to MonoGame such as BasicEffect, AlphaTestEffect, etc. Note that this will
            return a unique instance if you attempt to load the same Effect twice. If you intend to use the same Effect in multiple locations
            keep a reference to it and use it directly.
            </summary>
            <returns>The mono game effect.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadAsync``1(System.String,System.Action{``0})">
            <summary>
            loads an asset on a background thread with optional callback for when it is loaded. The callback will occur on the main thread.
            </summary>
            <param name="assetName">Asset name.</param>
            <param name="onLoaded">On loaded.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadAsync``1(System.String,System.Action{System.Object,``0},System.Object)">
            <summary>
            loads an asset on a background thread with optional callback that includes a context parameter for when it is loaded.
            The callback will occur on the main thread.
            </summary>
            <param name="assetName">Asset name.</param>
            <param name="onLoaded">On loaded.</param>
            <param name="context">Context.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LoadAsync``1(System.String[],System.Action)">
            <summary>
            loads a group of assets on a background thread with optional callback for when it is loaded
            </summary>
            <param name="assetNames">Asset names.</param>
            <param name="onLoaded">On loaded.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.UnloadAsset``1(System.String)">
            <summary>
            removes assetName from LoadedAssets and Disposes of it
            disposeableAssets List.
            </summary>
            <param name="assetName">Asset name.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Systems.NezContentManager.UnloadEffect(System.String)">
            <summary>
            unloads an Effect that was loaded via loadEffect, loadNezEffect or loadMonoGameEffect
            </summary>
            <param name="effectName">Effect.name</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.UnloadEffect(Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            unloads an Effect that was loaded via loadEffect, loadNezEffect or loadMonoGameEffect
            </summary>
        </member>
        <member name="M:Nez.Systems.NezContentManager.IsAssetLoaded(System.String)">
            <summary>
            checks to see if an asset with assetName is loaded
            </summary>
            <returns><c>true</c> if this instance is asset loaded the specified assetName; otherwise, <c>false</c>.</returns>
            <param name="assetName">Asset name.</param>
        </member>
        <member name="M:Nez.Systems.NezContentManager.LogLoadedAssets">
            <summary>
            provides a string suitable for logging with all the currently loaded assets and effects
            </summary>
            <returns>The loaded assets.</returns>
        </member>
        <member name="M:Nez.Systems.NezContentManager.GetPathForLoadedAsset(System.Object)">
            <summary>
            reverse lookup. Gets the asset path given the asset. This is useful for making editor and non-runtime stuff.
            </summary>
            <param name="asset"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.Systems.NezContentManager.Unload">
            <summary>
            override that disposes of all loaded Effects
            </summary>
        </member>
        <member name="T:Nez.Systems.NezGlobalContentManager">
            <summary>
            the only difference between this class and NezContentManager is that this one can load embedded resources from the Nez.dll
            </summary>
        </member>
        <member name="M:Nez.Systems.NezGlobalContentManager.OpenStream(System.String)">
            <summary>
            override that will load embedded resources if they have the "nez://" prefix
            </summary>
            <returns>The stream.</returns>
            <param name="assetName">Asset name.</param>
        </member>
        <member name="T:Nez.Systems.CoroutineManager">
            <summary>
            basic CoroutineManager. Coroutines can do the following:
            - yield return null (tick again the next frame)
            - yield return Coroutine.waitForSeconds( 3 ) (tick again after a 3 second delay)
            - yield return Coroutine.waitForSeconds( 5.5f ) (tick again after a 5.5 second delay)
            - yield return startCoroutine( another() ) (wait for the other coroutine before getting ticked again)
            </summary>
        </member>
        <member name="T:Nez.Systems.CoroutineManager.CoroutineImpl">
            <summary>
            internal class used by the CoroutineManager to hide the data it requires for a Coroutine
            </summary>
        </member>
        <member name="F:Nez.Systems.CoroutineManager.CoroutineImpl.WaitTimer">
            <summary>
            anytime a delay is yielded it is added to the waitTimer which tracks the delays
            </summary>
        </member>
        <member name="F:Nez.Systems.CoroutineManager._isInUpdate">
            <summary>
            flag to keep track of when we are in our update loop. If a new coroutine is started during the update loop we have to stick
            it in the shouldRunNextFrame List to avoid modifying a List while we iterate.
            </summary>
        </member>
        <member name="M:Nez.Systems.CoroutineManager.StopAllCoroutines">
            <summary>
            Stops all active coroutines. Can be safely called from inside a coroutine, though the coroutine will continue executing
            until the next yield. Some coroutines might not be returned to the pool for reuse until the next Update() cycle.
            </summary>
        </member>
        <member name="M:Nez.Systems.CoroutineManager.ClearAllCoroutines">
            <summary>
            Immediately clears all coroutines and returns them to the pool for reuse. Do not to call this from inside one of 
            the manager's coroutines.
            </summary>
        </member>
        <member name="M:Nez.Systems.CoroutineManager.StartCoroutine(System.Collections.IEnumerator)">
            <summary>
            adds the IEnumerator to the CoroutineManager. Coroutines get ticked before Update is called each frame.
            </summary>
            <returns>The coroutine.</returns>
            <param name="enumerator">Enumerator.</param>
        </member>
        <member name="M:Nez.Systems.CoroutineManager.TickCoroutine(Nez.Systems.CoroutineManager.CoroutineImpl)">
            <summary>
            ticks a coroutine. returns true if the coroutine should continue to run next frame. This method will put finished coroutines
            back in the Pool!
            </summary>
            <returns><c>true</c>, if coroutine was ticked, <c>false</c> otherwise.</returns>
            <param name="coroutine">Coroutine.</param>
        </member>
        <member name="T:Nez.Systems.Emitter`1">
            <summary>
            simple event emitter that is designed to have its generic contraint be either an int or an enum
            </summary>
        </member>
        <member name="M:Nez.Systems.Emitter`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            if using an enum as the generic constraint you may want to pass in a custom comparer to avoid boxing/unboxing. See the CoreEventsComparer
            for an example implementation.
            </summary>
            <param name="customComparer">Custom comparer.</param>
        </member>
        <member name="T:Nez.Systems.Emitter`2">
            <summary>
            simple event emitter that is designed to have its generic contraint be either an int or an enum. this variant lets you pass around
            data with each event. See InputEvent for an example.
            </summary>
        </member>
        <member name="M:Nez.Systems.Emitter`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            if using an enum as the generic constraint you may want to pass in a custom comparer to avoid boxing/unboxing. See the CoreEventsComparer
            for an example implementation.
            </summary>
            <param name="customComparer">Custom comparer.</param>
        </member>
        <member name="T:Nez.Sprites.SpriteAtlasData">
            <summary>
            temporary class used when loading a SpriteAtlas and by the sprite atlas editor
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAtlasLoader.ParseSpriteAtlas(System.String,System.Boolean)">
            <summary>
            parses a .atlas file and loads up a SpriteAtlas with it's associated Texture
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAtlasLoader.ParseSpriteAtlasData(System.String,System.Boolean)">
            <summary>
            parses a .atlas file into a temporary SpriteAtlasData class. If leaveOriginsRelative is true, origins will be left as 0 - 1 range instead
            of multiplying them by the width/height.
            </summary>
        </member>
        <member name="T:Nez.Sprites.ScrollingSpriteRenderer">
            <summary>
            Scrolling sprite. Note that ScrollingSprite overrides the Material so that it can wrap the UVs. This class requires the texture
            to not be part of an atlas so that wrapping can work.
            </summary>
        </member>
        <member name="F:Nez.Sprites.ScrollingSpriteRenderer.ScrollSpeedX">
            <summary>
            x speed of automatic scrolling in pixels/s
            </summary>
        </member>
        <member name="F:Nez.Sprites.ScrollingSpriteRenderer.ScrollSpeedY">
            <summary>
            y speed of automatic scrolling in pixels/s
            </summary>
        </member>
        <member name="P:Nez.Sprites.ScrollingSpriteRenderer.TextureScale">
            <summary>
            scale of the texture
            </summary>
            <value>The texture scale.</value>
        </member>
        <member name="T:Nez.Sprites.SpriteAnimator">
            <summary>
            SpriteAnimator handles the display and animation of a sprite
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.LoopMode.Loop">
            <summary>
            Play the sequence in a loop forever [A][B][C][A][B][C][A][B][C]...
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.LoopMode.Once">
            <summary>
            Play the sequence once [A][B][C] then pause and set time to 0 [A]
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.LoopMode.ClampForever">
            <summary>
            Plays back the animation once, [A][B][C]. When it reaches the end, it will keep playing the last frame and never stop playing
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.LoopMode.PingPong">
            <summary>
            Play the sequence in a ping pong loop forever [A][B][C][B][A][B][C][B]...
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.LoopMode.PingPongOnce">
            <summary>
            Play the sequence once forward then back to the start [A][B][C][B][A] then pause and set time to 0
            </summary>
        </member>
        <member name="E:Nez.Sprites.SpriteAnimator.OnAnimationCompletedEvent">
            <summary>
            fired when an animation completes, includes the animation name;
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteAnimator.Speed">
            <summary>
            animation playback speed
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.AnimationState">
            <summary>
            the current state of the animation
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.CurrentAnimation">
            <summary>
            the current animation
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.CurrentAnimationName">
            <summary>
            the name of the current animation
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.CurrentFrame">
            <summary>
            index of the current frame in sprite array of the current animation
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.FrameCount">
            <summary>
            amount of frames in the current animation
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.CurrentElapsedTime">
            <summary>
            returns the total elapsed time of the animation.
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.Animations">
            <summary>
            Provides access to list of available animations
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.CurrentLoopMode">
            <summary>
            Mode of looping the animation.
            It can have 5 different values: Loop, Once, ClampForever, PingPong and PingPongOnce. Defaults to Loop.
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.FrameTimeLeft">
            <summary>
            The amount of seconds remaining in the current frame
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.AddAnimationsFromAtlas(Nez.Sprites.SpriteAtlas)">
            <summary>
            adds all the animations from the SpriteAtlas
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.AddAnimation(System.String,Nez.Sprites.SpriteAnimation)">
            <summary>
            Adds a SpriteAnimation
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.IsAnimationActive(System.String)">
            <summary>
            checks to see if the animation is playing (i.e. the animation is active. it may still be in the paused state)
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteAnimator.IsRunning">
            <summary>
            checks to see if the CurrentAnimation is running
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.Play(System.String,Nez.Sprites.SpriteAnimator.LoopMode)">
            <summary>
            plays the animation with the given name. If no loopMode is specified it is defaults to Loop
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.Pause">
            <summary>
            pauses the animator
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.UnPause">
            <summary>
            unpauses the animator
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.Stop">
            <summary>
            stops the current animation and nulls it out
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.SetFrame(System.Int32)">
            <summary>
            Sets the current frame for the animation
            </summary>
            <param name="frameIndex">Index of the desired frame</param>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.SetCompleted(System.Boolean)">
            <summary>
            Sets the animation as completed
            </summary>
            <param name="returnToFirstFrame">If the animation should return to the first frame before finishing</param>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.ShouldChangeFrame">
            <summary>
            Checks if it needs to change the current animation frame
            </summary>
            <returns>True if it does need to change frame, false otherwise</returns>
        </member>
        <member name="M:Nez.Sprites.SpriteAnimator.ConvertFrameRateToSeconds(System.Single)">
            <summary>
            Converts an animation frame rate (1/60s) to seconds
            </summary>
            <param name="frameRate"></param>
            <returns>The number of seconds as a float</returns>
        </member>
        <member name="T:Nez.Sprites.SpriteMime">
            <summary>
            this component will draw the same frame of spriteToMime every frame. The only difference in rendering is that SpriteMime uses its own
            localOffset and color. This allows you to use it for the purpose of shadows (by offsetting via localPosition) or silhouettes (with a
            Material that has a stencil read).
            </summary>
        </member>
        <member name="T:Nez.Sprites.SpriteRenderer">
            <summary>
            the most basic and common Renderable. Renders a Sprite/Texture.
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteRenderer.Origin">
            <summary>
            the origin of the Sprite. This is set automatically when setting a Sprite.
            </summary>
            <value>The origin.</value>
        </member>
        <member name="P:Nez.Sprites.SpriteRenderer.OriginNormalized">
            <summary>
            helper property for setting the origin in normalized fashion (0-1 for x and y)
            </summary>
            <value>The origin normalized.</value>
        </member>
        <member name="P:Nez.Sprites.SpriteRenderer.FlipX">
            <summary>
            determines if the sprite should be rendered normally or flipped horizontally
            </summary>
            <value><c>true</c> if flip x; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.Sprites.SpriteRenderer.FlipY">
            <summary>
            determines if the sprite should be rendered normally or flipped vertically
            </summary>
            <value><c>true</c> if flip y; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetFlipXAndAdjustLocalOffset(System.Boolean)">
            <summary>
            Set the FlipX but also adjust the LocalOffset to account for the flip.  
            This multiplies the x value of your LocalOffset by -1 so the sprite will appear in the expected place relative to your entity 
            </summary>
            <param name="isFlippedX"></param>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetFlipYAndAdjustLocalOffset(System.Boolean)">
             <summary>
            Set the FlipY but also adjust the LocalOffset to account for the flip.  
             This multiplies the y value of your LocalOffset by -1 so the sprite will appear in the expected place relative to your entity 
             </summary>
             <param name="isFlippedY"></param>
        </member>
        <member name="F:Nez.Sprites.SpriteRenderer.SpriteEffects">
            <summary>
            Batchers passed along to the Batcher when rendering. flipX/flipY are helpers for setting this.
            </summary>
        </member>
        <member name="P:Nez.Sprites.SpriteRenderer.Sprite">
            <summary>
            the Sprite that should be displayed by this Sprite. When set, the origin of the Sprite is also set to match Sprite.origin.
            </summary>
            <value>The sprite.</value>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetSprite(Nez.Textures.Sprite)">
            <summary>
            sets the Sprite and updates the origin of the Sprite to match Sprite.origin. If for whatever reason you need
            an origin different from the Sprite either clone it or set the origin AFTER setting the Sprite here.
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetTexture(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets the Texture by creating a new sprite. See SetSprite() for details.
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetOrigin(Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets the origin for the Renderable
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.SetOriginNormalized(Microsoft.Xna.Framework.Vector2)">
            <summary>
            helper for setting the origin in normalized fashion (0-1 for x and y)
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteRenderer.DrawOutline(Nez.Batcher,Nez.Camera,System.Int32)">
            <summary>
            Draws the Renderable with an outline. Note that this should be called on disabled Renderables since they shouldnt take part in default
            rendering if they need an ouline.
            </summary>
        </member>
        <member name="T:Nez.Sprites.SpriteTrail">
            <summary>
            renders and fades a series of copies of the Sprite on the same Entity. minDistanceBetweenInstances determines how often a trail
            sprite is added.
            </summary>
        </member>
        <member name="T:Nez.Sprites.SpriteTrail.SpriteTrailInstance">
            <summary>
            helper class that houses the data required for the individual trail instances
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteTrail.SpriteTrailInstance.Update">
            <summary>
            returns true when the fade out is complete
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail.MinDistanceBetweenInstances">
            <summary>
            how far does the Sprite have to move before a new instance is spawned
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail.FadeDuration">
            <summary>
            total duration of the fade from initialColor to fadeToColor
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail.FadeDelay">
            <summary>
            delay before starting the color fade
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail.InitialColor">
            <summary>
            initial color of the trail instances
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail.FadeToColor">
            <summary>
            final color that will be lerped to over the course of fadeDuration
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail._isFirstInstance">
            <summary>
            flag when true it will always add a new instance regardless of the distance check
            </summary>
        </member>
        <member name="F:Nez.Sprites.SpriteTrail._awaitingDisable">
            <summary>
            if awaitingDisable all instances are allowed to fade out before the component is disabled
            </summary>
        </member>
        <member name="M:Nez.Sprites.SpriteTrail.EnableSpriteTrail">
            <summary>
            enables the SpriteTrail
            </summary>
            <returns>The sprite trail.</returns>
        </member>
        <member name="M:Nez.Sprites.SpriteTrail.DisableSpriteTrail(System.Boolean)">
            <summary>
            disables the SpriteTrail optionally waiting for the current trail to fade out first
            </summary>
            <param name="completeCurrentTrail">If set to <c>true</c> complete current trail.</param>
        </member>
        <member name="M:Nez.Sprites.SpriteTrail.SpawnInstance">
            <summary>
            stores the last position for distance calculations and spawns a new trail instance if there is one available in the stack
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.GetTile(System.Int32,System.Int32)">
            <summary>
            gets the TmxLayerTile at the x/y coordinates. Note that these are tile coordinates not world coordinates!
            </summary>
            <returns>The tile.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.GetTileAtWorldPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            gets the TmxLayerTile at the given world position
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.GetCollisionRectangles">
            <summary>
            Returns a list of rectangles in tile space, where any non-null tile is combined into bounding regions
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.FindBoundsRect(System.Int32,System.Int32,System.Int32,System.Nullable{System.Boolean}[])">
            <summary>
            Finds the largest bounding rect around tiles between startX and endX, starting at startY and going
            down as far as possible
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.GetTilesIntersectingBounds(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            gets a List of all the TiledTiles that intersect the passed in Rectangle. The returned List can be put back in the pool via ListPool.free.
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.SetTile(System.Int32,System.Int32,Nez.Tiled.TmxLayerTile)">
            <summary>
            sets the tile.
            </summary>
            <returns>The tile.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="tile">Tile.</param>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.SetTile(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the tile at position x, y.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="gid">Global Tile ID (without the flip flags)</param>
            <param name="flipHorizontally">Should the tile be flipped horizontally?</param>
            <param name="flipVertically">Should the tile be flipped vertically?</param>
            <param name="flipDiagonally">Should the tile be flipped diagonally?</param>
            <returns>The tile.</returns>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.RemoveTile(System.Int32,System.Int32)">
            <summary>
            nulls out the tile at the x/y coordinates
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="F:Nez.Tiled.TmxLayer.Width">
            <summary>
            width in tiles for this layer. Always the same as the map width for fixed-size maps.
            </summary>
        </member>
        <member name="F:Nez.Tiled.TmxLayer.Height">
            <summary>
            height in tiles for this layer. Always the same as the map height for fixed-size maps.
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayer.GetTileWithGid(System.UInt32)">
            <summary>
            returns the TmxLayerTile with gid. This is a slow lookup so cache it!
            </summary>
            <param name="gid"></param>
            <returns></returns>
        </member>
        <member name="T:Nez.Tiled.TmxMap">
            <summary>
            contains runtime querying and other helper methods seperate from the tmx parsing in the other partial
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetTilesetForTileGid(System.Int32)">
            <summary>
            gets the TiledTileset for the given tileId
            </summary>
            <returns>The tileset for tile identifier.</returns>
            <param name="gid">Identifier.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetTilesetTile(System.Int32)">
            <summary>
            returns the TmxTilesetTile for the given id or null if none exists. TmxTilesetTiles exist only for animated tiles
            and tiles with properties set.
            </summary>
            <returns>The tileset tile.</returns>
            <param name="gid">Identifier.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetLayer(System.String)">
            <summary>
            gets the TiledLayer by name
            </summary>
            <returns>The layer.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetLayer``1(System.Int32)">
            <summary>
            gets the ITmxLayer by index
            </summary>
            <returns>The layer.</returns>
            <param name="index">Index.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetLayer``1(System.String)">
            <summary>
            gets the ITmxLayer by name
            </summary>
            <returns>The layer.</returns>
            <param name="name">Name.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Tiled.TmxMap.GetObjectGroup(System.String)">
            <summary>
            gets the TmxObjectGroup with the given name
            </summary>
            <returns>The object group.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.WorldToTilePosition(Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            converts from world to tile position clamping to the tilemap bounds
            </summary>
            <returns>The to tile position.</returns>
            <param name="pos">Position.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.WorldToTilePositionX(System.Single,System.Boolean)">
            <summary>
            converts from world to tile position clamping to the tilemap bounds
            </summary>
            <returns>The to tile position x.</returns>
            <param name="x">The x coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.WorldToTilePositionY(System.Single,System.Boolean)">
            <summary>
            converts from world to tile position clamping to the tilemap bounds
            </summary>
            <returns>The to tile position y.</returns>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.TileToWorldPosition(Microsoft.Xna.Framework.Point)">
            <summary>
            converts from tile to world position
            </summary>
            <returns>The to world position.</returns>
            <param name="pos">Position.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.TileToWorldPositionX(System.Int32)">
            <summary>
            converts from tile to world position
            </summary>
            <returns>The to world position x.</returns>
            <param name="x">The x coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.TileToWorldPositionY(System.Int32)">
            <summary>
            converts from tile to world position
            </summary>
            <returns>The to world position y.</returns>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.HexagonalWorldToTilePosition(Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            converts from world to tile position for hexagonal map clamping to the tilemap bounds
            </summary>
            <returns>The to tile position.</returns>
            <param name="pos">Position.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.HexagonalWorldToTilePosition(System.Single,System.Single,System.Boolean)">
            <summary>
            converts from world to tile position for hexagonal map clamping to the tilemap bounds
            </summary>
            <returns>The to tile position.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.Tiled.TmxMap.HexagonalTileToWorldPosition(Microsoft.Xna.Framework.Point)" -->
        <member name="M:Nez.Tiled.TmxMap.HexagonalTileToWorldPosition(System.Int32,System.Int32)">
            <summary>
            converts from hexagonal tile to world position
            </summary>
            <returns>The to world position.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.IsometricWorldToTilePosition(Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            converts from world to tile position for isometric map clamping to the tilemap bounds
            </summary>
            <returns>The to tile position.</returns>
            <param name="pos">Position.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.IsometricWorldToTilePosition(System.Single,System.Single,System.Boolean)">
            <summary>
            converts from world to tile position for isometric map clamping to the tilemap bounds
            </summary>
            <returns>The to tile position.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.Tiled.TmxMap.IsometricTileToWorldPosition(Microsoft.Xna.Framework.Point)" -->
        <member name="M:Nez.Tiled.TmxMap.IsometricTileToWorldPosition(System.Int32,System.Int32)">
            <summary>
            converts from isometric tile to world position
            </summary>
            <returns>The to world position.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Tiled.TmxMap.ToWorldPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Converts a position to world position with respect to the Map's projection. Useful for placing Tiled Objects accurately.
            </summary>
            <param name="pos">The position.</param>
            <returns>The world position.</returns>
        </member>
        <member name="F:Nez.Tiled.TmxMap.Layers">
            <summary>
            contains all of the ITmxLayers, regardless of their specific type. Note that layers in a TmxGroup will not
            be in this list. TmxGroup manages its own layers list.
            </summary>
        </member>
        <member name="F:Nez.Tiled.TmxMap.MaxTileWidth">
            <summary>
            when we have an image tileset, tiles can be any size so we record the max size for culling
            </summary>
        </member>
        <member name="F:Nez.Tiled.TmxMap.MaxTileHeight">
            <summary>
            when we have an image tileset, tiles can be any size so we record the max size for culling
            </summary>
        </member>
        <member name="P:Nez.Tiled.TmxMap.RequiresLargeTileCulling">
            <summary>
            does this map have non-default tile sizes that would require special culling?
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxMap.Update">
            <summary>
            currently only used to tick all the Tilesets so they can update their animated tiles
            </summary>
        </member>
        <member name="M:Nez.Tiled.TiledMapLoader.ParseLayers(System.Object,System.Xml.Linq.XElement,Nez.Tiled.TmxMap,System.Int32,System.Int32,System.String,Nez.Systems.NezContentManager)">
            <summary>
            parses all the layers in xEle putting them in the container
            </summary>
        </member>
        <member name="T:Nez.Tiled.TiledRendering">
            <summary>
            helper class to deal with rendering Tiled maps
            </summary>
        </member>
        <member name="M:Nez.Tiled.TiledRendering.RenderMap(Nez.Tiled.TmxMap,Nez.Batcher,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,Nez.RectangleF)">
            <summary>
            naively renders every layer present in the tilemap
            </summary>
            <param name="map"></param>
            <param name="batcher"></param>
            <param name="scale"></param>
            <param name="layerDepth"></param>
            <param name="cameraClipBounds"></param>
        </member>
        <member name="M:Nez.Tiled.TiledRendering.RenderLayer(Nez.Tiled.ITmxLayer,Nez.Batcher,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,Nez.RectangleF)">
            <summary>
            renders the ITmxLayer by calling through to the concrete type's render method
            </summary>
        </member>
        <member name="M:Nez.Tiled.TiledRendering.RenderLayer(Nez.Tiled.TmxLayer,Nez.Batcher,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            renders all tiles with no camera culling performed
            </summary>
            <param name="layer"></param>
            <param name="batcher"></param>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="layerDepth"></param>
        </member>
        <member name="M:Nez.Tiled.TiledRendering.RenderLayer(Nez.Tiled.TmxLayer,Nez.Batcher,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single,Nez.RectangleF)">
            <summary>
            renders all tiles that are inside <paramref name="cameraClipBounds"/>
            </summary>
            <param name="layer"></param>
            <param name="batcher"></param>
            <param name="position"></param>
            <param name="scale"></param>
            <param name="layerDepth"></param>
            <param name="cameraClipBounds"></param>
        </member>
        <member name="P:Nez.Tiled.TmxLayerTile.TilesetTile">
            <summary>
            gets the TmxTilesetTile for this TmxLayerTile if it exists. TmxTilesetTile only exist for animated tiles and tiles with attached
            properties.
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTile.GetRawGid(System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Applies the given flip flags to the given Global Tile ID.
            </summary>
            <param name="gid">Global Tile ID (without the flip flags)</param>
            <param name="flipHorizontally">Horizontally flipped?</param>
            <param name="flipVertically">Vertically flipped?</param>
            <param name="flipDiagonally">Diagonally flipped?</param>
            <returns>Global Tile ID (with the flip flags)</returns>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTile.ClearFlipFlags(System.UInt32)">
            <summary>
            Clears flip flags from the given Global Tile Id.
            </summary>
            <param name="rawGid">Global Tile ID (with the flip flags)</param>
            <returns>Global Tile ID (without the flip flags)</returns>
        </member>
        <member name="F:Nez.Tiled.TmxTileset.TileRegions">
            <summary>
            cache of the source rectangles for each tile
            </summary>
        </member>
        <member name="F:Nez.Tiled.TmxTilesetTile.IsDestructable">
            <summary>
            returns the value of an "nez:isDestructable" property if present in the properties dictionary
            </summary>
            <value><c>true</c> if is destructable; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Nez.Tiled.TmxTilesetTile.IsSlope">
            <summary>
            returns the value of a "nez:isSlope" property if present in the properties dictionary
            </summary>
            <value>The is slope.</value>
        </member>
        <member name="F:Nez.Tiled.TmxTilesetTile.IsOneWayPlatform">
            <summary>
            returns the value of a "nez:isOneWayPlatform" property if present in the properties dictionary
            </summary>
        </member>
        <member name="F:Nez.Tiled.TmxTilesetTile.SlopeTopLeft">
            <summary>
            returns the value of a "nez:slopeTopLeft" property if present in the properties dictionary
            </summary>
            <value>The slope top left.</value>
        </member>
        <member name="F:Nez.Tiled.TmxTilesetTile.SlopeTopRight">
            <summary>
            returns the value of a "nez:slopeTopRight" property if present in the properties dictionary
            </summary>
            <value>The slope top right.</value>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.IsSlope(Nez.Tiled.TmxLayerTile)">
            <summary>
            passthrough to TilesetTile
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.IsOneWayPlatform(Nez.Tiled.TmxLayerTile)">
            <summary>
            passthrough to TilesetTile
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetSlopeTopLeft(Nez.Tiled.TmxLayerTile)">
            <summary>
            returns the slope top left taking flipping into account. Exceptions if the tile is not a slope.
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetSlopeTopRight(Nez.Tiled.TmxLayerTile)">
            <summary>
            returns the slope top right taking flipping into account. Exceptions if the tile is not a slope.
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetSlope(Nez.Tiled.TmxLayerTile)">
            <summary>
            calculates the slope based on the slope top left/right
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetSlopeOffset(Nez.Tiled.TmxLayerTile)">
            <summary>
            returns the slope position on the left side of the tile. b in the y = mx + b equation
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetHighestSlopeEdge(Nez.Tiled.TmxLayerTile)">
            <summary>
            returns the edge on the side that has the tallest side
            </summary>
        </member>
        <member name="M:Nez.Tiled.TmxLayerTileExt.GetNearestEdge(Nez.Tiled.TmxLayerTile,System.Int32,System.Int32)">
            <summary>
            returns the nearest edge to worldPosition
            </summary>
        </member>
        <member name="T:Nez.Tiled.TiledMapMover">
             <summary>
             WIP
             The TiledMapMover is a helper for moving objects around in a gravity-based Tiled map. It requires that the Entity it is on has a BoxCollider. The
             BoxCollider will be used in conjunction with colliderHorizontal/VerticalInset for all collision detection.
            
             One way platforms can be jumped down through by moving your Transform down 1 pixel and calling CollisionState.clearLastGroundTile.
            
             If you plan to use slopes/one way platforms with the TiledMapMover some extra properties need to be added to your tiles in Tiled.
             They are listed below:
             - nez:isOneWayPlatform (bool): one way platforms will ignore all collisions except from above
             - nez:isSlope (bool): signifies if the tile is a slope. Requires the next two properties if it is
             - nez:slopeTopLeft (int): distance in pixels from the tiles top to the slope on the left side. For example, a 45 top-left to bottom-right
             tile |\ would have a slopeTopLeft of 0 and slopeTopRight of 15
             - nez:slopeTopRight (int): distance in pixels from the tiles top to the slope on the right side
             </summary>
        </member>
        <member name="T:Nez.Tiled.TiledMapMover.CollisionState">
            <summary>
            class used to house all the collision information from a call to move
            </summary>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.CollisionState.Reset(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            resets collision state and does sub-pixel movement calculations
            </summary>
            <param name="motion">Motion.</param>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover.ColliderHorizontalInset">
            <summary>
            the inset on the horizontal plane that the BoxCollider will be shrunk by when moving vertically
            </summary>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover.ColliderVerticalInset">
            <summary>
            the inset on the vertical plane that the BoxCollider will be shrunk by when moving horizontally
            </summary>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover.CollisionLayer">
            <summary>
            the TiledTileLayer used for collision checks
            </summary>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover.TiledMap">
            <summary>
            the TiledMap that contains collisionLayer
            </summary>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover._collidingTilesCoordinates">
            <summary>
            temporary storage for all the coordinates of tiles that intersect the bounds being checked
            </summary>
        </member>
        <member name="F:Nez.Tiled.TiledMapMover._boxColliderBounds">
            <summary>
            temporary storage to avoid having to pass it around
            </summary>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.Move(Microsoft.Xna.Framework.Vector2,Nez.BoxCollider,Nez.Tiled.TiledMapMover.CollisionState)">
            <summary>
            moves the Entity taking into account the tiled map
            </summary>
            <param name="motion">Motion.</param>
            <param name="boxCollider">Box collider.</param>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.IsSlopeCollisionRow(System.Int32)">
            <summary>
            Checks whether collision is occurring with a slope on a given row.
            </summary>
            <returns>Whether collision is occurring with a slope on a given row</returns>
            <param name="rowY">the row to check</param>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.TestTileCollision(Nez.Tiled.TmxLayerTile,System.Int32,System.Int32,Nez.Edge,System.Int32,System.Int32,System.Boolean,System.Int32@)">
            <summary>
            Tests the tile for a collision. Returns via out the position in world space where the collision occured.
            </summary>
            <returns>The tile collision.</returns>
            <param name="tile">Tile.</param>
            /// <param name="x">x position of the tile.</param>
            /// <param name="y">y position of the tile..</param>
            <param name="edgeToTest">the opposite side of movement, the side the leading edge will collide with</param>
            <param name="perpindicularPosition">Perpindicular position.</param>
            <param name="leadingPosition">Leading position.</param>
            <param name="shouldTestSlopes">Should test slopes.</param>
            <param name="collisionResponse">Collision response.</param>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.PopulateCollidingTiles(Microsoft.Xna.Framework.Rectangle,Nez.Edge)">
            <summary>
            gets a list of all the tiles intersecting bounds. The returned list is ordered for collision detection based on the
            direction passed in so they can be processed in order.
            </summary>
            <returns>The colliding tiles.</returns>
            <param name="bounds">Bounds.</param>
            <param name="direction">Direction.</param>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.WorldToTilePosition(System.Single,Nez.Axis)">
            <summary>
            returns the tile position clamped to the tiled map
            </summary>
            <returns>The to tile position.</returns>
            <param name="worldPosition">World position.</param>
            <param name="axis">Axis.</param>
        </member>
        <member name="M:Nez.Tiled.TiledMapMover.CollisionRectForSide(Nez.Edge,System.Int32)">
            <summary>
            gets a collision rect for the given side expanded to take into account motion
            </summary>
            <returns>The rect for side.</returns>
            <param name="side">Side.</param>
            <param name="motion">Motion.</param>
        </member>
        <member name="F:Nez.Core.Emitter">
            <summary>
            core emitter. emits only Core level events.
            </summary>
        </member>
        <member name="F:Nez.Core.ExitOnEscapeKeypress">
            <summary>
            enables/disables if we should quit the app when escape is pressed
            </summary>
        </member>
        <member name="F:Nez.Core.PauseOnFocusLost">
            <summary>
            enables/disables pausing when focus is lost. No update or render methods will be called if true when not in focus.
            </summary>
        </member>
        <member name="F:Nez.Core.DebugRenderEnabled">
            <summary>
            enables/disables debug rendering
            </summary>
        </member>
        <member name="F:Nez.Core.GraphicsDevice">
            <summary>
            global access to the graphicsDevice
            </summary>
        </member>
        <member name="F:Nez.Core.Content">
            <summary>
            global content manager for loading any assets that should stick around between scenes
            </summary>
        </member>
        <member name="F:Nez.Core.DefaultSamplerState">
            <summary>
            default SamplerState used by Materials. Note that this must be set at launch! Changing it after that time will result in only
            Materials created after it was set having the new SamplerState
            </summary>
        </member>
        <member name="P:Nez.Core.DefaultWrappedSamplerState">
            <summary>
            default wrapped SamplerState. Determined by the Filter of the defaultSamplerState.
            </summary>
            <value>The default state of the wraped sampler.</value>
        </member>
        <member name="P:Nez.Core.Services">
            <summary>
            default GameServiceContainer access
            </summary>
            <value>The services.</value>
        </member>
        <member name="P:Nez.Core.Instance">
            <summary>
            provides access to the single Core/Game instance
            </summary>
        </member>
        <member name="F:Nez.Core._instance">
            <summary>
            facilitates easy access to the global Content instance for internal classes
            </summary>
        </member>
        <member name="F:Nez.Core._graphicsDeviceChangeTimer">
            <summary>
            used to coalesce GraphicsDeviceReset events
            </summary>
        </member>
        <member name="P:Nez.Core.Scene">
            <summary>
            The currently active Scene. Note that if set, the Scene will not actually change until the end of the Update
            </summary>
        </member>
        <member name="M:Nez.Core.OnGraphicsDeviceReset(System.Object,System.EventArgs)">
            <summary>
            this gets called whenever the screen size changes
            </summary>
            <param name="sender">Sender.</param>
            <param name="e">E.</param>
        </member>
        <member name="M:Nez.Core.OnSceneChanged">
            <summary>
            Called after a Scene ends, before the next Scene begins
            </summary>
        </member>
        <member name="M:Nez.Core.StartSceneTransition``1(``0)">
            <summary>
            temporarily runs SceneTransition allowing one Scene to transition to another smoothly with custom effects.
            </summary>
            <param name="sceneTransition">Scene transition.</param>
        </member>
        <member name="M:Nez.Core.RegisterGlobalManager(Nez.GlobalManager)">
            <summary>
            adds a global manager object that will have its update method called each frame before Scene.update is called
            </summary>
            <returns>The global manager.</returns>
            <param name="manager">Manager.</param>
        </member>
        <member name="M:Nez.Core.UnregisterGlobalManager(Nez.GlobalManager)">
            <summary>
            removes the global manager object
            </summary>
            <returns>The global manager.</returns>
            <param name="manager">Manager.</param>
        </member>
        <member name="M:Nez.Core.GetGlobalManager``1">
            <summary>
            gets the global manager of type T
            </summary>
            <returns>The global manager.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Core.StartCoroutine(System.Collections.IEnumerator)">
            <summary>
            starts a coroutine. Coroutines can yeild ints/floats to delay for seconds or yeild to other calls to startCoroutine.
            Yielding null will make the coroutine get ticked the next frame.
            </summary>
            <returns>The coroutine.</returns>
            <param name="enumerator">Enumerator.</param>
        </member>
        <member name="M:Nez.Core.Schedule(System.Single,System.Boolean,System.Object,System.Action{Nez.ITimer})">
            <summary>
            schedules a one-time or repeating timer that will call the passed in Action
            </summary>
            <param name="timeInSeconds">Time in seconds.</param>
            <param name="repeats">If set to <c>true</c> repeats.</param>
            <param name="context">Context.</param>
            <param name="onTime">On time.</param>
        </member>
        <member name="M:Nez.Core.Schedule(System.Single,System.Object,System.Action{Nez.ITimer})">
            <summary>
            schedules a one-time timer that will call the passed in Action after timeInSeconds
            </summary>
            <param name="timeInSeconds">Time in seconds.</param>
            <param name="context">Context.</param>
            <param name="onTime">On time.</param>
        </member>
        <member name="M:Nez.Core.Schedule(System.Single,System.Boolean,System.Action{Nez.ITimer})">
            <summary>
            schedules a one-time or repeating timer that will call the passed in Action
            </summary>
            <param name="timeInSeconds">Time in seconds.</param>
            <param name="repeats">If set to <c>true</c> repeats.</param>
            <param name="onTime">On time.</param>
        </member>
        <member name="M:Nez.Core.Schedule(System.Single,System.Action{Nez.ITimer})">
            <summary>
            schedules a one-time timer that will call the passed in Action after timeInSeconds
            </summary>
            <param name="timeInSeconds">Time in seconds.</param>
            <param name="onTime">On time.</param>
        </member>
        <member name="F:Nez.CoreEvents.GraphicsDeviceReset">
            <summary>
            fired when the graphics device resets. When this happens, any RenderTargets or other contents of VRAM will be wiped and need
            to be regenerated
            </summary>
        </member>
        <member name="F:Nez.CoreEvents.SceneChanged">
            <summary>
            fired when the scene changes
            </summary>
        </member>
        <member name="F:Nez.CoreEvents.OrientationChanged">
            <summary>
            fired when the device orientation changes
            </summary>
        </member>
        <member name="F:Nez.CoreEvents.Exiting">
            <summary>
            fired when the game is exiting
            </summary>
        </member>
        <member name="T:Nez.CoreEventsComparer">
            <summary>
            comparer that should be passed to a dictionary constructor to avoid boxing/unboxing when using an enum as a key
            on Mono
            </summary>
        </member>
        <member name="F:Nez.Console.DebugConsole.RenderScale">
            <summary>
            controls the scale of the console
            </summary>
        </member>
        <member name="F:Nez.Console.DebugConsole._functionKeyActions">
            <summary>
            bind any custom Actions you would like to function keys
            </summary>
        </member>
        <member name="F:Nez.Console.DebugConsole.COMMAND_HISTORY_PADDING">
            <summary>
            separation of the command entry and history boxes
            </summary>
        </member>
        <member name="F:Nez.Console.DebugConsole.HORIZONTAL_PADDING">
            <summary>
            global padding on the left/right of the console
            </summary>
        </member>
        <member name="M:Nez.Console.DebugConsole.BindCommandToFunctionKey(System.Int32,System.String,System.String[])">
            <summary>
            binds a debug console command to a function key
            </summary>
            <param name="functionKey">The function (e.g. 1 for F1).</param>
            <param name="command">The name of the command.</param>
            <param name="args">Optional list of arguments.</param>
        </member>
        <member name="T:Nez.Console.CommandAttribute">
            <summary>
            add this attribute to any static method
            </summary>
        </member>
        <member name="M:Nez.Debug.TimeAction(System.Action,System.UInt32)">
            <summary>
            times how long an Action takes to run and returns the TimeSpan
            </summary>
            <returns>The action.</returns>
            <param name="action">Action.</param>
        </member>
        <member name="T:Nez.Debug.Colors">
            <summary>
            we store all the default colors for various systems here such as collider debug rendering, Debug.drawText and others. The naming
            convention is CLASS-THING where possible to make it clear where it is used.
            </summary>
        </member>
        <member name="M:Nez.DebugDrawItem.Draw(Nez.Batcher)">
            <summary>
            returns true if we are done with this debug draw item
            </summary>
        </member>
        <member name="M:Nez.Insist.IsNull(System.Object)">
            <summary>
            asserts that obj is null
            </summary>
            <param name="obj">Object.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="M:Nez.Insist.IsNull(System.Object,System.String,System.Object[])">
            <summary>
            asserts that obj is null
            </summary>
            <param name="obj">Object.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="M:Nez.Insist.IsNotNull(System.Object)">
            <summary>
            asserts that obj is not null
            </summary>
            <param name="obj">Object.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="M:Nez.Insist.IsNotNull(System.Object,System.String,System.Object[])">
            <summary>
            asserts that obj is not null
            </summary>
            <param name="obj">Object.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="M:Nez.Insist.AreEqual(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            asserts that first is equal to second
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="M:Nez.Insist.AreNotEqual(System.Object,System.Object,System.String,System.Object[])">
            <summary>
            asserts that first is not equal to second
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="message">Message.</param>
            <param name="args">Arguments.</param>
        </member>
        <member name="T:Nez.InspectableAttribute">
            <summary>
            Attribute that is used to indicate that the field/property should be present in the inspector
            </summary>
        </member>
        <member name="T:Nez.NotInspectableAttribute">
            <summary>
            Attribute that is used to indicate that the field/property should not be present in the inspector
            </summary>
        </member>
        <member name="T:Nez.InspectorCallableAttribute">
            <summary>
            adding this to a method will expose it to the inspector if it has 0 params or 1 param of a supported type: int, float, string
            and bool are currently supported.
            </summary>
        </member>
        <member name="T:Nez.TooltipAttribute">
            <summary>
            displays a tooltip when hovering over the label of any inspectable elements
            </summary>
        </member>
        <member name="T:Nez.RangeAttribute">
            <summary>
            Range attribute. Tells the inspector you want a slider to be displayed for a float/int
            </summary>
        </member>
        <member name="T:Nez.CustomInspectorAttribute">
            <summary>
            putting this attribute on a class and specifying a subclass of Inspector lets you create custom inspectors for any type. When
            the Inspector finds a field/property of the type with the attribute on it the inspectorType will be instantiated and used.
            Inspectors are only active in DEBUG builds so make sure to wrap your custom inspector subclass in #if DEBUG/#endif.
            </summary>
        </member>
        <member name="F:Nez.Camera.PositionZ3D">
            <summary>
            z-position of the 3D camera projections. Affects the fov greatly. Lower values make the objects appear very long in the z-direction.
            </summary>
        </member>
        <member name="F:Nez.Camera.NearClipPlane3D">
            <summary>
            near clip plane of the 3D camera projection
            </summary>
        </member>
        <member name="F:Nez.Camera.FarClipPlane3D">
            <summary>
            far clip plane of the 3D camera projection
            </summary>
        </member>
        <member name="P:Nez.Camera.Position">
            <summary>
            shortcut to entity.transform.position
            </summary>
            <value>The position.</value>
        </member>
        <member name="P:Nez.Camera.Rotation">
            <summary>
            shortcut to entity.transform.rotation
            </summary>
            <value>The rotation.</value>
        </member>
        <member name="P:Nez.Camera.RawZoom">
            <summary>
            raw zoom value. This is the exact value used for the scale matrix. Default is 1.
            </summary>
            <value>The raw zoom.</value>
        </member>
        <member name="P:Nez.Camera.Zoom">
            <summary>
            the zoom value should be between -1 and 1. This value is then translated to be from minimumZoom to maximumZoom. This lets you set
            appropriate minimum/maximum values then use a more intuitive -1 to 1 mapping to change the zoom.
            </summary>
            <value>The zoom.</value>
        </member>
        <member name="P:Nez.Camera.MinimumZoom">
            <summary>
            minimum non-scaled value (0 - float.Max) that the camera zoom can be. Defaults to 0.3
            </summary>
            <value>The minimum zoom.</value>
        </member>
        <member name="P:Nez.Camera.MaximumZoom">
            <summary>
            maximum non-scaled value (0 - float.Max) that the camera zoom can be. Defaults to 3
            </summary>
            <value>The maximum zoom.</value>
        </member>
        <member name="P:Nez.Camera.Bounds">
            <summary>
            world-space bounds of the camera. useful for culling.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:Nez.Camera.TransformMatrix">
            <summary>
            used to convert from world coordinates to screen
            </summary>
            <value>The transform matrix.</value>
        </member>
        <member name="P:Nez.Camera.InverseTransformMatrix">
            <summary>
            used to convert from screen coordinates to world
            </summary>
            <value>The inverse transform matrix.</value>
        </member>
        <member name="P:Nez.Camera.ProjectionMatrix">
            <summary>
            the 2D Cameras projection matrix
            </summary>
            <value>The projection matrix.</value>
        </member>
        <member name="P:Nez.Camera.ViewProjectionMatrix">
            <summary>
            gets the view-projection matrix which is the transformMatrix * the projection matrix
            </summary>
            <value>The view projection matrix.</value>
        </member>
        <member name="P:Nez.Camera.ProjectionMatrix3D">
            <summary>
            returns a perspective projection for this camera for use when rendering 3D objects
            </summary>
            <value>The projection matrix3 d.</value>
        </member>
        <member name="P:Nez.Camera.ViewMatrix3D">
            <summary>
            returns a view Matrix via CreateLookAt for this camera for use when rendering 3D objects
            </summary>
            <value>The view matrix3 d.</value>
        </member>
        <member name="M:Nez.Camera.OnSceneRenderTargetSizeChanged(System.Int32,System.Int32)">
            <summary>
            when the scene render target size changes we update the cameras origin and adjust the position to keep it where it was
            </summary>
            <param name="newWidth">New width.</param>
            <param name="newHeight">New height.</param>
        </member>
        <member name="M:Nez.Camera.SetInset(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            sets the amount used to inset the camera bounds from the viewport edge
            </summary>
            <param name="left">The amount to set the left bounds in from the viewport.</param>
            <param name="right">The amount to set the right bounds in from the viewport.</param>
            <param name="top">The amount to set the top bounds in from the viewport.</param>
            <param name="bottom">The amount to set the bottom bounds in from the viewport.</param>
        </member>
        <member name="M:Nez.Camera.SetPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            shortcut to entity.transform.setPosition
            </summary>
            <param name="position">Position.</param>
        </member>
        <member name="M:Nez.Camera.SetRotation(System.Single)">
            <summary>
            shortcut to entity.transform.setRotation
            </summary>
            <param name="radians">Radians.</param>
        </member>
        <member name="M:Nez.Camera.SetRotationDegrees(System.Single)">
            <summary>
            shortcut to entity.transform.setRotationDegrees
            </summary>
            <param name="degrees">Degrees.</param>
        </member>
        <member name="M:Nez.Camera.SetZoom(System.Single)">
            <summary>
            sets the the zoom value which should be between -1 and 1. This value is then translated to be from minimumZoom to maximumZoom.
            This lets you set appropriate minimum/maximum values then use a more intuitive -1 to 1 mapping to change the zoom.
            </summary>
            <param name="zoom">Zoom.</param>
        </member>
        <member name="M:Nez.Camera.SetMinimumZoom(System.Single)">
            <summary>
            minimum non-scaled value (0 - float.Max) that the camera zoom can be. Defaults to 0.3
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Camera.SetMaximumZoom(System.Single)">
            <summary>
            maximum non-scaled value (0 - float.Max) that the camera zoom can be. Defaults to 3
            </summary>
            <param name="maxZoom">Max zoom.</param>
        </member>
        <member name="M:Nez.Camera.ForceMatrixUpdate">
            <summary>
            this forces the matrix and bounds dirty
            </summary>
        </member>
        <member name="M:Nez.Camera.WorldToScreenPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            converts a point from world coordinates to screen
            </summary>
            <returns>The to screen point.</returns>
            <param name="worldPosition">World position.</param>
        </member>
        <member name="M:Nez.Camera.ScreenToWorldPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            converts a point from screen coordinates to world
            </summary>
            <returns>The to world point.</returns>
            <param name="screenPosition">Screen position.</param>
        </member>
        <member name="M:Nez.Camera.ScreenToWorldPoint(Microsoft.Xna.Framework.Point)">
            <summary>
            converts a point from screen coordinates to world
            </summary>
            <returns>The to world point.</returns>
            <param name="screenPosition">Screen position.</param>
        </member>
        <member name="M:Nez.Camera.MouseToWorldPoint">
            <summary>
            returns the mouse position in world space
            </summary>
            <returns>The to world point.</returns>
        </member>
        <member name="M:Nez.Camera.TouchToWorldPoint(Microsoft.Xna.Framework.Input.Touch.TouchLocation)">
            <summary>
            returns the touch position in world space
            </summary>
            <returns>The to world point.</returns>
        </member>
        <member name="T:Nez.Component">
             <summary>
             Execution order:
             - OnAddedToEntity
             - OnEnabled
            
             Removal:
             - OnRemovedFromEntity
            
             </summary>
        </member>
        <member name="F:Nez.Component.Entity">
            <summary>
            the Entity this Component is attached to
            </summary>
        </member>
        <member name="P:Nez.Component.Transform">
            <summary>
            shortcut to entity.transform
            </summary>
            <value>The transform.</value>
        </member>
        <member name="P:Nez.Component.Enabled">
            <summary>
            true if the Component is enabled and the Entity is enabled. When enabled this Components lifecycle methods will be called.
            Changes in state result in onEnabled/onDisable being called.
            </summary>
            <value><c>true</c> if enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.Component.UpdateOrder">
            <summary>
            update order of the Components on this Entity
            </summary>
            <value>The order.</value>
        </member>
        <member name="M:Nez.Component.Initialize">
            <summary>
            called when this Component has had its Entity assigned but it is NOT yet added to the live Components list of the Entity yet. Useful
            for things like physics Components that need to access the Transform to modify collision body properties.
            </summary>
        </member>
        <member name="M:Nez.Component.OnAddedToEntity">
            <summary>
            Called when this component is added to a scene after all pending component changes are committed. At this point, the Entity field
            is set and the Entity.Scene is also set.
            </summary>
        </member>
        <member name="M:Nez.Component.OnRemovedFromEntity">
            <summary>
            Called when this component is removed from its entity. Do all cleanup here.
            </summary>
        </member>
        <member name="M:Nez.Component.OnEntityTransformChanged(Nez.Transform.Component)">
            <summary>
            called when the entity's position changes. This allows components to be aware that they have moved due to the parent
            entity moving.
            </summary>
        </member>
        <member name="M:Nez.Component.OnEnabled">
            <summary>
            called when the parent Entity or this Component is enabled
            </summary>
        </member>
        <member name="M:Nez.Component.OnDisabled">
            <summary>
            called when the parent Entity or this Component is disabled
            </summary>
        </member>
        <member name="M:Nez.Component.Clone">
            <summary>
            creates a clone of this Component. The default implementation is just a MemberwiseClone so if a Component has object references
            that need to be cloned this method should be overriden.
            </summary>
        </member>
        <member name="M:Nez.CameraShake.Shake(System.Single,System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            if the shake is already running this will overwrite the current values only if shakeIntensity > the current shakeIntensity.
            if the shake is not currently active it will be started.
            </summary>
            <param name="shakeIntensity">how much should we shake it</param>
            <param name="shakeDegredation">lower values cause faster degradation</param>
            <param name="shakeDirection">Vector3.zero will result in a shake on just the x/y axis. any other values will result in the passed
            in shakeDirection * intensity being the offset the camera is moved</param>
        </member>
        <member name="T:Nez.ColorCycler">
            <summary>
            takes a RenderableComponent and cycles the color using different wave forms. A specific color channel can be affected or all of them.
            Useful for making flickering lights and adding atmosphere.
            </summary>
        </member>
        <member name="F:Nez.ColorCycler.Offset">
            <summary>
            This value is added to the final result. 0 - 1 range.
            </summary>
        </member>
        <member name="F:Nez.ColorCycler.Amplitude">
            <summary>
            this value is multiplied by the calculated value
            </summary>
        </member>
        <member name="F:Nez.ColorCycler.Phase">
            <summary>
            start point in wave function. 0 - 1 range.
            </summary>
        </member>
        <member name="F:Nez.ColorCycler.Frequency">
            <summary>
            cycles per second
            </summary>
        </member>
        <member name="T:Nez.FollowCamera">
            <summary>
            basic follow camera. LockOn mode uses no deadzone and just centers the camera on the target. CameraWindow mode wraps a deadzone
            around the target allowing it to move within the deadzone without moving the camera.
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.Measurement.FixedPixel">
            <summary>
            Size is measured in pixel.
            Does not change with the Camera <see cref="P:Nez.Camera.Bounds"/> and <see cref="P:Nez.Camera.Zoom"/> level.
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.Measurement.ScaledCameraBounds">
            <summary>
            Size is measured in % of Camera <see cref="P:Nez.Camera.Bounds"/>.
            Where 1.0f equals the whole Camera Size and 0.5f is half the Camera size.
            Scales automatically with the Camera <see cref="P:Nez.Camera.Bounds"/> and <see cref="P:Nez.Camera.Zoom"/> level.
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.FollowLerp">
            <summary>
            0 - 1 range where 0 is the camera never closes the target position and 1 is the camera immediately closes the target position
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.Deadzone">
            <summary>
            when in <see cref="F:Nez.FollowCamera.CameraStyle.CameraWindow"/> mode used as a bounding box around the camera position
            to allow the targetEntity to movement inside it without moving the camera.
            when in <see cref="F:Nez.FollowCamera.CameraStyle.LockOn"/> mode only the deadzone x/y values are used as offset.
            This is set to sensible defaults when you call <see cref="M:Nez.FollowCamera.Follow(Nez.Entity,Nez.FollowCamera.CameraStyle,Nez.FollowCamera.Measurement)"/> but you are
            free to override <see cref="F:Nez.FollowCamera.Deadzone"/> to get a custom deadzone directly or via the helper <see cref="M:Nez.FollowCamera.SetCenteredDeadzone(System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.FocusOffset">
            <summary>
            offset from the screen center that the camera will focus on
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.MapLockEnabled">
            <summary>
            If true, the camera position will not got out of the map rectangle (0,0, mapwidth, mapheight)
            </summary>
        </member>
        <member name="F:Nez.FollowCamera.MapSize">
            <summary>
            Contains the width and height of the current map.
            </summary>
        </member>
        <member name="M:Nez.FollowCamera.ClampToMapSize(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Clamps the camera so it never leaves the visible area of the map.
            </summary>
            <returns>The to map size.</returns>
            <param name="position">Position.</param>
        </member>
        <member name="M:Nez.FollowCamera.SetCenteredDeadzone(System.Int32,System.Int32)">
            <summary>
            sets up the deadzone centered in the current cameras bounds with the given size
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.FollowCamera.SetCenteredDeadzoneInScreenspace(System.Single,System.Single)">
            <summary>
            sets up the deadzone centered in the current cameras bounds with the given size
            </summary>
            <param name="width">Width in % of screenspace. Between 0.0 and 1.0</param>
            <param name="height">Height in % of screenspace. Between 0.0 and 1.0</param>
        </member>
        <member name="T:Nez.IUpdatable">
            <summary>
            interface that when added to a Component lets Nez know that it wants the update method called each frame as long as the Component
            and Entity are enabled.
            </summary>
        </member>
        <member name="T:Nez.IUpdatableComparer">
            <summary>
            Comparer for sorting IUpdatables
            </summary>
        </member>
        <member name="T:Nez.ArcadeRigidbody">
            <summary>
            Note that this is not a full, multi-iteration physics system! This can be used for simple, arcade style physics.
            Based on http://elancev.name/oliver/2D%20polygon.htm#tut5
            </summary>
        </member>
        <member name="P:Nez.ArcadeRigidbody.Mass">
            <summary>
            mass of this rigidbody. A 0 mass will make this an immovable object.
            </summary>
            <value>The mass.</value>
        </member>
        <member name="P:Nez.ArcadeRigidbody.Elasticity">
            <summary>
            0 - 1 range where 0 is no bounce and 1 is perfect reflection
            </summary>
        </member>
        <member name="P:Nez.ArcadeRigidbody.Friction">
            <summary>
            0 - 1 range. 0 means no friction, 1 means the object will stop dead on
            </summary>
        </member>
        <member name="P:Nez.ArcadeRigidbody.Glue">
            <summary>
            0 - 9 range. When a collision occurs and it has risidual motion along the surface of collision if its square magnitude is less
            than glue friction will be set to the maximum for the collision resolution.
            </summary>
        </member>
        <member name="F:Nez.ArcadeRigidbody.ShouldUseGravity">
            <summary>
            if true, Physics.gravity will be taken into account each frame
            </summary>
        </member>
        <member name="F:Nez.ArcadeRigidbody.Velocity">
            <summary>
            velocity of this rigidbody
            </summary>
        </member>
        <member name="P:Nez.ArcadeRigidbody.IsImmovable">
            <summary>
            rigidbodies with a mass of 0 are considered immovable. Changing velocity and collisions will have no effect on them.
            </summary>
            <value><c>true</c> if is immovable; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.ArcadeRigidbody.SetMass(System.Single)">
            <summary>
            mass of this rigidbody. A 0 mass will make this an immovable object.
            </summary>
            <returns>The mass.</returns>
            <param name="mass">Mass.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.SetElasticity(System.Single)">
            <summary>
            0 - 1 range where 0 is no bounce and 1 is perfect reflection
            </summary>
            <returns>The elasticity.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.SetFriction(System.Single)">
            <summary>
            0 - 1 range. 0 means no friction, 1 means the object will stop dead on
            </summary>
            <returns>The friction.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.SetGlue(System.Single)">
            <summary>
            0 - 9 range. When a collision occurs and it has risidual motion along the surface of collision if its square magnitude is less
            than glue friction will be set to the maximum for the collision resolution.
            </summary>
            <returns>The glue.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.SetVelocity(Microsoft.Xna.Framework.Vector2)">
            <summary>
            velocity of this rigidbody
            </summary>
            <returns>The velocity.</returns>
            <param name="velocity">Velocity.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.AddImpulse(Microsoft.Xna.Framework.Vector2)">
            <summary>
            add an instant force impulse to the rigidbody using its mass. force is an acceleration in pixels per second per second. The
            force is multiplied by 100000 to make the values more reasonable to use.
            </summary>
            <param name="force">Force.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.ProcessOverlap(Nez.ArcadeRigidbody,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            separates two overlapping rigidbodies. Handles the case of either being immovable as well.
            </summary>
            <param name="other">Other.</param>
            <param name="minimumTranslationVector"></param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.ProcessCollision(Nez.ArcadeRigidbody,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            handles the collision of two non-overlapping rigidbodies. New velocities will be assigned to each rigidbody as appropriate.
            </summary>
            <param name="other">Other.</param>
            <param name="inverseMTV">Inverse MT.</param>
        </member>
        <member name="M:Nez.ArcadeRigidbody.CalculateResponseVelocity(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            given the relative velocity between the two objects and the MTV this method modifies the relativeVelocity to make it a collision
            response.
            </summary>
            <param name="relativeVelocity">Relative velocity.</param>
            <param name="minimumTranslationVector">Minimum translation vector.</param>
        </member>
        <member name="M:Nez.BoxCollider.#ctor">
            <summary>
            zero param constructor requires that a RenderableComponent be on the entity so that the collider can size itself when the
            entity is added to the scene.
            </summary>
        </member>
        <member name="M:Nez.BoxCollider.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            creates a BoxCollider and uses the x/y components as the localOffset
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.BoxCollider.#ctor(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            creates a BoxCollider and uses the x/y components of the Rect as the localOffset
            </summary>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.BoxCollider.SetSize(System.Single,System.Single)">
            <summary>
            sets the size of the BoxCollider
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.BoxCollider.SetWidth(System.Single)">
            <summary>
            sets the width of the BoxCollider
            </summary>
            <returns>The width.</returns>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.BoxCollider.SetHeight(System.Single)">
            <summary>
            sets the height of the BoxCollider
            </summary>
            <returns>The height.</returns>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.CircleCollider.#ctor">
            <summary>
            zero param constructor requires that a RenderableComponent be on the entity so that the collider can size itself when the
            entity is added to the scene.
            </summary>
        </member>
        <member name="M:Nez.CircleCollider.#ctor(System.Single)">
            <summary>
            creates a CircleCollider with radius. Note that when specifying a radius if using a RenderableComponent on the Entity as well you
            will need to set the origin to align the CircleCollider. For example, if the RenderableComponent has a 0,0 origin and a CircleCollider
            with a radius of 1.5f * renderable.width is created you can offset the origin by just setting the originNormalied to the center
            divided by the scaled size:
            
            	entity.collider = new CircleCollider( moonTexture.Width * 1.5f );
                entity.collider.originNormalized = Vector2Extension.halfVector() / 1.5f;
            </summary>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.CircleCollider.SetRadius(System.Single)">
            <summary>
            sets the radius for the CircleCollider
            </summary>
            <returns>The radius.</returns>
            <param name="radius">Radius.</param>
        </member>
        <member name="F:Nez.Collider.Shape">
            <summary>
            the underlying Shape of the Collider
            </summary>
        </member>
        <member name="P:Nez.Collider.LocalOffset">
            <summary>
            localOffset is added to entity.position to get the final position for the collider geometry. This allows you to add multiple
            Colliders to an Entity and position them separately and also lets you set the point of rotation/scale.
            </summary>
        </member>
        <member name="P:Nez.Collider.AbsolutePosition">
            <summary>
            represents the absolute position to this Collider. It is entity.transform.position + localPosition - origin.
            </summary>
            <value>The absolute position.</value>
        </member>
        <member name="P:Nez.Collider.Rotation">
            <summary>
            wraps Transform.rotation and returns 0 if this Collider does not rotate with the Entity else it returns Transform.rotation
            </summary>
            <value>The rotation.</value>
        </member>
        <member name="F:Nez.Collider.IsTrigger">
            <summary>
            if this collider is a trigger it will not cause collisions but it will still trigger events
            </summary>
        </member>
        <member name="F:Nez.Collider.PhysicsLayer">
            <summary>
            physicsLayer can be used as a filter when dealing with collisions. The Flags class has methods to assist with bitmasks.
            </summary>
        </member>
        <member name="F:Nez.Collider.CollidesWithLayers">
            <summary>
            layer mask of all the layers this Collider should collide with when Entity.move methods are used. defaults to all layers.
            </summary>
        </member>
        <member name="F:Nez.Collider.ShouldColliderScaleAndRotateWithTransform">
            <summary>
            if true, the Collider will scale and rotate following the Transform it is attached to
            </summary>
        </member>
        <member name="F:Nez.Collider.registeredPhysicsBounds">
            <summary>
            the bounds of this Collider when it was registered with the Physics system. Storing this allows us to always be able to
            safely remove the Collider from the Physics system even if it was moved before attempting to remove it.
            </summary>
        </member>
        <member name="F:Nez.Collider._isParentEntityAddedToScene">
            <summary>
            flag to keep track of if our Entity was added to a Scene
            </summary>
        </member>
        <member name="F:Nez.Collider._isColliderRegistered">
            <summary>
            flag to keep track of if we registered ourself with the Physics system
            </summary>
        </member>
        <member name="M:Nez.Collider.SetLocalOffset(Microsoft.Xna.Framework.Vector2)">
            <summary>
            localOffset is added to entity.position to get the final position for the collider. This allows you to add multiple Colliders
            to an Entity and position them separately.
            </summary>
            <returns>The local offset.</returns>
            <param name="offset">Offset.</param>
        </member>
        <member name="M:Nez.Collider.SetShouldColliderScaleAndRotateWithTransform(System.Boolean)">
            <summary>
            if set to true, the Collider will scale and rotate following the Transform it is attached to
            </summary>
            <returns>The should collider scale and rotate with transform.</returns>
            <param name="shouldColliderScaleAndRotateWithTransform">If set to <c>true</c> should collider scale and rotate with transform.</param>
        </member>
        <member name="M:Nez.Collider.RegisterColliderWithPhysicsSystem">
            <summary>
            the parent Entity will call this at various times (when added to a scene, enabled, etc)
            </summary>
        </member>
        <member name="M:Nez.Collider.UnregisterColliderWithPhysicsSystem">
            <summary>
            the parent Entity will call this at various times (when removed from a scene, disabled, etc)
            </summary>
        </member>
        <member name="M:Nez.Collider.Overlaps(Nez.Collider)">
            <summary>
            checks to see if this shape overlaps any other Colliders in the Physics system
            </summary>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Collider.CollidesWith(Nez.Collider,Nez.CollisionResult@)">
            <summary>
            checks to see if this Collider collides with collider. If it does, true will be returned and result will be populated
            with collision data
            </summary>
            <returns><c>true</c>, if with was collidesed, <c>false</c> otherwise.</returns>
            <param name="collider">Collider.</param>
            <param name="result">Result.</param>
        </member>
        <member name="M:Nez.Collider.CollidesWith(Nez.Collider,Microsoft.Xna.Framework.Vector2,Nez.CollisionResult@)">
            <summary>
            checks to see if this Collider with motion applied (delta movement vector) collides with collider. If it does, true will be
            returned and result will be populated with collision data.
            </summary>
            <returns><c>true</c>, if with was collidesed, <c>false</c> otherwise.</returns>
            <param name="collider">Collider.</param>
            <param name="motion">Motion.</param>
            <param name="result">Result.</param>
        </member>
        <member name="M:Nez.Collider.CollidesWithAny(Nez.CollisionResult@)">
            <summary>
            checks to see if this Collider collides with any other Colliders in the Scene. The first Collider it intersects will have its collision
            data returned in the CollisionResult.
            </summary>
            <returns><c>true</c>, if with was collidesed, <c>false</c> otherwise.</returns>
            <param name="result">Result.</param>
        </member>
        <member name="M:Nez.Collider.CollidesWithAny(Microsoft.Xna.Framework.Vector2@,Nez.CollisionResult@)">
            <summary>
            checks to see if this Collider with motion applied (delta movement vector) collides with any collider. If it does, true will be
            returned and result will be populated with collision data. Motion will be set to the maximum distance the Collider can travel
            before colliding.
            </summary>
            <returns><c>true</c>, if with was collidesed, <c>false</c> otherwise.</returns>
            <param name="motion">Motion.</param>
            <param name="result">Result.</param>
        </member>
        <member name="T:Nez.PolygonCollider">
            <summary>
            Polygons should be defined in clockwise fashion.
            </summary>
        </member>
        <member name="M:Nez.PolygonCollider.#ctor(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            If the points are not centered they will be centered with the difference being applied to the localOffset.
            </summary>
            <param name="points">Points.</param>
        </member>
        <member name="T:Nez.ITriggerListener">
            <summary>
            when added to a Component, whenever a Collider on the Entity overlaps/exits another Component these methods will be called.
            The ITriggerListener method will be called on any Component on the Entity that is a trigger that implement the interface.
            Note that this interface works only in conjunction with the Mover class
            </summary>
        </member>
        <member name="M:Nez.ITriggerListener.OnTriggerEnter(Nez.Collider,Nez.Collider)">
            <summary>
            called when a collider intersects a trigger collider. This is called on the trigger collider and the collider that touched
            the trigger. Movement must be handled by the Mover/ProjectileMover methods for this to function automatically.
            </summary>
            <param name="remote">Remote.</param>
            <param name="local">Local.</param>
        </member>
        <member name="M:Nez.ITriggerListener.OnTriggerExit(Nez.Collider,Nez.Collider)">
            <summary>
            called when another collider leaves a trigger collider.
            </summary>
            <param name="remote">Remote.</param>
            <param name="local">Local.</param>
        </member>
        <member name="T:Nez.Mover">
            <summary>
            helper class illustrating one way to handle movement taking into account all Collisions including triggers. The ITriggerListener
            interface is used to manage callbacks to any triggers that are breached while moving. An object must move only via the Mover.move
            method for triggers to be properly reported. Note that multiple Movers interacting with each other will end up calling ITriggerListener
            multiple times.
            </summary>
        </member>
        <member name="M:Nez.Mover.CalculateMovement(Microsoft.Xna.Framework.Vector2@,Nez.CollisionResult@)">
            <summary>
            caculates the movement modifying the motion vector to take into account any collisions that will
            occur when moving
            </summary>
            <returns><c>true</c>, if movement was calculated, <c>false</c> otherwise.</returns>
            <param name="motion">Motion.</param>
            <param name="collisionResult">Collision result.</param>
        </member>
        <member name="M:Nez.Mover.AdvancedCalculateMovement(Microsoft.Xna.Framework.Vector2@,System.Collections.Generic.ICollection{Nez.CollisionResult})">
            <summary>
            Calculates the movement modifying the motion vector to take into account any collisions that will
            occur when moving. This version is modified to output through a given collection to show every
            collision that occured.
            </summary>
            <returns>The amount of collisions that occured.</returns>
            <param name="motion">Motion.</param>
            <param name="collisionResult">Collision result.</param>
        </member>
        <member name="M:Nez.Mover.ApplyMovement(Microsoft.Xna.Framework.Vector2)">
            <summary>
            applies the movement from calculateMovement to the entity and updates the triggerHelper
            </summary>
            <param name="motion">Motion.</param>
        </member>
        <member name="M:Nez.Mover.Move(Microsoft.Xna.Framework.Vector2,Nez.CollisionResult@)">
            <summary>
            moves the entity taking collisions into account by calling calculateMovement followed by applyMovement;
            </summary>
            <returns><c>true</c>, if move actor was newed, <c>false</c> otherwise.</returns>
            <param name="motion">Motion.</param>
            <param name="collisionResult">Collision result.</param>
        </member>
        <member name="T:Nez.ProjectileMover">
            <summary>
            moves taking collision into account only for reporting to any ITriggerListeners. The object will always move the full amount so it is up
            to the caller to destroy it on impact if desired.
            </summary>
        </member>
        <member name="M:Nez.ProjectileMover.Move(Microsoft.Xna.Framework.Vector2)">
            <summary>
            moves the entity taking collisions into account
            </summary>
            <returns><c>true</c>, if move actor was newed, <c>false</c> otherwise.</returns>
            <param name="motion">Motion.</param>
        </member>
        <member name="M:Nez.GeometricPrimitive3D.InitializePrimitive">
            <summary>
            Once all the geometry has been specified by calling addVertex and addIndex, this method copies the vertex and index data into
            GPU format buffers, ready for efficient rendering.
            </summary>
        </member>
        <member name="M:Nez.GeometricPrimitive3D.Dispose">
            <summary>
            frees resources used by this object.
            </summary>
        </member>
        <member name="M:Nez.GeometricPrimitive3D.Dispose(System.Boolean)">
            <summary>
            frees resources used by this object.
            </summary>
        </member>
        <member name="T:Nez.Renderable3D">
            <summary>
            convenience base class for 3D objects. It reuses and wraps the Transform in Vector3s for easy access and provides a world
            transform for rendering.
            </summary>
        </member>
        <member name="P:Nez.Renderable3D.Bounds">
            <summary>
            by default, uses a magic number of 1.5 * the scale of the object. This will work fine for objects ~1 unit in width/height.
            Any other odd sizes should override this appropriately.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:Nez.Renderable3D.Position">
            <summary>
            wraps Transform.position along with a private Z position
            </summary>
            <value>The position.</value>
        </member>
        <member name="F:Nez.Renderable3D.Scale">
            <summary>
            the scale of the object. 80 by default. You will need to adjust this depending on your Scene's backbuffer size.
            </summary>
        </member>
        <member name="P:Nez.Renderable3D.Rotation">
            <summary>
            wraps Transform.rotation for the Z rotation along with a private X and Y rotation.
            </summary>
            <value>The rotation.</value>
        </member>
        <member name="P:Nez.Renderable3D.RotationDegrees">
            <summary>
            rotation in degrees
            </summary>
            <value>The rotation degrees.</value>
        </member>
        <member name="P:Nez.Renderable3D.WorldMatrix">
            <summary>
            Matrix that represents the world transform. Useful for rendering.
            </summary>
            <value>The world matrix.</value>
        </member>
        <member name="T:Nez.IRenderable">
            <summary>
            interface that when applied to a Component will register it to be rendered by the Scene Renderers. Implement this very carefully! Changing
            things like layerDepth/renderLayer/material need to update the Scene RenderableComponentList
            </summary>
        </member>
        <member name="P:Nez.IRenderable.Bounds">
            <summary>
            the AABB that wraps this object. Used for camera culling.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:Nez.IRenderable.Enabled">
            <summary>
            whether this IRenderable should be rendered or not
            </summary>
        </member>
        <member name="P:Nez.IRenderable.LayerDepth">
            <summary>
            standard Batcher layerdepth. 0 is in front and 1 is in back. Changing this value will trigger a sort of the renderableComponents
            list on the scene.
            </summary>
        </member>
        <member name="P:Nez.IRenderable.RenderLayer">
            <summary>
            lower renderLayers are in the front and higher are in the back, just like layerDepth but not clamped to 0-1. Note that this means
            higher renderLayers are sent to the Batcher first. An important fact when using the stencil buffer.
            </summary>
        </member>
        <member name="P:Nez.IRenderable.Material">
            <summary>
            used by Renderers to specify how this sprite should be rendered. If non-null, it is automatically disposed of when the Component
            is removed from the Entity.
            </summary>
        </member>
        <member name="P:Nez.IRenderable.IsVisible">
            <summary>
            the visibility of this Renderable. Changes in state end up calling the onBecameVisible/onBecameInvisible methods.
            </summary>
            <value><c>true</c> if is visible; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.IRenderable.GetMaterial``1">
            <summary>
            helper for retrieving a Material subclass already casted
            </summary>
        </member>
        <member name="M:Nez.IRenderable.IsVisibleFromCamera(Nez.Camera)">
            <summary>
            returns true if the Renderables bounds intersects the Camera.bounds. Handles state switches for the isVisible flag. Use this method
            in your render method to see decide if you should render or not.
            </summary>
            <returns><c>true</c>, if visible from camera was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.IRenderable.Render(Nez.Batcher,Nez.Camera)">
            <summary>
            called by a Renderer. The Camera can be used for culling and the Batcher instance to draw with.
            </summary>
        </member>
        <member name="M:Nez.IRenderable.DebugRender(Nez.Batcher)">
            <summary>
            renders the bounds only if there is no collider. Always renders a square on the origin.
            </summary>
        </member>
        <member name="T:Nez.RenderableComparer">
            <summary>
            Comparer for sorting IRenderables. Sorts first by RenderLayer, then LayerDepth. If there is a tie Materials
            are used for the tie-breaker to avoid render state changes.
            </summary>
        </member>
        <member name="F:Nez.EndCapType.Standard">
            <summary>
            will not attempt to add any extra verts at joints
            </summary>
        </member>
        <member name="F:Nez.EndCapType.Jagged">
            <summary>
            all joints will be extruded out with an extra vert resulting in jagged, pointy joints
            </summary>
        </member>
        <member name="F:Nez.EndCapType.JaggedWithCutoff">
            <summary>
            the same as jagged but uses cutoffAngleForEndCapSubdivision to decide if a joint should be Jagged or Standard
            </summary>
        </member>
        <member name="F:Nez.EndCapType.Smooth">
            <summary>
            joints are smoothed with some extra geometry. Uses degreesPerSubdivision to decide how smooth to make each joint.
            </summary>
        </member>
        <member name="T:Nez.LineRenderer">
            <summary>
            Renders a trail behind a moving object
            Adapted from http://www.paradeofrain.com/2010/01/28/update-on-continuous-2d-trails-in-xna/
            </summary>
        </member>
        <member name="P:Nez.LineRenderer.UseWorldSpace">
            <summary>
            controls whether the lines are defined in world space or local
            </summary>
        </member>
        <member name="P:Nez.LineRenderer.EndCapType">
            <summary>
            the type of end cap for all joints
            </summary>
            <value>The end type of the cap.</value>
        </member>
        <member name="P:Nez.LineRenderer.CutoffAngleForEndCapSubdivision">
            <summary>
            used by EndCapType.JaggedWithCutoff to decide what angle to stop creating jagged joints
            </summary>
            <value>The cutoff angle for end cap subdivision.</value>
        </member>
        <member name="P:Nez.LineRenderer.DegreesPerSubdivision">
            <summary>
            used by EndCapType.Smooth to decide how often to subdivide and smooth joints
            </summary>
            <value>The degrees per subdivision.</value>
        </member>
        <member name="M:Nez.LineRenderer.SetUseWorldSpace(System.Boolean)">
            <summary>
            sets whether local or world space will be used for rendering. Defaults to world space. Using local space will take into account
            all the Transform properties including scale/rotation/position.
            </summary>
            <returns>The use world space.</returns>
            <param name="useWorldSpace">If set to <c>true</c> use world space.</param>
        </member>
        <member name="M:Nez.LineRenderer.SetTexture(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets the texture. Textures should be horizontally tileable. Pass in null to unset the texture.
            </summary>
            <returns>The texture.</returns>
            <param name="texture">Texture.</param>
        </member>
        <member name="M:Nez.LineRenderer.SetEndCapType(Nez.EndCapType)">
            <summary>
            sets the EndCapType used for rendering the line
            </summary>
            <returns>The end cap type.</returns>
            <param name="endCapType">End cap type.</param>
        </member>
        <member name="M:Nez.LineRenderer.SetCutoffAngleForEndCapSubdivision(System.Single)">
            <summary>
            sets the cutoff angle for use with EndCapType.JaggedWithCutoff. Any angles less than the cutoff angle will have jagged
            joints and all others will have standard.
            </summary>
            <returns>The cutoff angle for end cap subdivision.</returns>
            <param name="cutoffAngleForEndCapSubdivision">Cutoff angle for end cap subdivision.</param>
        </member>
        <member name="M:Nez.LineRenderer.SetDegreesPerSubdivision(System.Single)">
            <summary>
            sets the number of degrees between each subdivision for use with EndCapType.Smooth
            </summary>
            <returns>The per subdivision.</returns>
            <param name="degreesPerSubdivision">Degrees per subdivision.</param>
        </member>
        <member name="M:Nez.LineRenderer.SetStartEndWidths(System.Single,System.Single)">
            <summary>
            sets the start and end width. If these are set, the individual point widths will be ignored.
            </summary>
            <returns>The start end widths.</returns>
            <param name="startWidth">Start width.</param>
            <param name="endWidth">End width.</param>
        </member>
        <member name="M:Nez.LineRenderer.ClearStartEndWidths">
            <summary>
            clears the global start/end widths and goes back to using the individual point widths
            </summary>
            <returns>The start end widths.</returns>
        </member>
        <member name="M:Nez.LineRenderer.SetStartEndColors(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color)">
            <summary>
            sets the start and end color. If these are set, the individual point colors will be ignored.
            </summary>
            <returns>The start end colors.</returns>
            <param name="startColor">Start color.</param>
            <param name="endColor">End color.</param>
        </member>
        <member name="M:Nez.LineRenderer.ClearStartEndColors">
            <summary>
            clears the global start/end colors and goes back to using the individual point colors
            </summary>
            <returns>The start end colors.</returns>
        </member>
        <member name="M:Nez.LineRenderer.AddPoint(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            adds a point to the line. If start/end widths are not set each point should have a width set here.
            </summary>
            <returns>The point.</returns>
            <param name="point">Point.</param>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.LineRenderer.AddPoint(Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            adds a point to the line. If start/end widths are not set each point should have a width set here. If start/end colors
            are not set a color should be set as well.
            </summary>
            <returns>The point.</returns>
            <param name="point">Point.</param>
            <param name="width">Width.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.LineRenderer.UpdatePoint(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>
            updates a points properties
            </summary>
            <returns>The point.</returns>
            <param name="index">Index.</param>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.LineRenderer.UpdatePoint(System.Int32,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            updates a points properties
            </summary>
            <returns>The point.</returns>
            <param name="index">Index.</param>
            <param name="point">Point.</param>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.LineRenderer.UpdatePoint(System.Int32,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Color)">
            <summary>
            updates a points properties
            </summary>
            <returns>The point.</returns>
            <param name="index">Index.</param>
            <param name="point">Point.</param>
            <param name="width">Width.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.LineRenderer.ClearPoints">
            <summary>
            clears all the points
            </summary>
            <returns>The points.</returns>
        </member>
        <member name="M:Nez.LineRenderer.AddSingleSegmentLine(Nez.LineRenderer.Segment@,Microsoft.Xna.Framework.Color)">
            <summary>
            special case for just 2 points, one line segment
            </summary>
            <param name="segment">Segment.</param>
        </member>
        <member name="M:Nez.LineRenderer.AddFirstSegment(Nez.LineRenderer.Segment@,Nez.LineRenderer.Segment@,System.Int32@)">
            <summary>
            the first segment is special since it has no previous verts to connect to so we handle it separately.
            </summary>
            <param name="segment">Segment.</param>
            <param name="nextSegment">Next segment.</param>
            <param name="vertIndex">Vert index.</param>
        </member>
        <member name="M:Nez.LineRenderer.AddSegment(Nez.LineRenderer.Segment@,System.Int32@)">
            <summary>
            adds a segment and takes care of patching the previous elbow
            </summary>
            <param name="segment">Segment.</param>
            <param name="vertIndex">Vert index.</param>
        </member>
        <member name="M:Nez.LineRenderer.AddVert(System.Int32,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>
            adds a vert to the list
            </summary>
            <param name="index">Index.</param>
            <param name="position">Position.</param>
            <param name="texCoord">Tex coordinate.</param>
            <param name="col">Col.</param>
        </member>
        <member name="T:Nez.LineRenderer.Segment">
            <summary>
            helper class used to store some data when calculating verts
            </summary>
        </member>
        <member name="T:Nez.Mesh">
            <summary>
            basic class that can be used to create simple meshes. For more advanced usage subclass and override what is needed. The general gist
            of usage is the following:
            - call setVertPositions
            - call setTriangles to set the triangle indices
            - call recalculateBounds to prepare the Mesh for rendering and culling
            </summary>
        </member>
        <member name="P:Nez.Mesh.Bounds">
            <summary>
            the AABB that wraps this object
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="M:Nez.Mesh.RecalculateBounds(System.Boolean)">
            <summary>
            recalculates the bounds and optionally sets the UVs. The UVs are setup to map the texture in a best fit fashion.
            </summary>
            <param name="recalculateUVs">If set to <c>true</c> recalculate U vs.</param>
        </member>
        <member name="M:Nez.Mesh.SetVertexColorEnabled(System.Boolean)">
            <summary>
            sets whether vertex colors will be used by the shader
            </summary>
            <returns>The enable vertex colors.</returns>
            <param name="shouldEnableVertexColors">If set to <c>true</c> should enable vertex colors.</param>
        </member>
        <member name="M:Nez.Mesh.SetTexture(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets the texture. Pass in null to unset the texture.
            </summary>
            <returns>The texture.</returns>
            <param name="texture">Texture.</param>
        </member>
        <member name="M:Nez.Mesh.SetColorForAllVerts(Microsoft.Xna.Framework.Color)">
            <summary>
            helper that sets the color for all verts
            </summary>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.Mesh.SetColor(Microsoft.Xna.Framework.Color)">
            <summary>
            sets the color for all of the verts
            </summary>
            <returns>The color.</returns>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.Mesh.SetColorForVert(System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            sets the vertex color for a single vert
            </summary>
            <returns>The color for vert.</returns>
            <param name="vertIndex">Vert index.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.Mesh.SetVertPositions(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            sets the vert positions. If the positions array does not match the verts array size the verts array will be recreated.
            </summary>
            <param name="positions">Positions.</param>
        </member>
        <member name="M:Nez.Mesh.SetVertPositions(Microsoft.Xna.Framework.Vector3[])">
            <summary>
            sets the vert positions. If the positions array does not match the verts array size the verts array will be recreated.
            </summary>
            <param name="positions">Positions.</param>
        </member>
        <member name="M:Nez.Mesh.SetTriangles(System.Int32[])">
            <summary>
            sets the triangle indices for rendering
            </summary>
            <returns>The triangles.</returns>
            <param name="triangles">Triangles.</param>
        </member>
        <member name="M:Nez.Mesh.SetPrimitiveType(Microsoft.Xna.Framework.Graphics.PrimitiveType)">
            <summary>
            Change the rendering primitive type.
            If it is PrimitiveType.TriangleStrip then you don't need to setTriangles.
            </summary>
            <param name="primitiveType">The ordering of the verticies.</param>
            <returns>The mesh.</returns>
        </member>
        <member name="T:Nez.Particles.Particle">
            <summary>
            the internal fields are required for the ParticleEmitter to be able to render the Particle
            </summary>
        </member>
        <member name="F:Nez.Particles.Particle._circleCollisionShape">
            <summary>
            shared Circle used for collisions checks
            </summary>
        </member>
        <member name="F:Nez.Particles.Particle._collided">
            <summary>
            flag indicating if this particle has already collided so that we know not to move it in the normal fashion
            </summary>
        </member>
        <member name="M:Nez.Particles.Particle.Update(Nez.Particles.ParticleEmitterConfig,Nez.ParticleCollisionConfig@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            updates the particle. Returns true when the particle is no longer alive
            </summary>
            <param name="emitterConfig">Emitter config.</param>
        </member>
        <member name="M:Nez.Particles.Particle.CalculateCollisionResponseVelocity(System.Single,System.Single,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            given the relative velocity between the two objects and the MTV this method modifies the relativeVelocity to make it a collision
            response.
            </summary>
            <param name="relativeVelocity">Relative velocity.</param>
            <param name="minimumTranslationVector">Minimum translation vector.</param>
        </member>
        <member name="P:Nez.Particles.ParticleEmitter.SimulateInWorldSpace">
            <summary>
            convenience method for setting ParticleEmitterConfig.simulateInWorldSpace. If true, particles will simulate in world space. ie when the
            parent Transform moves it will have no effect on any already active Particles.
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitter.CollisionConfig">
            <summary>
            config object with various properties to deal with particle collisions
            </summary>
        </member>
        <member name="E:Nez.Particles.ParticleEmitter.OnAllParticlesExpired">
            <summary>
            event that's going to be called when particles count becomes 0 after stopping emission.
            emission can stop after either we stop it manually or when we run for entire duration specified in ParticleEmitterConfig.
            </summary>
        </member>
        <member name="E:Nez.Particles.ParticleEmitter.OnEmissionDurationReached">
            <summary>
            event that's going to be called when emission is stopped due to reaching duration specified in ParticleEmitterConfig
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitter._emitCounter">
            <summary>
            keeps track of how many particles should be emitted
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitter._elapsedTime">
            <summary>
            tracks the elapsed time of the emitter
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitter._emitting">
            <summary>
            if the emitter is emitting this will be true. Note that emitting can be false while particles are still alive. emitting gets set
            to false and then any live particles are allowed to finish their lifecycle.
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Init">
            <summary>
            creates the Batcher and loads the texture if it is available
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Clear">
            <summary>
            removes all particles from the particle emitter
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Play">
            <summary>
            plays the particle emitter
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Stop">
            <summary>
            stops the particle emitter
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Pause">
            <summary>
            pauses the particle emitter
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.ResumeEmission">
            <summary>
            resumes emission of particles.
            this is possible only if stop() wasn't called and emission wasn't stopped due to duration
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.PauseEmission">
            <summary>
            pauses emission of particles while allowing existing particles to expire
            </summary>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.Emit(System.Int32)">
            <summary>
            manually emit some particles
            </summary>
            <param name="count">Count.</param>
        </member>
        <member name="M:Nez.Particles.ParticleEmitter.AddParticle(Microsoft.Xna.Framework.Vector2)">
            <summary>
            adds a Particle to the emitter
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitterConfig.SimulateInWorldSpace">
            <summary>
            If true, particles will simulate in world space. ie when the parent Transform moves it will have no effect on any already active Particles.
            </summary>
        </member>
        <member name="F:Nez.Particles.ParticleEmitterConfig.SourcePosition">
            <summary>
            sourcePosition is read in but internally it is not used. The ParticleEmitter.localPosition is what the emitter will use for positioning
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.Enabled">
            <summary>
            enable/disable particle collision
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.RadiusScale">
            <summary>
            A multiplier applied to the size of each particle before collisions are processed.
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.Elasticity">
            <summary>
            0 - 1 range where 0 is no bounce and 1 is perfect reflection
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.Friction">
            <summary>
            0 - 1 range. 0 means no friction, 1 means the object will stop dead on
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.CollidesWithLayers">
            <summary>
            control which layers this particle system collides with
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.Gravity">
            <summary>
            gravity value used for simulation after a collision occurs
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.LifetimeLoss">
            <summary>
            how much a particle's lifetime is reduced after a collision. 0 is none and 1 is all of it.
            </summary>
        </member>
        <member name="F:Nez.ParticleCollisionConfig.MinKillSpeedSquared">
            <summary>
            kill particles whose squared speed falls below this threshold, after a collision
            </summary>
        </member>
        <member name="T:Nez.Shadows.EndPoint">
            <summary>    
            The end-point of a segment    
            </summary>
        </member>
        <member name="F:Nez.Shadows.EndPoint.position">
            <summary>
            Position of the segment
            </summary>
        </member>
        <member name="F:Nez.Shadows.EndPoint.begin">
            <summary>
            If this end-point is a begin or end end-point
            of a segment (each segment has only one begin and one end end-point
            </summary>
        </member>
        <member name="F:Nez.Shadows.EndPoint.segment">
            <summary>
            The segment this end-point belongs to
            </summary>
        </member>
        <member name="F:Nez.Shadows.EndPoint.angle">
            <summary>
            The angle of the end-point relative to the location of the visibility test
            </summary>
        </member>
        <member name="T:Nez.Shadows.PolyLight">
            <summary>
            Point light that also casts shadows
            </summary>
        </member>
        <member name="F:Nez.Shadows.PolyLight.CollidesWithLayers">
            <summary>
            layer mask of all the layers this light should interact with. defaults to all layers.
            </summary>
        </member>
        <member name="P:Nez.Shadows.PolyLight.Radius">
            <summary>
            Radius of influence of the light
            </summary>
        </member>
        <member name="F:Nez.Shadows.PolyLight.Power">
            <summary>
            Power of the light, from 0 (turned off) to 1 for maximum brightness
            </summary>
        </member>
        <member name="M:Nez.Shadows.PolyLight.GetOverlappedColliders">
            <summary>
            fetches any Colliders that should be considered for occlusion. Subclasses with a shape other than a circle can override this.
            </summary>
            <returns>The overlapped components.</returns>
        </member>
        <member name="M:Nez.Shadows.PolyLight.LoadVisibilityBoundaries">
            <summary>
            override point for calling through to VisibilityComputer that allows subclasses to setup their visibility boundaries for
            different shaped lights.
            </summary>
        </member>
        <member name="M:Nez.Shadows.PolyLight.AddVert(Microsoft.Xna.Framework.Vector2)">
            <summary>
            adds a vert to the list
            </summary>
            <param name="position">Position.</param>
        </member>
        <member name="T:Nez.Shadows.PolySpotLight">
            <summary>
            WIP: still has some odd rendering bugs that need to get worked out
            poly spot light. Works just like a PolyLight except it is limited to a cone shape (spotAngle).
            </summary>
        </member>
        <member name="P:Nez.Shadows.PolySpotLight.SpotAngle">
            <summary>
            the angle of the light's spotlight cone in degrees. Defaults to 45.
            </summary>
            <value>The spot angle.</value>
        </member>
        <member name="M:Nez.Shadows.PolySpotLight.RecalculatePolyPoints">
            <summary>
            calculates the points needed to encompass the spot light. The points generate a polygon which is used for overlap detection.
            </summary>
        </member>
        <member name="T:Nez.Shadows.Segment">
            <summary>
            Represents an occluding line segment in the visibility mesh
            </summary>
        </member>
        <member name="F:Nez.Shadows.Segment.p1">
            <summary>
            First end-point of the segment
            </summary>
        </member>
        <member name="F:Nez.Shadows.Segment.p2">
            <summary>
            Second end-point of the segment
            </summary>
        </member>
        <member name="T:Nez.Shadows.VisibilityComputer">
            <summary>
            Class which computes a mesh that represents which regions are visibile from the origin point given a set of occluders. Usage is as
            follows:
            
            - call begin
            - add any occluders
            - call end to get the visibility polygon. When end is called all internal storage is cleared.
            
            based on: http://www.redblobgames.com/articles/visibility/ and http://roy-t.nl/index.php/2014/02/27/2d-lighting-and-shadows-preview/
            </summary>
        </member>
        <member name="F:Nez.Shadows.VisibilityComputer.LineCountForCircleApproximation">
            <summary>
            total number of lines that will be used when approximating a circle. Only a 180 degree hemisphere is needed so this will be the number
            of segments to approximate that hemisphere.
            </summary>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.AddColliderOccluder(Nez.Collider)">
            <summary>
            adds a Collider as an occluder for the PolyLight
            </summary>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.AddSquareOccluder(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            Add a square shaped occluder
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.AddSquareOccluder(Nez.RectangleF)">
            <summary>
            Add a square shaped occluder
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.AddCircleOccluder(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            adds a circle shaped occluder
            </summary>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.AddLineOccluder(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Add a line shaped occluder
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.ClearOccluders">
            <summary>
            Remove all occluders
            </summary>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.Begin(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            prepares the computer for calculating the current poly light
            </summary>
            <param name="origin">Origin.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.End">
            <summary>
            Computes the visibility polygon and returns the vertices of the triangle fan (minus the center vertex). Returned List is from the
            ListPool.
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.LoadRectangleBoundaries">
            <summary>
            Helper function to construct segments along the outside perimiter in order to limit the radius of the light
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.UpdateSegments">
            <summary>
            Processes segments so that we can sort them later
            </summary>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.IsSegmentInFrontOf(Nez.Shadows.Segment,Nez.Shadows.Segment,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Helper: do we know that segment a is in front of b? Implementation not anti-symmetric (that is to say,
            isSegmentInFrontOf(a, b) != (!isSegmentInFrontOf(b, a)). Also note that it only has to work in a restricted set of cases
            in the visibility algorithm; I don't think it handles all cases. See http://www.redblobgames.com/articles/visibility/segment-sorting.html
            </summary>
            <returns><c>true</c>, if in front of was segmented, <c>false</c> otherwise.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="relativeTo">Relative to.</param>
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.LineLineIntersection(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Computes the intersection point of the line p1-p2 with p3-p4
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.IsLeftOf(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns if the point is 'left' of the line p1-p2
            </summary>        
        </member>
        <member name="M:Nez.Shadows.VisibilityComputer.Interpolate(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            Returns a slightly shortened version of the vector:
            p * (1 - f) + q * f
            </summary>        
        </member>
        <member name="T:Nez.PolygonMesh">
            <summary>
            renders a basic, CCW, convex polygon
            </summary>
        </member>
        <member name="T:Nez.RenderableComponent">
             <summary>
             concrete implementation of IRenderable. Contains convenience methods.
            
             VERY IMPORTANT! Subclasses MUST either override width/height or bounds!
             </summary>
        </member>
        <member name="P:Nez.RenderableComponent.Width">
            <summary>
            width of the RenderableComponent. subclasses that do not override the bounds property must implement this!
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:Nez.RenderableComponent.Height">
            <summary>
            height of the RenderableComponent. subclasses that do not override the bounds property must implement this!
            </summary>
            <value>The height.</value>
        </member>
        <member name="P:Nez.RenderableComponent.Bounds">
            <summary>
            the AABB that wraps this object. Used for camera culling.
            </summary>
            <value>The bounds.</value>
        </member>
        <member name="P:Nez.RenderableComponent.LayerDepth">
            <summary>
            standard Batcher layerdepth. 0 is in front and 1 is in back. Changing this value will trigger a sort of the renderableComponents
            list on the scene.
            </summary>
        </member>
        <member name="P:Nez.RenderableComponent.RenderLayer">
            <summary>
            lower renderLayers are in the front and higher are in the back, just like layerDepth but not clamped to 0-1. Note that this means
            higher renderLayers are sent to the Batcher first. An important fact when using the stencil buffer.
            </summary>
            <value>The render layer.</value>
        </member>
        <member name="F:Nez.RenderableComponent.Color">
            <summary>
            color passed along to the Batcher when rendering
            </summary>
        </member>
        <member name="P:Nez.RenderableComponent.Material">
            <summary>
            used by Renderers to specify how this sprite should be rendered
            </summary>
        </member>
        <member name="P:Nez.RenderableComponent.LocalOffset">
            <summary>
            offset from the parent entity. Useful for adding multiple Renderables to an Entity that need specific positioning.
            </summary>
            <value>The local position.</value>
        </member>
        <member name="P:Nez.RenderableComponent.IsVisible">
            <summary>
            the visibility of this Renderable. Changes in state end up calling the onBecameVisible/onBecameInvisible methods.
            </summary>
            <value><c>true</c> if is visible; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.RenderableComponent.Render(Nez.Batcher,Nez.Camera)">
            <summary>
            called by a Renderer. The Camera can be used for culling and the Batcher instance to draw with.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="camera">Camera.</param>
        </member>
        <member name="M:Nez.RenderableComponent.DebugRender(Nez.Batcher)">
            <summary>
            renders the bounds only if there is no collider. Always renders a square on the origin.
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="M:Nez.RenderableComponent.OnBecameVisible">
            <summary>
            called when the Renderable enters the camera frame. Note that these methods will not be called if your Renderer does not use
            isVisibleFromCamera for its culling check. All default Renderers do.
            </summary>
        </member>
        <member name="M:Nez.RenderableComponent.OnBecameInvisible">
            <summary>
            called when the renderable exits the camera frame. Note that these methods will not be called if your Renderer does not use
            isVisibleFromCamera for its culling check. All default Renderers do.
            </summary>
        </member>
        <member name="M:Nez.RenderableComponent.IsVisibleFromCamera(Nez.Camera)">
            <summary>
            returns true if the Renderables bounds intersects the Camera.bounds. Handles state switches for the isVisible flag. Use this method
            in your render method to see decide if you should render or not.
            </summary>
            <returns><c>true</c>, if visible from camera was ised, <c>false</c> otherwise.</returns>
            <param name="camera">Camera.</param>
        </member>
        <member name="M:Nez.RenderableComponent.SetLayerDepth(System.Single)">
            <summary>
            standard Batcher layerdepth. 0 is in front and 1 is in back. Changing this value will trigger a sort of the renderableComponents
            </summary>
            <returns>The layer depth.</returns>
            <param name="layerDepth">Value.</param>
        </member>
        <member name="M:Nez.RenderableComponent.SetRenderLayer(System.Int32)">
            <summary>
            lower renderLayers are in the front and higher are in the back, just like layerDepth but not clamped to 0-1. Note that this means
            higher renderLayers are sent to the Batcher first. An important fact when using the stencil buffer.
            </summary>
            <returns>The render layer.</returns>
            <param name="renderLayer">Render layer.</param>
        </member>
        <member name="M:Nez.RenderableComponent.SetColor(Microsoft.Xna.Framework.Color)">
            <summary>
            color passed along to the Batcher when rendering
            </summary>
            <returns>The color.</returns>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.RenderableComponent.SetLocalOffset(Microsoft.Xna.Framework.Vector2)">
            <summary>
            offset from the parent entity. Useful for adding multiple Renderables to an Entity that need specific positioning.
            </summary>
            <returns>The local offset.</returns>
            <param name="offset">Offset.</param>
        </member>
        <member name="M:Nez.RenderableComponent.GetMaterial``1">
            <summary>
            helper for retrieving a Material subclass already casted
            </summary>
            <returns>The material.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.RenderableComponent.CompareTo(Nez.RenderableComponent)">
            <Docs>To be added.</Docs>
            <para>Returns the sort order of the current instance compared to the specified object.</para>
            <summary>
            sorted first by renderLayer, then layerDepth and finally material
            </summary>
            <returns>The to.</returns>
            <param name="other">Other.</param>
        </member>
        <member name="T:Nez.SpringGrid">
            <summary>
            grid of springs
            based on the tutorial: http://gamedevelopment.tutsplus.com/tutorials/make-a-neon-vector-shooter-for-ios-the-warping-grid--gamedev-14637
            </summary>
        </member>
        <member name="P:Nez.SpringGrid.Width">
            <summary>
            width of the grid
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:Nez.SpringGrid.Height">
            <summary>
            height of the grid
            </summary>
            <value>The height.</value>
        </member>
        <member name="F:Nez.SpringGrid.GridMajorColor">
            <summary>
            color of all major grid lines
            </summary>
        </member>
        <member name="F:Nez.SpringGrid.GridMinorColor">
            <summary>
            color of all minor grid lines
            </summary>
        </member>
        <member name="F:Nez.SpringGrid.GridMajorThickness">
            <summary>
            thickness of all major grid lines
            </summary>
        </member>
        <member name="F:Nez.SpringGrid.GridMinorThickness">
            <summary>
            thickness of all minor grid lines
            </summary>
        </member>
        <member name="F:Nez.SpringGrid.GridMajorPeriodX">
            <summary>
            how often a major grid line should appear on the x axis
            </summary>
        </member>
        <member name="F:Nez.SpringGrid.GridMajorPeriodY">
            <summary>
            how often a major grid line should appear on the y axis
            </summary>
        </member>
        <member name="M:Nez.SpringGrid.SetGridSizeAndSpacing(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets up the SpringGrid springs and points so that it can be drawn
            </summary>
            <param name="gridSize"></param>
            <param name="spacing"></param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyDirectedForce(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            applies a force in a 3-dimensional direction
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyDirectedForce(Microsoft.Xna.Framework.Vector3,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            applies a force in a 3-dimensional direction
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyImplosiveForce(System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            applies a force that sucks the grid in towards the point
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyImplosiveForce(System.Single,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            applies a force that sucks the grid in towards the point
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyExplosiveForce(System.Single,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            applies a force the pushes the grid out aware from the point
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.SpringGrid.ApplyExplosiveForce(System.Single,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            applies a force the pushes the grid out aware from the point
            </summary>
            <param name="force">Force.</param>
            <param name="position">Position.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="F:Nez.NinePatchSpriteRenderer._finalRenderRect">
            <summary>
            full area in which we will be rendering
            </summary>
        </member>
        <member name="T:Nez.PrototypeSpriteRenderer">
            <summary>
            skewable rectangle sprite for prototyping
            </summary>
        </member>
        <member name="M:Nez.PrototypeSpriteRenderer.SetWidth(System.Single)">
            <summary>
            sets the width of the sprite
            </summary>
            <returns>The width.</returns>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.PrototypeSpriteRenderer.SetHeight(System.Single)">
            <summary>
            sets the height of the sprite
            </summary>
            <returns>The height.</returns>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.PrototypeSpriteRenderer.SetSkew(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            sets the skew values for the sprite
            </summary>
            <returns>The skew.</returns>
            <param name="skewTopX">Skew top x.</param>
            <param name="skewBottomX">Skew bottom x.</param>
            <param name="skewLeftY">Skew left y.</param>
            <param name="skewRightY">Skew right y.</param>
        </member>
        <member name="T:Nez.SpriteOutlineRenderer">
            <summary>
            renders a sprite with an outline in a very inefficient (but simple) way. The sprite is rendered multiple times offset/colored then it
            is rendered normally on top of that.
            </summary>
        </member>
        <member name="F:Nez.SpriteOutlineRenderer.OutlineWidth">
            <summary>
            the width of the outline
            </summary>
        </member>
        <member name="F:Nez.SpriteOutlineRenderer.OutlineColor">
            <summary>
            the color the sprite will be tinted when it is rendered
            </summary>
        </member>
        <member name="M:Nez.SpriteOutlineRenderer.#ctor(Nez.Sprites.SpriteRenderer)">
            <summary>
            the Sprite passed in will be disabled. The SpriteOutlineRenderer will handle manually calling its render method.
            </summary>
            <param name="sprite">Sprite.</param>
        </member>
        <member name="T:Nez.TiledSpriteRenderer">
            <summary>
            Tiled sprite. Note that TiledSprite overrides the Material so that it can wrap the UVs. This class requires the texture
            to not be part of an atlas so that wrapping can work.
            </summary>
        </member>
        <member name="P:Nez.TiledSpriteRenderer.ScrollX">
            <summary>
            x value of the texture scroll
            </summary>
            <value>The scroll x.</value>
        </member>
        <member name="P:Nez.TiledSpriteRenderer.ScrollY">
            <summary>
            y value of the texture scroll
            </summary>
            <value>The scroll y.</value>
        </member>
        <member name="P:Nez.TiledSpriteRenderer.TextureScale">
            <summary>
            scale of the texture
            </summary>
            <value>The texture scale.</value>
        </member>
        <member name="P:Nez.TiledSpriteRenderer.Width">
            <summary>
            overridden width value so that the TiledSprite can have an independent width than its texture
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:Nez.TiledSpriteRenderer.Height">
            <summary>
            overridden height value so that the TiledSprite can have an independent height than its texture
            </summary>
            <value>The height.</value>
        </member>
        <member name="F:Nez.TiledSpriteRenderer._sourceRect">
            <summary>
            we keep a copy of the sourceRect so that we dont change the Sprite in case it is used elsewhere
            </summary>
        </member>
        <member name="T:Nez.StencilLight">
            <summary>
            Light that works with the StencilLightRenderer. This uses a texture-less shader with a simple falloff calculation to draw a light.
            </summary>
        </member>
        <member name="P:Nez.StencilLight.Radius">
            <summary>
            Radius of influence of the light
            </summary>
        </member>
        <member name="F:Nez.StencilLight.Power">
            <summary>
            Power of the light, from 0 (turned off) to 1 for maximum brightness
            </summary>
        </member>
        <member name="F:Nez.TiledMapRenderer.LayerIndicesToRender">
            <summary>
            if null, all layers will be rendered
            </summary>
        </member>
        <member name="M:Nez.TiledMapRenderer.SetLayerToRender(System.String)">
            <summary>
            sets this component to only render a single layer
            </summary>
            <param name="layerName">Layer name.</param>
        </member>
        <member name="M:Nez.TiledMapRenderer.SetLayersToRender(System.String[])">
            <summary>
            sets which layers should be rendered by this component by name. If you know the indices you can set layerIndicesToRender directly.
            </summary>
            <param name="layerNames">Layer names.</param>
        </member>
        <member name="M:Nez.TiledMapRenderer.GetTileAtWorldPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            this method requires that you are using a collision layer setup in the constructor.
            </summary>
        </member>
        <member name="M:Nez.TiledMapRenderer.GetTilesIntersectingBounds(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            gets all the non-empty tiles that intersect the passed in bounds for the collision layer. The returned List can be put back in the
            pool via ListPool.free.
            </summary>
            <returns>The tiles intersecting bounds.</returns>
            <param name="bounds">Bounds.</param>
        </member>
        <member name="T:Nez.TrailRibbon">
            <summary>
            Renders a trail behind a moving object
            Adapted from http://www.paradeofrain.com/2010/01/28/update-on-continuous-2d-trails-in-xna/
            </summary>
        </member>
        <member name="F:Nez.TrailRibbon.StartColor">
            <summary>
            starting color of the ribbon
            </summary>
        </member>
        <member name="F:Nez.TrailRibbon.EndColor">
            <summary>
            end (tail) color of the ribbon
            </summary>
        </member>
        <member name="F:Nez.TrailRibbon.RibbonRadius">
            <summary>
            max pixel radius of the ribbon
            </summary>
        </member>
        <member name="M:Nez.TrailRibbon.InitializeVertices">
            <summary>
            builds the intialial ribbon segments
            </summary>
        </member>
        <member name="M:Nez.TrailRibbon.CalculateVertices">
            <summary>
            transfers the data from our segments to the vertices for display
            </summary>
        </member>
        <member name="T:Nez.UICanvas">
            <summary>
            simple component that houses a Stage and delegates update/render/debugRender calls
            </summary>
        </member>
        <member name="P:Nez.UICanvas.IsFullScreen">
            <summary>
            if true, the rawMousePosition will be used else the scaledMousePosition will be used. If your UI is in screen space (using a 
            ScreenSpaceRenderer for example) then set this to true so input is not scaled.
            </summary>
        </member>
        <member name="M:Nez.UICanvas.ShowDialog(System.String,System.String,System.String)">
            <summary>
            displays a simple dialog with a button to close it
            </summary>
            <returns>The dialog.</returns>
            <param name="title">Title.</param>
            <param name="messageText">Message text.</param>
            <param name="closeButtonText">Close button text.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Nez.WaterReflectionPlane" -->
        <member name="F:Nez.FramesPerSecondCounter.MaximumSamples">
            <summary>
            total number of samples that should be stored and averaged for calculating the FPS
            </summary>
        </member>
        <member name="P:Nez.FramesPerSecondCounter.DockPosition">
            <summary>
            position the FPS counter should be docked
            </summary>
            <value>The dock position.</value>
        </member>
        <member name="P:Nez.FramesPerSecondCounter.DockOffset">
            <summary>
            offset from dockPosition the FPS counter should be drawn
            </summary>
            <value>The dock offset.</value>
        </member>
        <member name="M:Nez.FramesPerSecondCounter.SetDockOffset(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Sets how far the fps text will appear from the edges of the screen.
            </summary>
            <param name="dockOffset">Offset from screen edges</param>
        </member>
        <member name="M:Nez.FramesPerSecondCounter.SetDockPosition(Nez.FramesPerSecondCounter.FPSDockPosition)">
            <summary>
            Sets which corner of the screen the fps text will show.
            </summary>
            <param name="dockPosition">Corner of the screen</param>
        </member>
        <member name="T:Nez.MarkupText">
            <summary>
            MarkupText lets you set fonts, textures and conditionals and provide some XML text to render that uses them. You must first
            set the fonts, textures and conditionals before you can use them in your markup.
            
            <![CDATA[
            <markuptext face="RegularFont" color="#ffffff" align="left">
            	<font face="Large" color="#00ff00" scale="3.2,3.2">Lorem Ipsum</font>
            	<p align="right">Some more text <text color='#ff9900'>with color</text> in the middle</p>
            	<p align="center">Images are inlined too <img src="texture" scale="2,2" /></p>
            	<if condition="isTrue"><img src="otherTexture" scale="0.2,0.2" /></if>
            	<p>conditions can be negated as well <if condition="!isTrue">isTrue isnt true<else>isTrue is true</else></if></p>
            </markuptext>
            ]]>
            </summary>
        </member>
        <member name="M:Nez.MarkupText.SetText(System.String)">
            <summary>
            sets the text used for the run. Text should be valid XML.
            </summary>
            <returns>The text.</returns>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.MarkupText.SetTextWidth(System.Single)">
            <summary>
            sets the width that the run will fill
            </summary>
            <returns>The width.</returns>
            <param name="textWidth">Width.</param>
        </member>
        <member name="M:Nez.MarkupText.SetFont(System.String,Nez.IFont)">
            <summary>
            sets a font that can be used in a text tag via the font attribute
            </summary>
            <returns>The font.</returns>
            <param name="name">Name.</param>
            <param name="font">Font.</param>
        </member>
        <member name="M:Nez.MarkupText.SetTexture(System.String,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets a texture which can be used in an img tag via the source attribute
            </summary>
            <returns>The texture.</returns>
            <param name="name">Name.</param>
            <param name="texture">Texture.</param>
        </member>
        <member name="M:Nez.MarkupText.SetConditional(System.String,System.Boolean)">
            <summary>
            sets a conditional which can be used in an if tag with a condition attribute. It is also valid to negate the condition by
            prepending a ! to the name in the if tag
            </summary>
            <returns>The conditional.</returns>
            <param name="name">Name.</param>
            <param name="conditional">Conditional.</param>
        </member>
        <member name="M:Nez.MarkupText.Render(Nez.Batcher,Nez.Camera)">
            <summary>
            renders the MarkupText
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="camera">Camera.</param>
        </member>
        <member name="M:Nez.MarkupText.Compile">
            <summary>
            compiles the current text to prepare it for rendering
            </summary>
        </member>
        <member name="P:Nez.TextComponent.Text">
            <summary>
            text to draw
            </summary>
            <value>The text.</value>
        </member>
        <member name="P:Nez.TextComponent.HorizontalOrigin">
            <summary>
            horizontal alignment of the text
            </summary>
            <value>The horizontal origin.</value>
        </member>
        <member name="P:Nez.TextComponent.VerticalOrigin">
            <summary>
            vertical alignment of the text
            </summary>
            <value>The vertical origin.</value>
        </member>
        <member name="T:Nez.TextRun">
            <summary>
            provides a cached run of text for super fast text drawing. Note that this is only appropriate for text that doesnt change often
            and doesnt move.
            </summary>
        </member>
        <member name="P:Nez.TextRun.Text">
            <summary>
            text to draw
            </summary>
            <value>The text.</value>
        </member>
        <member name="P:Nez.TextRun.HorizontalOrigin">
            <summary>
            horizontal alignment of the text
            </summary>
            <value>The horizontal origin.</value>
        </member>
        <member name="P:Nez.TextRun.VerticalOrigin">
            <summary>
            vertical alignment of the text
            </summary>
            <value>The vertical origin.</value>
        </member>
        <member name="M:Nez.TextRun.Compile">
            <summary>
            compiles the text into raw verts/texture coordinates. This method must be called anytime text or any other properties are
            changed.
            </summary>
        </member>
        <member name="T:Nez.TextRunComponent">
            <summary>
            very basic wrapper around TextRun. Note that the TextRunComponent.compile method should be used not TextRun.compile so that
            the Component data can be passed off to the TextRun.
            </summary>
        </member>
        <member name="M:Nez.TextRunComponent.Compile">
            <summary>
            calls through to TextRun.compile and handles marshalling some data between this Component and the underlying TextRun
            </summary>
        </member>
        <member name="F:Nez.Entity.Scene">
            <summary>
            the scene this entity belongs to
            </summary>
        </member>
        <member name="F:Nez.Entity.Name">
            <summary>
            entity name. useful for doing scene-wide searches for an entity
            </summary>
        </member>
        <member name="F:Nez.Entity.Id">
            <summary>
            unique identifer for this Entity
            </summary>
        </member>
        <member name="F:Nez.Entity.Transform">
            <summary>
            encapsulates the Entity's position/rotation/scale and allows setting up a hieararchy
            </summary>
        </member>
        <member name="F:Nez.Entity.Components">
            <summary>
            list of all the components currently attached to this entity
            </summary>
        </member>
        <member name="P:Nez.Entity.Tag">
            <summary>
            use this however you want to. It can later be used to query the scene for all Entities with a specific tag
            </summary>
        </member>
        <member name="F:Nez.Entity.UpdateInterval">
            <summary>
            specifies how often this entitys update method should be called. 1 means every frame, 2 is every other, etc
            </summary>
        </member>
        <member name="P:Nez.Entity.Enabled">
            <summary>
            enables/disables the Entity. When disabled colliders are removed from the Physics system and components methods will not be called
            </summary>
        </member>
        <member name="P:Nez.Entity.UpdateOrder">
            <summary>
            update order of this Entity. updateOrder is also used to sort tag lists on scene.entities
            </summary>
            <value>The order.</value>
        </member>
        <member name="P:Nez.Entity.IsDestroyed">
            <summary>
            if destroy was called, this will be true until the next time Entitys are processed
            </summary>
        </member>
        <member name="F:Nez.Entity._isDestroyed">
            <summary>
            flag indicating if destroy was called on this Entity
            </summary>
        </member>
        <member name="M:Nez.Entity.SetTag(System.Int32)">
            <summary>
            sets the tag for the Entity
            </summary>
            <returns>The tag.</returns>
            <param name="tag">Tag.</param>
        </member>
        <member name="M:Nez.Entity.SetEnabled(System.Boolean)">
            <summary>
            sets the enabled state of the Entity. When disabled colliders are removed from the Physics system and components methods will not be called
            </summary>
            <returns>The enabled.</returns>
            <param name="isEnabled">If set to <c>true</c> is enabled.</param>
        </member>
        <member name="M:Nez.Entity.SetUpdateOrder(System.Int32)">
            <summary>
            sets the update order of this Entity. updateOrder is also used to sort tag lists on scene.entities
            </summary>
            <returns>The update order.</returns>
            <param name="updateOrder">Update order.</param>
        </member>
        <member name="M:Nez.Entity.Destroy">
            <summary>
            removes the Entity from the scene and destroys all children
            </summary>
        </member>
        <member name="M:Nez.Entity.DetachFromScene">
            <summary>
            detaches the Entity from the scene.
            the following lifecycle method will be called on the Entity: OnRemovedFromScene
            the following lifecycle method will be called on the Components: OnRemovedFromEntity
            </summary>
        </member>
        <member name="M:Nez.Entity.AttachToScene(Nez.Scene)">
            <summary>
            attaches an Entity that was previously detached to a new scene
            </summary>
            <param name="newScene">New scene.</param>
        </member>
        <member name="M:Nez.Entity.Clone(Microsoft.Xna.Framework.Vector2)">
            <summary>
            creates a deep clone of this Entity. Subclasses can override this method to copy any custom fields. When overriding,
            the CopyFrom method should be called which will clone all Components, Colliders and Transform children for you. Note
            that the cloned Entity will not be added to any Scene! You must add them yourself!
            </summary>
        </member>
        <member name="M:Nez.Entity.CopyFrom(Nez.Entity)">
            <summary>
            copies the properties, components and colliders of Entity to this instance
            </summary>
            <param name="entity">Entity.</param>
        </member>
        <member name="M:Nez.Entity.OnAddedToScene">
            <summary>
            Called when this entity is added to a scene after all pending entity changes are committed
            </summary>
        </member>
        <member name="M:Nez.Entity.OnRemovedFromScene">
            <summary>
            Called when this entity is removed from a scene
            </summary>
        </member>
        <member name="M:Nez.Entity.Update">
            <summary>
            called each frame as long as the Entity is enabled
            </summary>
        </member>
        <member name="M:Nez.Entity.DebugRender(Nez.Batcher)">
            <summary>
            called if Core.debugRenderEnabled is true by the default renderers. Custom renderers can choose to call it or not.
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="M:Nez.Entity.AddComponent``1(``0)">
            <summary>
            Adds a Component to the components list. Returns the Component.
            </summary>
            <returns>Scene.</returns>
            <param name="component">Component.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.AddComponent``1">
            <summary>
            Adds a Component to the components list. Returns the Component.
            </summary>
            <returns>Scene.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.GetComponent``1">
            <summary>
            Gets the first component of type T and returns it. If no components are found returns null.
            </summary>
            <returns>The component.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.TryGetComponent``1(``0@)">
            <summary>
            Tries to get the component of type T. If no components are found returns false.
            </summary>
            <returns>true if a component has been found.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.HasComponent``1">
            <summary>
            checks to see if the Entity has the component
            </summary>
        </member>
        <member name="M:Nez.Entity.GetOrCreateComponent``1">
            <summary>
            Gets the first Component of type T and returns it. If no Component is found the Component will be created.
            </summary>
            <returns>The component.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.GetComponent``1(System.Boolean)">
            <summary>
            Gets the first component of type T and returns it optionally skips checking un-initialized Components (Components who have not yet had their
            onAddedToEntity method called). If no components are found returns null.
            </summary>
            <returns>The component.</returns>
            <param name="onlyReturnInitializedComponents">If set to <c>true</c> only return initialized components.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.GetComponents``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets all the components of type T without a List allocation
            </summary>
            <param name="componentList">Component list.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.GetComponents``1">
            <summary>
            Gets all the components of type T. The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The component.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Entity.RemoveComponent``1">
            <summary>
            removes the first Component of type T from the components list
            </summary>
        </member>
        <member name="M:Nez.Entity.RemoveComponent(Nez.Component)">
            <summary>
            removes a Component from the components list
            </summary>
            <param name="component">The Component to remove</param>
        </member>
        <member name="M:Nez.Entity.RemoveAllComponents">
            <summary>
            removes all Components from the Entity
            </summary>
        </member>
        <member name="F:Nez.ComponentList._components">
            <summary>
            list of components added to the entity
            </summary>
        </member>
        <member name="F:Nez.ComponentList._updatableComponents">
            <summary>
            list of all Components that want update called
            </summary>
        </member>
        <member name="F:Nez.ComponentList._componentsToAdd">
            <summary>
            The list of components that were added this frame. Used to group the components so we can process them simultaneously
            </summary>
        </member>
        <member name="F:Nez.ComponentList._componentsToRemove">
            <summary>
            The list of components that were marked for removal this frame. Used to group the components so we can process them simultaneously
            </summary>
        </member>
        <member name="F:Nez.ComponentList._isComponentListUnsorted">
            <summary>
            flag used to determine if we need to sort our Components this frame
            </summary>
        </member>
        <member name="M:Nez.ComponentList.RemoveAllComponents">
            <summary>
            removes all components from the component list immediately
            </summary>
        </member>
        <member name="M:Nez.ComponentList.UpdateLists">
            <summary>
            handles any Components that need to be removed or added
            </summary>
        </member>
        <member name="M:Nez.ComponentList.GetComponent``1(System.Boolean)">
            <summary>
            Gets the first component of type T and returns it. Optionally skips checking un-initialized Components (Components who have not yet had their
            onAddedToEntity method called). If no components are found returns null.
            </summary>
            <returns>The component.</returns>
            <param name="onlyReturnInitializedComponents">If set to <c>true</c> only return initialized components.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ComponentList.GetComponents``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets all the components of type T without a List allocation
            </summary>
            <param name="components">Components.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ComponentList.GetComponents``1">
            <summary>
            Gets all the components of type T. The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The components.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="F:Nez.EntityList._entities">
            <summary>
            list of entities added to the scene
            </summary>
        </member>
        <member name="F:Nez.EntityList._entitiesToAdd">
            <summary>
            The list of entities that were added this frame. Used to group the entities so we can process them simultaneously
            </summary>
        </member>
        <member name="F:Nez.EntityList._entitiesToRemove">
            <summary>
            The list of entities that were marked for removal this frame. Used to group the entities so we can process them simultaneously
            </summary>
        </member>
        <member name="F:Nez.EntityList._isEntityListUnsorted">
            <summary>
            flag used to determine if we need to sort our entities this frame
            </summary>
        </member>
        <member name="F:Nez.EntityList._entityDict">
            <summary>
            tracks entities by tag for easy retrieval
            </summary>
        </member>
        <member name="M:Nez.EntityList.Add(Nez.Entity)">
            <summary>
            adds an Entity to the list. All lifecycle methods will be called in the next frame.
            </summary>
            <param name="entity">Entity.</param>
        </member>
        <member name="M:Nez.EntityList.Remove(Nez.Entity)">
            <summary>
            removes an Entity from the list. All lifecycle methods will be called in the next frame.
            </summary>
            <param name="entity">Entity.</param>
        </member>
        <member name="M:Nez.EntityList.RemoveAllEntities">
            <summary>
            removes all entities from the entities list
            </summary>
        </member>
        <member name="M:Nez.EntityList.Contains(Nez.Entity)">
            <summary>
            checks to see if the Entity is presently managed by this EntityList
            </summary>
            <param name="entity">Entity.</param>
        </member>
        <member name="M:Nez.EntityList.FindEntity(System.String)">
            <summary>
            returns the first Entity found with a name of name. If none are found returns null.
            </summary>
            <returns>The entity.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.EntityList.EntitiesWithTag(System.Int32)">
            <summary>
            returns a list of all entities with tag. If no entities have the tag an empty list is returned. The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The with tag.</returns>
            <param name="tag">Tag.</param>
        </member>
        <member name="M:Nez.EntityList.EntitiesOfType``1">
            <summary>
            returns a List of all Entities of type T. The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.EntityList.FindComponentOfType``1">
            <summary>
            returns the first Component found in the Scene of type T
            </summary>
            <returns>The component of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.EntityList.FindComponentsOfType``1">
            <summary>
            returns all Components found in the Scene of type T. The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The components of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="F:Nez.RenderableComponentList._components">
            <summary>
            list of components added to the entity
            </summary>
        </member>
        <member name="F:Nez.RenderableComponentList._componentsByRenderLayer">
            <summary>
            tracks components by renderLayer for easy retrieval
            </summary>
        </member>
        <member name="M:Nez.RenderableComponentList.SetRenderLayerNeedsComponentSort(System.Int32)">
            <summary>
            dirties a RenderLayers sort flag, causing a re-sort of all components to occur
            </summary>
            <param name="renderLayer"></param>
        </member>
        <member name="M:Nez.RenderableComponentList.ComponentsWithRenderLayer(System.Int32)">
            <summary>
            fetches all the Components with the given renderLayer. The component list is pre-sorted.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.None">
            <summary>
            Default. RenderTarget matches the sceen size
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.ExactFit">
            <summary>
            The entire application is visible in the specified area without trying to preserve the original aspect ratio.
            Distortion can occur, and the application may appear stretched or compressed.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.NoBorder">
            <summary>
            The entire application fills the specified area, without distortion but possibly with some cropping,
            while maintaining the original aspect ratio of the application.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.NoBorderPixelPerfect">
            <summary>
            Pixel perfect version of NoBorder. Scaling is limited to integer values.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.ShowAll">
            <summary>
            The entire application is visible in the specified area without distortion while maintaining the original
            aspect ratio of the application. Borders can appear on two sides of the application.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.ShowAllPixelPerfect">
            <summary>
            Pixel perfect version of ShowAll. Scaling is limited to integer values.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.FixedHeight">
            <summary>
            The application takes the height of the design resolution size and modifies the width of the internal
            canvas so that it fits the aspect ratio of the device.
            no distortion will occur however you must make sure your application works on different
            aspect ratios
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.FixedHeightPixelPerfect">
            <summary>
            Pixel perfect version of FixedHeight. Scaling is limited to integer values.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.FixedWidth">
            <summary>
            The application takes the width of the design resolution size and modifies the height of the internal
            canvas so that it fits the aspect ratio of the device.
            no distortion will occur however you must make sure your application works on different
            aspect ratios
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.FixedWidthPixelPerfect">
            <summary>
            Pixel perfect version of FixedWidth. Scaling is limited to integer values.
            </summary>
        </member>
        <member name="F:Nez.Scene.SceneResolutionPolicy.BestFit">
            <summary>
            The application takes the width and height that best fits the design resolution with optional cropping inside of the "bleed area"
            and possible letter/pillar boxing. Works just like ShowAll except with horizontal/vertical bleed (padding). Gives you an area much
            like the old TitleSafeArea. Example: if design resolution is 1348x900 and bleed is 148x140 the safe area would be 1200x760 (design
            resolution - bleed).
            </summary>
        </member>
        <member name="F:Nez.Scene.Camera">
            <summary>
            default scene Camera
            </summary>
        </member>
        <member name="F:Nez.Scene.ClearColor">
            <summary>
            clear color that is used in preRender to clear the screen
            </summary>
        </member>
        <member name="F:Nez.Scene.LetterboxColor">
            <summary>
            clear color for the final render of the RenderTarget to the framebuffer
            </summary>
        </member>
        <member name="F:Nez.Scene.SamplerState">
            <summary>
            SamplerState used for the final draw of the RenderTarget to the framebuffer
            </summary>
        </member>
        <member name="F:Nez.Scene.Content">
            <summary>
            Scene-specific ContentManager. Use it to load up any resources that are needed only by this scene. If you have global/multi-scene
            resources you can use Core.contentManager to load them since Nez will not ever unload them.
            </summary>
        </member>
        <member name="F:Nez.Scene.EnablePostProcessing">
            <summary>
            global toggle for PostProcessors
            </summary>
        </member>
        <member name="F:Nez.Scene.Entities">
            <summary>
            The list of entities within this Scene
            </summary>
        </member>
        <member name="F:Nez.Scene.RenderableComponents">
            <summary>
            Manages a list of all the RenderableComponents that are currently on scene Entitys
            </summary>
        </member>
        <member name="P:Nez.Scene.SceneRenderTargetSize">
            <summary>
            gets the size of the sceneRenderTarget
            </summary>
            <value>The size of the scene render texture.</value>
        </member>
        <member name="P:Nez.Scene.SceneRenderTarget">
            <summary>
            accesses the main scene RenderTarget. Some Renderers that use multiple RenderTargets may need to render into them first and then
            render the result into the sceneRenderTarget.
            </summary>
            <value>The scene render target.</value>
        </member>
        <member name="F:Nez.Scene.PixelPerfectScale">
            <summary>
            if the ResolutionPolicy is pixel perfect this will be set to the scale calculated for it
            </summary>
        </member>
        <member name="P:Nez.Scene.FinalRenderDelegate">
            <summary>
            the final render to the screen can be deferred to this delegate if set. This is really only useful for cases where the final render
            might need a full screen size effect even though a small back buffer is used.
            </summary>
            <value>The final render delegate.</value>
        </member>
        <member name="F:Nez.Scene._defaultDesignResolutionSize">
            <summary>
            default resolution size used for all scenes
            </summary>
        </member>
        <member name="F:Nez.Scene._defaultDesignBleedSize">
            <summary>
            default bleed size for <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/> resolution policy
            </summary>
        </member>
        <member name="F:Nez.Scene._defaultSceneResolutionPolicy">
            <summary>
            default resolution policy used for all scenes
            </summary>
        </member>
        <member name="F:Nez.Scene._resolutionPolicy">
            <summary>
            resolution policy used by the scene
            </summary>
        </member>
        <member name="F:Nez.Scene._designResolutionSize">
            <summary>
            design resolution size used by the scene
            </summary>
        </member>
        <member name="F:Nez.Scene._designBleedSize">
            <summary>
            bleed size for <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/> resolution policy
            </summary>
        </member>
        <member name="F:Nez.Scene._finalRenderDestinationRect">
            <summary>
            this gets setup based on the resolution policy and is used for the final blit of the RenderTarget
            </summary>
        </member>
        <member name="M:Nez.Scene.SetDefaultDesignResolution(System.Int32,System.Int32,Nez.Scene.SceneResolutionPolicy,System.Int32,System.Int32)">
            <summary>
            sets the default design size and resolution policy that new scenes will use. horizontal/verticalBleed are only relevant for BestFit.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="sceneResolutionPolicy">Scene resolution policy.</param>
            <param name="horizontalBleed">Horizontal bleed size. Used only if resolution policy is set to <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/>.</param>
            <param name="verticalBleed">Vertical bleed size. Used only if resolution policy is set to <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/>.</param>
        </member>
        <member name="M:Nez.Scene.CreateWithDefaultRenderer(System.Nullable{Microsoft.Xna.Framework.Color})">
            <summary>
            helper that creates a scene with the DefaultRenderer attached and ready for use
            </summary>
            <returns>The with default renderer.</returns>
        </member>
        <member name="M:Nez.Scene.CreateWithDefaultRenderer``1(System.Nullable{Microsoft.Xna.Framework.Color})">
            <summary>
            helper that creates a scene of type T with the DefaultRenderer attached and ready for use
            </summary>
            <returns>The with default renderer.</returns>
        </member>
        <member name="M:Nez.Scene.Create(System.Nullable{Microsoft.Xna.Framework.Color})">
            <summary>
            helper that creates a scene with no Renderer
            </summary>
            <returns>The with default renderer.</returns>
        </member>
        <member name="M:Nez.Scene.Create``1(System.Nullable{Microsoft.Xna.Framework.Color})">
            <summary>
            helper that creates a scene of type T with no Renderer
            </summary>
            <returns>The with default renderer.</returns>
        </member>
        <member name="M:Nez.Scene.Initialize">
            <summary>
            override this in Scene subclasses and do your loading here. This is called from the contructor after the scene sets itself up but
            before begin is ever called.
            </summary>
        </member>
        <member name="M:Nez.Scene.OnStart">
            <summary>
            override this in Scene subclasses. this will be called when Core sets this scene as the active scene.
            </summary>
        </member>
        <member name="M:Nez.Scene.Unload">
            <summary>
            override this in Scene subclasses and do any unloading necessary here. this is called when Core removes this scene from the active slot.
            </summary>
        </member>
        <member name="M:Nez.Scene.PostRender(Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            any PostProcessors present get to do their processing then we do the final render of the RenderTarget to the screen.
            In almost all cases finalRenderTarget will be null. The only time it will have a value is the first frame of a
            SceneTransition if the transition is requesting the render.
            </summary>
            <returns>The render.</returns>
        </member>
        <member name="M:Nez.Scene.SetDesignResolution(System.Int32,System.Int32,Nez.Scene.SceneResolutionPolicy,System.Int32,System.Int32)">
            <summary>
            sets the design size and resolution policy then updates the render textures
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="sceneResolutionPolicy">Scene resolution policy.</param>
            <param name="horizontalBleed">Horizontal bleed size. Used only if resolution policy is set to <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/>.</param>
            <param name="verticalBleed">Horizontal bleed size. Used only if resolution policy is set to <see cref="F:Nez.Scene.SceneResolutionPolicy.BestFit"/>.</param>
        </member>
        <member name="M:Nez.Scene.RequestScreenshot(System.Action{Microsoft.Xna.Framework.Graphics.Texture2D})">
            <summary>
            after the next draw completes this will clone the backbuffer and call callback with the clone. Note that you must dispose of the
            Texture2D when done with it!
            </summary>
            <param name="callback">Callback.</param>
        </member>
        <member name="M:Nez.Scene.AddSceneComponent``1">
            <summary>
            Adds and returns a SceneComponent to the components list
            </summary>
            <returns>Scene.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.AddSceneComponent``1(``0)">
            <summary>
            Adds and returns a SceneComponent to the components list
            </summary>
            <returns>Scene.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.GetSceneComponent``1">
            <summary>
            Gets the first SceneComponent of type T and returns it. If no component is found returns null.
            </summary>
            <returns>The component.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.GetOrCreateSceneComponent``1">
            <summary>
            Gets the first SceneComponent of type T and returns it. If no SceneComponent is found the SceneComponent will be created.
            </summary>
            <returns>The component.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.RemoveSceneComponent``1">
            <summary>
            removes the first SceneComponent of type T from the components list
            </summary>
            <returns><c>true</c>, if component was removed, <c>false</c> otherwise.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.RemoveSceneComponent(Nez.SceneComponent)">
            <summary>
            removes a SceneComponent from the SceneComponents list
            </summary>
        </member>
        <member name="M:Nez.Scene.AddRenderer``1(``0)">
            <summary>
            adds a Renderer to the scene
            </summary>
            <returns>The renderer.</returns>
            <param name="renderer">Renderer.</param>
        </member>
        <member name="M:Nez.Scene.GetRenderer``1">
            <summary>
            gets the first Renderer of Type T
            </summary>
            <returns>The renderer.</returns>
        </member>
        <member name="M:Nez.Scene.RemoveRenderer(Nez.Renderer)">
            <summary>
            removes the Renderer from the scene
            </summary>
            <param name="renderer">Renderer.</param>
        </member>
        <member name="M:Nez.Scene.AddPostProcessor``1(``0)">
            <summary>
            adds a PostProcessor to the scene. Sets the scene field and calls PostProcessor.onAddedToScene so that PostProcessors can load
            resources using the scenes ContentManager.
            </summary>
            <param name="postProcessor">Post processor.</param>
        </member>
        <member name="M:Nez.Scene.GetPostProcessor``1">
            <summary>
            gets the first PostProcessor of Type T
            </summary>
            <returns>The post processor.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.RemovePostProcessor(Nez.PostProcessor)">
            <summary>
            removes a PostProcessor. Note that unload is not called when removing so if you no longer need the PostProcessor be sure to call
            unload to free resources.
            </summary>
            <param name="postProcessor">Step.</param>
        </member>
        <member name="M:Nez.Scene.CreateEntity(System.String)">
            <summary>
            add the Entity to this Scene, and return it
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nez.Scene.CreateEntity(System.String,Microsoft.Xna.Framework.Vector2)">
            <summary>
            add the Entity to this Scene at position, and return it
            </summary>
            <returns>The entity.</returns>
            <param name="name">Name.</param>
            <param name="position">Position.</param>
        </member>
        <member name="M:Nez.Scene.AddEntity(Nez.Entity)">
            <summary>
            adds an Entity to the Scene's Entities list
            </summary>
            <param name="entity">The Entity to add</param>
        </member>
        <member name="M:Nez.Scene.AddEntity``1(``0)">
            <summary>
            adds an Entity to the Scene's Entities list
            </summary>
            <param name="entity">The Entity to add</param>
        </member>
        <member name="M:Nez.Scene.DestroyAllEntities">
            <summary>
            removes all entities from the scene
            </summary>
        </member>
        <member name="M:Nez.Scene.FindEntity(System.String)">
            <summary>
            searches for and returns the first Entity with name
            </summary>
            <returns>The entity.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.Scene.FindEntitiesWithTag(System.Int32)">
            <summary>
            returns all entities with the given tag
            </summary>
            <returns>The entities by tag.</returns>
            <param name="tag">Tag.</param>
        </member>
        <member name="M:Nez.Scene.EntitiesOfType``1">
            <summary>
            returns all entities of Type T
            </summary>
            <returns>The of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.FindComponentOfType``1">
            <summary>
            returns the first enabled loaded component of Type T
            </summary>
            <returns>The component of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Scene.FindComponentsOfType``1">
            <summary>
            returns a list of all enabled loaded components of Type T
            </summary>
            <returns>The components of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="F:Nez.SceneComponent.Scene">
            <summary>
            the scene this SceneComponent is attached to
            </summary>
        </member>
        <member name="P:Nez.SceneComponent.Enabled">
            <summary>
            true if the SceneComponent is enabled. Changes in state result in onEnabled/onDisable being called.
            </summary>
            <value><c>true</c> if enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.SceneComponent.UpdateOrder">
            <summary>
            update order of the SceneComponents on this Scene
            </summary>
            <value>The order.</value>
        </member>
        <member name="M:Nez.SceneComponent.OnEnabled">
            <summary>
            called when this SceneComponent is enabled
            </summary>
        </member>
        <member name="M:Nez.SceneComponent.OnDisabled">
            <summary>
            called when the this SceneComponent is disabled
            </summary>
        </member>
        <member name="M:Nez.SceneComponent.OnRemovedFromScene">
            <summary>
            called when this SceneComponent is removed from the Scene
            </summary>
        </member>
        <member name="M:Nez.SceneComponent.Update">
            <summary>
            called each frame before the Entities are updated
            </summary>
        </member>
        <member name="M:Nez.SceneComponent.SetEnabled(System.Boolean)">
            <summary>
            enables/disables this SceneComponent
            </summary>
            <returns>The enabled.</returns>
            <param name="isEnabled">If set to <c>true</c> is enabled.</param>
        </member>
        <member name="M:Nez.SceneComponent.SetUpdateOrder(System.Int32)">
            <summary>
            sets the updateOrder for the SceneComponent and triggers a sort of the SceneComponents
            </summary>
            <returns>The update order.</returns>
            <param name="updateOrder">Update order.</param>
        </member>
        <member name="M:Nez.ScreenSpaceCamera.UpdateMatrixes">
            <summary>
            we are screen space, so our matrixes should always be identity
            </summary>
        </member>
        <member name="F:Nez.Transform.Entity">
            <summary>
            the Entity associated with this transform
            </summary>
        </member>
        <member name="P:Nez.Transform.Parent">
            <summary>
            the parent Transform of this Transform
            </summary>
            <value>The parent.</value>
        </member>
        <member name="P:Nez.Transform.ChildCount">
            <summary>
            total children of this Transform
            </summary>
            <value>The child count.</value>
        </member>
        <member name="P:Nez.Transform.Position">
            <summary>
            position of the transform in world space
            </summary>
            <value>The position.</value>
        </member>
        <member name="P:Nez.Transform.LocalPosition">
            <summary>
            position of the transform relative to the parent transform. If the transform has no parent, it is the same as Transform.position
            </summary>
            <value>The local position.</value>
        </member>
        <member name="P:Nez.Transform.Rotation">
            <summary>
            rotation of the transform in world space in radians
            </summary>
            <value>The rotation.</value>
        </member>
        <member name="P:Nez.Transform.RotationDegrees">
            <summary>
            rotation of the transform in world space in degrees
            </summary>
            <value>The rotation degrees.</value>
        </member>
        <member name="P:Nez.Transform.LocalRotation">
            <summary>
            the rotation of the transform relative to the parent transform's rotation. If the transform has no parent, it is the same as Transform.rotation
            </summary>
            <value>The local rotation.</value>
        </member>
        <member name="P:Nez.Transform.LocalRotationDegrees">
            <summary>
            rotation of the transform relative to the parent transform's rotation in degrees
            </summary>
            <value>The rotation degrees.</value>
        </member>
        <member name="P:Nez.Transform.Scale">
            <summary>
            global scale of the transform
            </summary>
            <value>The scale.</value>
        </member>
        <member name="P:Nez.Transform.LocalScale">
            <summary>
            the scale of the transform relative to the parent. If the transform has no parent, it is the same as Transform.scale
            </summary>
            <value>The local scale.</value>
        </member>
        <member name="M:Nez.Transform.GetChild(System.Int32)">
            <summary>
            returns the Transform child at index
            </summary>
            <returns>The child.</returns>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.Transform.SetParent(Nez.Transform)">
            <summary>
            sets the parent Transform of this Transform
            </summary>
            <returns>The parent.</returns>
            <param name="parent">Parent.</param>
        </member>
        <member name="M:Nez.Transform.SetPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets the position of the transform in world space
            </summary>
            <returns>The position.</returns>
            <param name="position">Position.</param>
        </member>
        <member name="M:Nez.Transform.SetLocalPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets the position of the transform relative to the parent transform. If the transform has no parent, it is the same
            as Transform.position
            </summary>
            <returns>The local position.</returns>
            <param name="localPosition">Local position.</param>
        </member>
        <member name="M:Nez.Transform.SetRotation(System.Single)">
            <summary>
            sets the rotation of the transform in world space in radians
            </summary>
            <returns>The rotation.</returns>
            <param name="radians">Radians.</param>
        </member>
        <member name="M:Nez.Transform.SetRotationDegrees(System.Single)">
            <summary>
            sets the rotation of the transform in world space in degrees
            </summary>
            <returns>The rotation.</returns>
            <param name="radians">Radians.</param>
        </member>
        <member name="M:Nez.Transform.SetLocalRotation(System.Single)">
            <summary>
            sets the the rotation of the transform relative to the parent transform's rotation. If the transform has no parent, it is the
            same as Transform.rotation
            </summary>
            <returns>The local rotation.</returns>
            <param name="radians">Radians.</param>
        </member>
        <member name="M:Nez.Transform.SetLocalRotationDegrees(System.Single)">
            <summary>
            sets the the rotation of the transform relative to the parent transform's rotation. If the transform has no parent, it is the
            same as Transform.rotation
            </summary>
            <returns>The local rotation.</returns>
            <param name="radians">Radians.</param>
        </member>
        <member name="M:Nez.Transform.LookAt(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Rotate so the top of the sprite is facing <see cref="!:pos"/>
            </summary>
            <param name="pos">The position to look at</param>
        </member>
        <member name="M:Nez.Transform.SetScale(Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets the global scale of the transform
            </summary>
            <returns>The scale.</returns>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.Transform.SetScale(System.Single)">
            <summary>
            sets the global scale of the transform
            </summary>
            <returns>The scale.</returns>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.Transform.SetLocalScale(Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets the scale of the transform relative to the parent. If the transform has no parent, it is the same as Transform.scale
            </summary>
            <returns>The local scale.</returns>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.Transform.SetLocalScale(System.Single)">
            <summary>
            sets the scale of the transform relative to the parent. If the transform has no parent, it is the same as Transform.scale
            </summary>
            <returns>The local scale.</returns>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.Transform.RoundPosition">
            <summary>
            rounds the position of the Transform
            </summary>
        </member>
        <member name="M:Nez.Transform.SetDirty(Nez.Transform.DirtyType)">
            <summary>
            sets the dirty flag on the enum and passes it down to our children
            </summary>
            <param name="dirtyFlagType">Dirty flag type.</param>
        </member>
        <member name="P:Nez.Batcher.TransformMatrix">
            <summary>
            Matrix to be used when creating the projection matrix
            </summary>
            <value>The transform matrix.</value>
        </member>
        <member name="F:Nez.Batcher.ShouldRoundDestinations">
            <summary>
            If true, destination positions will be rounded before being drawn.
            </summary>
        </member>
        <member name="F:Nez.Batcher.UseFnaHalfPixelMatrix">
            if true, the older FNA half-pixel offset will be used when creating the ortho matrix. Autoset to true for FNA.
        </member>
        <member name="M:Nez.Batcher.SetIgnoreRoundingDestinations(System.Boolean)">
            <summary>
            sets if position rounding should be ignored. Useful when you are drawing primitives for debugging.
            </summary>
            <param name="shouldIgnore">If set to <c>true</c> should ignore.</param>
        </member>
        <member name="M:Nez.Batcher.DrawRaw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector3[],Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color[])">
            <summary>
            direct access to setting vert positions, UVs and colors. The order of elements is top-left, top-right, bottom-left, bottom-right
            </summary>
            <returns>The raw.</returns>
            <param name="texture">Texture.</param>
            <param name="verts">Verts.</param>
            <param name="textureCoords">Texture coords.</param>
            <param name="colors">Colors.</param>
        </member>
        <member name="M:Nez.Batcher.DrawRaw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector3[],Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color)">
            <summary>
            direct access to setting vert positions, UVs and colors. The order of elements is top-left, top-right, bottom-left, bottom-right
            </summary>
            <returns>The raw.</returns>
            <param name="texture">Texture.</param>
            <param name="verts">Verts.</param>
            <param name="textureCoords">Texture coords.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.Batcher.PushSprite(Microsoft.Xna.Framework.Graphics.Texture2D,System.Nullable{Microsoft.Xna.Framework.Rectangle},System.Single,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Byte,System.Boolean,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            the meat of the Batcher. This is where it all goes down
            </summary>
        </member>
        <member name="M:Nez.Batcher.PushSprite(Nez.Textures.Sprite,System.Single,System.Single,System.Single,System.Single,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Byte,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sprite alternative to the old SpriteBatch pushSprite
            </summary>
        </member>
        <member name="M:Nez.Batcher.EnableScissorTest(System.Boolean)">
            <summary>
            enables/disables scissor testing. If the RasterizerState changes it will cause a batch flush.
            </summary>
            <returns>The scissor test.</returns>
            <param name="shouldEnable">Should enable.</param>
        </member>
        <member name="T:Nez.BatcherDrawingExt">
            <summary>
            an assortment of helper methods to assist with drawing
            </summary>
        </member>
        <member name="M:Nez.BatcherDrawingExt.DrawPoints(Nez.Batcher,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
        </member>
        <member name="M:Nez.BatcherDrawingExt.DrawPoints(Nez.Batcher,Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
        </member>
        <member name="M:Nez.BatcherDrawingExt.DrawPoints(Nez.Batcher,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color,System.Boolean,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
            <param name="closePoly">If set to <c>true</c> the first and last points will be connected.</param>
        </member>
        <member name="T:Nez.GraphicsResource">
            <summary>
            this class exists only so that we can sneak the Batcher through and have it work just like SpriteBatch with regard to resource handling.
            </summary>
        </member>
        <member name="M:Nez.GraphicsResource.Dispose(System.Boolean)">
            <summary>
            The method that derived classes should override to implement disposing of managed and native resources.
            </summary>
            <param name="disposing">True if managed objects should be disposed.</param>
            <remarks>Native resources should always be released regardless of the value of the disposing parameter.</remarks>
        </member>
        <member name="T:Nez.DeferredLighting.DeferredLightingRenderer">
            <summary>
            handles deferred lighting. This Renderer should be ordered after any of your Renderers that render to a RenderTexture. Any renderLayers
            rendered by this Renderer should have Renderables with DeferredSpriteMaterials (or null Material to use the default, diffuse only Material).
            </summary>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredLightingRenderer.WantsToRenderToSceneRenderTarget">
            <summary>
            we do not want to render into the Scene render texture
            </summary>
            <value>true</value>
            <c>false</c>
        </member>
        <member name="F:Nez.DeferredLighting.DeferredLightingRenderer.RenderLayers">
            <summary>
            the renderLayers this Renderer will render
            </summary>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredLightingRenderer.AmbientColor">
            <summary>
            ambient lighting color. Alpha is ignored
            </summary>
            <value>The color of the ambient.</value>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredLightingRenderer.ClearColor">
            <summary>
            clear color for the diffuse portion of the gbuffer
            </summary>
            <value>The color of the clear.</value>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredLightingRenderer.NullNormalMapTexture">
            <summary>
            single pixel texture of a neutral normal map. This will effectively make the object have only diffuse lighting if applied as the normal map.
            </summary>
            <value>The null normal map texture.</value>
        </member>
        <member name="F:Nez.DeferredLighting.DeferredLightingRenderer.EnableDebugBufferRender">
            <summary>
            if true, all stages of the deferred pipeline are rendered after the final combine
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightingRenderer.Render(Nez.Scene)">
            <summary>
            we override render completely here so we can do our thing with multiple render targets
            </summary>
            <param name="scene">scene.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightingRenderer.SetAmbientColor(Microsoft.Xna.Framework.Color)">
            <summary>
            ambient lighting color. Alpha is ignored
            </summary>
            <returns>The ambient color.</returns>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightingRenderer.SetClearColor(Microsoft.Xna.Framework.Color)">
            <summary>
            clear color for the diffuse portion of the gbuffer
            </summary>
            <returns>The clear color.</returns>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredSpriteMaterial.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            DeferredSpriteEffects require a normal map. If you want to forego the normal map and have just diffuse light use the
            DeferredLightingRenderer.nullNormalMapTexture.
            </summary>
            <param name="normalMap">Normal map.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForCamera(Nez.Camera)">
            <summary>
            updates the camera matrixes in the Effect
            </summary>
            <param name="camera">Camera.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForLight(Nez.DeferredLighting.DeferredLight)">
            <summary>
            updates the shader values for the light and sets the appropriate CurrentTechnique
            </summary>
            <param name="light">Light.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForLight(Nez.DeferredLighting.PointLight)">
            <summary>
            updates the shader values for the light and sets the appropriate CurrentTechnique
            </summary>
            <param name="light">Light.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForLight(Nez.DeferredLighting.SpotLight)">
            <summary>
            updates the shader values for the light and sets the appropriate CurrentTechnique
            </summary>
            <param name="light">Light.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForLight(Nez.DeferredLighting.AreaLight)">
            <summary>
            updates the shader values for the light and sets the appropriate CurrentTechnique
            </summary>
            <param name="light">Light.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.UpdateForLight(Nez.DeferredLighting.DirLight)">
            <summary>
            updates the shader values for the light and sets the appropriate CurrentTechnique
            </summary>
            <param name="light">Light.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.SetScreenToWorld(Microsoft.Xna.Framework.Matrix)">
            <summary>
            inverse of Camera.getViewProjectionMatrix
            </summary>
            <param name="screenToWorld">screenToWorld.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.SetSpotLightDirection(Microsoft.Xna.Framework.Vector2)">
            <summary>
            directly sets the light direction
            </summary>
            <param name="lightDirection">Light direction.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.SetSpotLightDirection(System.Single)">
            <summary>
            sets the light direction using just an angle in degrees. 0 degrees points to theright, 90 degrees would be straight down, etc
            </summary>
            <param name="degrees">Degrees.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLightEffect.PrepareForFinalCombine(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.Texture2D)">
            <summary>
            sets the two textures required for the final combine and applies the pass
            </summary>
            <param name="diffuse">Diffuse.</param>
            <param name="lightMap">Light map.</param>
        </member>
        <member name="T:Nez.DeferredLighting.DeferredSpriteEffect">
            <summary>
            effect used to render sprites that take part in deferred lighting. A normal map is required. The normal map can optionally use the alpha
            channel for self illumination by setitng useNormalAlphaChannelForSelfIllumination to true. Note that you need to turn off premultiplied
            alpha in the Pipeline tool when using the alpha for self illumination!
            </summary>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredSpriteEffect.AlphaCutoff">
            <summary>
            alpha cutoff for the alpha test. defaults to 0.3
            </summary>
            <value>The alpha cutoff.</value>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredSpriteEffect.UseNormalAlphaChannelForSelfIllumination">
            <summary>
            if true, the normal map alpha channel will be used for self illumination. Note that you need to turn off premultiplied
            alpha in the Pipeline tool when using the alpha for self illumination!
            </summary>
            <value><c>true</c> if use normal alpha channel for self illumination; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.DeferredLighting.DeferredSpriteEffect.SelfIlluminationPower">
            <summary>
            controls the power of the self illumination where 0 is no contribution and 1 is fully self illuminated
            </summary>
            <value>The self illumination power parameter.</value>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredSpriteEffect.SetAlphaCutoff(System.Single)">
            <summary>
            alpha cutoff for the alpha test. defaults to 0.3
            </summary>
            <returns>The alpha cutoff.</returns>
            <param name="alphaCutoff">Alpha cutoff.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredSpriteEffect.SetUseNormalAlphaChannelForSelfIllumination(System.Boolean)">
            <summary>
            if true, the normal map alpha channel will be used for self illumination. Note that you need to turn off premultiplied
            alpha in the Pipeline tool when using the alpha for self illumination!
            </summary>
            <returns>The use normal alpha channel for self illumination.</returns>
            <param name="useNormalAlphaChannelForSelfIllumination">If set to <c>true</c> use normal alpha channel for self illumination.</param>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredSpriteEffect.SetSelfIlluminationPower(System.Single)">
            <summary>
            controls the power of the self illumination where 0 is no contribution and 1 is fully self illuminated
            </summary>
            <returns>The self illumination power.</returns>
            <param name="selfIlluminationPower">Self illumination power.</param>
        </member>
        <member name="T:Nez.DeferredLighting.PolygonMesh">
            <summary>
            builds a Polygon from the passed in verts. Verts should be relative to 0,0 and contain the outer perimeter of the polygon. A center
            vert will be added and used to triangulate the polygon. If you need a transform matrix for the Polygon set the position/scale and
            then fetch the transformMatrix property.
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.PolygonMesh.CreateSymmetricalPolygon(System.Int32,System.Single)">
            <summary>
            creates a circular polygon
            </summary>
            <returns>The symmetrical polygon.</returns>
            <param name="vertCount">Vert count.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.DeferredLighting.PolygonMesh.CreateSymmetricalPolygon(System.Int32)">
            <summary>
            creates a circular polygon
            </summary>
            <returns>The symmetrical polygon.</returns>
            <param name="vertCount">Vert count.</param>
        </member>
        <member name="T:Nez.DeferredLighting.AreaLight">
            <summary>
            AreaLights work like DirLights except they only affect a specific area specified by the width/height. Note that Transform.scale
            will affect the size of an AreaLight.
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.AreaLight.Direction">
            <summary>
            direction of the light
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.AreaLight.Intensity">
            <summary>
            brightness of the light
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.DeferredLight.Render(Nez.Batcher,Nez.Camera)">
            <summary>
            we dont render lights normally so this method will do nothing and never be called. The DeferredLightingRenderer takes care of
            light rendering so that it can cache and reuse the light meshes.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="camera">Camera.</param>
        </member>
        <member name="T:Nez.DeferredLighting.DirLight">
            <summary>
            directional light with a shortended name to avoid clashes with the XNA DirectionalLight. This light type has only a direction and is
            never culled. It is a global light and the only light that produces specular highlights.
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.DirLight.Direction">
            <summary>
            direction of the light
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.DirLight.SpecularIntensity">
            <summary>
            specular intensity. 0 - 1 range
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.DirLight.SpecularPower">
            <summary>
            specular power. this is the exponent passed to pow() of the projection from 0,0,-1 to the light-to-normal
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.DirLight.DebugRender(Nez.Batcher)">
            <summary>
            we dont want to render our bounds so we just render a direction
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="T:Nez.DeferredLighting.PointLight">
            <summary>
            PointLights radiate light in a circle. Note that PointLights are affected by Transform.scale. The Transform.scale.X value is multiplied
            by the lights radius when sent to the GPU. It is expected that scale will be linear.
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.PointLight.ZPosition">
            <summary>
            "height" above the scene in the z direction
            </summary>
        </member>
        <member name="P:Nez.DeferredLighting.PointLight.Radius">
            <summary>
            how far does this light reaches
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.PointLight.Intensity">
            <summary>
            brightness of the light
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.PointLight.SetRadius(System.Single)">
            <summary>
            how far does this light reach
            </summary>
            <returns>The radius.</returns>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.DeferredLighting.PointLight.SetIntensity(System.Single)">
            <summary>
            brightness of the light
            </summary>
            <returns>The intensity.</returns>
            <param name="intensity">Intensity.</param>
        </member>
        <member name="M:Nez.DeferredLighting.PointLight.DebugRender(Nez.Batcher)">
            <summary>
            renders the bounds only if there is no collider. Always renders a square on the origin.
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="P:Nez.DeferredLighting.SpotLight.Direction">
            <summary>
            wrapper for entity.transform.rotation to ease in setting up direction of spots to point at specific locations
            </summary>
        </member>
        <member name="F:Nez.DeferredLighting.SpotLight.ConeAngle">
            <summary>
            angle in degrees of the cone
            </summary>
        </member>
        <member name="M:Nez.DeferredLighting.SpotLight.SetRadius(System.Single)">
            <summary>
            how far does this light reach
            </summary>
            <returns>The radius.</returns>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.DeferredLighting.SpotLight.SetIntensity(System.Single)">
            <summary>
            brightness of the light
            </summary>
            <returns>The intensity.</returns>
            <param name="intensity">Intensity.</param>
        </member>
        <member name="M:Nez.DeferredLighting.SpotLight.SetDirection(Microsoft.Xna.Framework.Vector2)">
            <summary>
            wrapper for entity.transform.rotation to ease in setting up direction of spots to point at specific locations
            </summary>
            <returns>The direction.</returns>
            <param name="direction">Direction.</param>
        </member>
        <member name="P:Nez.CrosshatchEffect.CrosshatchSize">
            <summary>
            size in pixels of the crosshatch. Should be an even number because the half size is also required. Defaults to 16.
            </summary>
            <value>The size of the cross hatch.</value>
        </member>
        <member name="P:Nez.DissolveEffect.Progress">
            <summary>
            value from 0 - 1 that determines how much the dissolve effect will encompass
            </summary>
            <value>The progress.</value>
        </member>
        <member name="P:Nez.DissolveEffect.DissolveThreshold">
            <summary>
            determines how much area around the current dissolve threshold will be colored with dissolveThresholdColor
            </summary>
            <value>The dissolve threshold.</value>
        </member>
        <member name="P:Nez.DissolveEffect.DissolveThresholdColor">
            <summary>
            the Color that will appear on the threshold of the dissolve effect
            </summary>
            <value>The color of the dissolve threshold.</value>
        </member>
        <member name="P:Nez.DissolveEffect.DissolveTexture">
            <summary>
            the grayscale texture used to determine what is disolved
            </summary>
            <value>The dissolve texture.</value>
        </member>
        <member name="M:Nez.EffectResource.GetEmbeddedResourceBytes(System.String)">
            <summary>
            gets the raw byte[] from an EmbeddedResource
            </summary>
            <returns>The embedded resource bytes.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.EffectResource.GetFileResourceBytes(System.String)">
            <summary>
            fetches the raw byte data of a file from the Content folder. Used to keep the Effect subclass code simple and clean due to the Effect
            constructor requiring the byte[].
            </summary>
            <returns>The file resource bytes.</returns>
            <param name="path">Path.</param>
        </member>
        <member name="T:Nez.GaussianBlurEffect">
            <summary>
            this effect requires that you render it twice. The first time horizontally (prepareForHorizontalBlur) and then
            vertically (prepareForVerticalBlur).
            </summary>
        </member>
        <member name="P:Nez.GaussianBlurEffect.BlurAmount">
            <summary>
            amount to blur. A range of 0.5 - 6 works well. Defaults to 2.
            </summary>
            <value>The blur amount.</value>
        </member>
        <member name="P:Nez.GaussianBlurEffect.HorizontalBlurDelta">
            <summary>
            horizontal delta for the blur. Typically 1 / backbuffer width
            </summary>
            <value>The horizontal blur delta.</value>
        </member>
        <member name="P:Nez.GaussianBlurEffect.VerticalBlurDelta">
            <summary>
            vertical delta for the blur. Typically 1 / backbuffer height
            </summary>
            <value>The vertical blur delta.</value>
        </member>
        <member name="M:Nez.GaussianBlurEffect.PrepareForHorizontalBlur">
            <summary>
            prepares the Effect for performing a horizontal blur
            </summary>
        </member>
        <member name="M:Nez.GaussianBlurEffect.PrepareForVerticalBlur">
            <summary>
            prepares the Effect for performing a vertical blur
            </summary>
        </member>
        <member name="M:Nez.GaussianBlurEffect.SetBlurEffectParameters(System.Single,System.Single,Microsoft.Xna.Framework.Vector2[])">
            <summary>
            computes sample weightings and texture coordinate offsets for one pass of a separable gaussian blur filter.
            </summary>
        </member>
        <member name="M:Nez.GaussianBlurEffect.CalculateSampleWeights">
            <summary>
            calculates the sample weights and passes them along to the shader
            </summary>
        </member>
        <member name="M:Nez.GaussianBlurEffect.ComputeGaussian(System.Single)">
            <summary>
            Evaluates a single point on the gaussian falloff curve.
            Used for setting up the blur filter weightings.
            </summary>
        </member>
        <member name="P:Nez.NoiseEffect.Noise">
            <summary>
            Intensity of the noise. Defaults to 1.
            </summary>
        </member>
        <member name="T:Nez.PaletteCyclerEffect">
            <summary>
            retro palette swap/cycle effect. If cycleSpeed is 0 (the default) this works as a plain old palette swap. It should be used with
            a grayscale texture and a paletteTexture that has a 1 pixel height.
            </summary>
        </member>
        <member name="P:Nez.PaletteCyclerEffect.PaletteTexture">
            <summary>
            palette lookup texture. Should be a 1D texture with a height of 1 pixel
            </summary>
            <value>The palette texture.</value>
        </member>
        <member name="P:Nez.PaletteCyclerEffect.CycleSpeed">
            <summary>
            gets or sets the cycle speed
            </summary>
            <value>The cycle speed.</value>
        </member>
        <member name="M:Nez.PaletteCyclerEffect.UpdateTime">
            <summary>
            updates the _time param of the shader if cycleSpeed != 0
            </summary>
            <returns>The time.</returns>
        </member>
        <member name="P:Nez.ReflectionEffect.ReflectionIntensity">
            <summary>
            0 - 1 range. Intensity of the reflection where 0 is none and 1 is full reflected
            </summary>
            <value>The reflection intensity.</value>
        </member>
        <member name="P:Nez.ReflectionEffect.NormalMagnitude">
            <summary>
            magnitude of the normal map contribution to the UV offset of the sampled RenderTarget. Default is 0.05. Very small numbers work best.
            </summary>
            <value>The normal magnitude.</value>
        </member>
        <member name="P:Nez.ReflectionEffect.NormalMap">
            <summary>
            optional normal map used to displace/refract the UV of the sampled RenderTarget.
            </summary>
            <value>The normal map.</value>
        </member>
        <member name="P:Nez.ReflectionEffect.RenderTexture">
            <summary>
            the render textured used for the reflections
            </summary>
            <value>The render texture.</value>
        </member>
        <member name="P:Nez.SepiaEffect.SepiaTone">
            <summary>
            multiplied by the grayscale value for the final output. Defaults to 1.2f, 1.0f, 0.8f
            </summary>
            <value>The sepia tone.</value>
        </member>
        <member name="P:Nez.SpriteAlphaTestEffect.ReferenceAlpha">
            <summary>
            alpha value used for the comparison. Should be in the 0 - 1 range. Defaults to 0.5f.
            </summary>
            <value>The reference alpha.</value>
        </member>
        <member name="P:Nez.SpriteBlinkEffect.BlinkColor">
            <summary>
            color to blink the sprite. When the blinkColor has an alpha of 1 only the blink color will be shown. An alpha of 0 will result in
            just the sprite being displayed. Any value in between 0 and 1 will interpolate between the two colors.
            </summary>
            <value>The color of the blink.</value>
        </member>
        <member name="T:Nez.SpriteLinesEffect">
            <summary>
            draws the sprite with just vertical or horizonal lines of the specified color. The effect works in screen space.
            </summary>
        </member>
        <member name="P:Nez.SpriteLinesEffect.LineColor">
            <summary>
            color of the lines. Defaults to red.
            </summary>
            <value>The color of the line.</value>
        </member>
        <member name="P:Nez.SpriteLinesEffect.LineSize">
            <summary>
            size of the lines in pixels. Defaults to 5.
            </summary>
            <value>The size of the line.</value>
        </member>
        <member name="P:Nez.SpriteLinesEffect.IsVertical">
            <summary>
            toggles vertical/horizontal lines
            </summary>
            <value><c>true</c> if is vertical; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.SparkleIntensity">
            <summary>
            defaults to 0.015. Waves are calculated by sampling the normal map twice. Any values generated that are sparkleIntensity greater
            than the actual uv value at the place of sampling will be colored sparkleColor.
            </summary>
            <value>The sparkle intensity.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.SparkleColor">
            <summary>
            the color for the sparkly wave peaks
            </summary>
            <value>The color of the sparkle.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.ScreenSpaceVerticalOffset">
            <summary>
            position in screen space of the top of the water plane
            </summary>
            <value>The screen space vertical offset.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.PerspectiveCorrectionIntensity">
            <summary>
            defaults to 0.3. intensity of the perspective correction
            </summary>
            <value>The perspective correction intensity.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.FirstDisplacementSpeed">
            <summary>
            defaults to 2. speed that the first displacment/normal uv is scrolled
            </summary>
            <value>The first displacement speed.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.SecondDisplacementSpeed">
            <summary>
            defaults to 6. speed that the second displacment/normal uv is scrolled
            </summary>
            <value>The second displacement speed.</value>
        </member>
        <member name="P:Nez.WaterReflectionEffect.SecondDisplacementScale">
            <summary>
            defaults to 3. the normal map is sampled twice then combined. The 2nd sampling is scaled by this value.
            </summary>
            <value>The second displacement scale.</value>
        </member>
        <member name="T:Nez.Graphics">
            <summary>
            wrapper class that holds in instance of a Batcher and helpers so that it can be passed around and draw anything.
            </summary>
        </member>
        <member name="F:Nez.Graphics.Batcher">
            <summary>
            All 2D rendering is done through this Batcher instance
            </summary>
        </member>
        <member name="F:Nez.Graphics.BitmapFont">
            <summary>
            default font is loaded up and stored here for easy access. Nez uses it for the DebugConsole
            </summary>
        </member>
        <member name="F:Nez.Graphics.PixelTexture">
            <summary>
            A sprite used to draw rectangles, lines, circles, etc. 
            Will be generated at startup, but you can replace this with a sprite from your atlas to reduce texture swaps.
            Should be a 1x1 white pixel
            </summary>
        </member>
        <member name="M:Nez.Graphics.CreateSingleColorTexture(System.Int32,System.Int32,Microsoft.Xna.Framework.Color)">
            <summary>
            helper method that generates a single color texture of the given dimensions
            </summary>
            <returns>The single color texture.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="color">Color.</param>
        </member>
        <member name="T:Nez.Material`1">
            <summary>
            convenience subclass with a single property that casts the Effect for cleaner configuration
            </summary>
        </member>
        <member name="F:Nez.Material.DefaultMaterial">
            <summary>
            default Material instance
            </summary>
        </member>
        <member name="F:Nez.Material.DefaultOpaqueMaterial">
            <summary>
            default opaque Material used for PostProcessors
            </summary>
        </member>
        <member name="F:Nez.Material.BlendState">
            <summary>
            BlendState used by the Batcher for the current RenderableComponent
            </summary>
        </member>
        <member name="F:Nez.Material.DepthStencilState">
            <summary>
            DepthStencilState used by the Batcher for the current RenderableComponent
            </summary>
        </member>
        <member name="F:Nez.Material.SamplerState">
            <summary>
            SamplerState used by the Batcher for the current RenderableComponent
            </summary>
        </member>
        <member name="F:Nez.Material.Effect">
            <summary>
            Effect used by the Batcher for the current RenderableComponent
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.Material.BlendMultiply2x" -->
        <member name="M:Nez.Material.OnPreRender(Nez.Camera)">
            <summary>
            called when the Material is initialy set right before Batcher.begin to allow any Effects that have parameters set if necessary
            based on the Camera Matrix such as to set the MatrixTransform via camera.viewProjectionMatrix mimicking what Batcher does. This will
            only be called if there is a non-null Effect.
            </summary>
            <param name="camera">Camera.</param>
        </member>
        <member name="M:Nez.Material.CompareTo(Nez.Material)">
            <summary>
            very basic here. We only check if the pointers are the same
            </summary>
            <returns>The to.</returns>
            <param name="other">Other.</param>
        </member>
        <member name="M:Nez.Material.Clone">
            <summary>
            clones the Material. Note that the Effect is not cloned. It is the same instance as the original Material.
            </summary>
        </member>
        <member name="T:Nez.IFinalRenderDelegate">
            <summary>
            optional interface that can be added to any object for special cases where the final render to screen needs to be overridden. Note that
            the Scene.screenshotRequestCallback will not function as expected if an IFinalRenderDelegate is present. This is because the
            screenshot will grab the RenderTarget before the IFinalRenderDelegate does its thing.
            </summary>
        </member>
        <member name="M:Nez.IFinalRenderDelegate.OnAddedToScene(Nez.Scene)">
            <summary>
            called when added to the Scene
            </summary>
            <param name="scene"></param>
        </member>
        <member name="M:Nez.IFinalRenderDelegate.OnSceneBackBufferSizeChanged(System.Int32,System.Int32)">
            <summary>
            called when the back buffer size changes
            </summary>
            <param name="newWidth"></param>
            <param name="newHeight"></param>
        </member>
        <member name="M:Nez.IFinalRenderDelegate.HandleFinalRender(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Graphics.SamplerState)">
            <summary>
            this gets called by a Scene so that the final render can be handled. The render should be done into finalRenderTarget.
            In most cases, finalRenderTarget will be null so the render will just be to the backbuffer. The only time finalRenderTarget
            will be set is the first frame of a SceneTransition where the transition has requested the previous Scene render.
            </summary>
            <param name="finalRenderTarget"></param>
            <param name="letterboxColor"></param>
            <param name="source"></param>
            <param name="finalRenderDestinationRect"></param>
            <param name="samplerState"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.IFinalRenderDelegate.Unload">
            <summary>
            called when a Scene ends. Release any resources here.
            </summary>
        </member>
        <member name="T:Nez.PostProcessor">
            <summary>
            Post Processing step for rendering actions after everthing done.
            </summary>
        </member>
        <member name="F:Nez.PostProcessor.Enabled">
            <summary>
            Step is Enabled or not.
            </summary>
        </member>
        <member name="F:Nez.PostProcessor.ExecutionOrder">
            <summary>
            specifies the order in which the Renderers will be called by the scene
            </summary>
        </member>
        <member name="F:Nez.PostProcessor.Effect">
            <summary>
            The effect used to render with
            </summary>
        </member>
        <member name="F:Nez.PostProcessor.SamplerState">
            <summary>
            SamplerState used for the drawFullscreenQuad method
            </summary>
        </member>
        <member name="F:Nez.PostProcessor.BlendState">
            <summary>
            BlendState used by the drawFullsceenQuad method
            </summary>
        </member>
        <member name="F:Nez.PostProcessor._scene">
            <summary>
            the Scene this PostProcessor is attached to or null
            </summary>
        </member>
        <member name="M:Nez.PostProcessor.OnAddedToScene(Nez.Scene)">
            <summary>
            called when the PostProcessor is added to the Scene. Subclasses must base!
            </summary>
            <param name="scene">Scene.</param>
        </member>
        <member name="M:Nez.PostProcessor.OnSceneBackBufferSizeChanged(System.Int32,System.Int32)">
            <summary>
            called when the default scene RenderTarget is resized. If a PostProcessor is added to a scene before it begins this method will be
            called before the scene first renders. If the scene already started this will be called after onAddedToScene making it an ideal place
            to create any RenderTextures a PostProcessor might require.
            </summary>
            <param name="newWidth">New width.</param>
            <param name="newHeight">New height.</param>
        </member>
        <member name="M:Nez.PostProcessor.Process(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            this is the meat method here. The source passed in contains the full scene with any previous PostProcessors
            rendering. Render it into the destination RenderTarget. The drawFullScreenQuad methods are there to make
            the process even easier. The default implementation renders source into destination with effect.
            
            Note that destination might have a previous render! If your PostProcessor Effect is discarding you should clear
            the destination before writing to it!
            </summary>
            <param name="source">Source.</param>
            <param name="destination">Destination.</param>
        </member>
        <member name="M:Nez.PostProcessor.Unload">
            <summary>
            called when a scene is ended or this PostProcessor is removed. use this for cleanup.
            </summary>
        </member>
        <member name="M:Nez.PostProcessor.DrawFullscreenQuad(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            helper for drawing a texture into a rendertarget, optionally using a custom shader to apply postprocessing effects.
            </summary>
        </member>
        <member name="M:Nez.PostProcessor.DrawFullscreenQuad(Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.Effect)">
            <summary>
            helper for drawing a texture into the current rendertarget, optionally using a custom shader to apply postprocessing effects.
            </summary>
        </member>
        <member name="P:Nez.BloomPostProcessor.Settings">
            <summary>
            the settings used by the bloom and blur shaders. If changed, you must call setBloomSettings for the changes to take effect.
            </summary>
        </member>
        <member name="P:Nez.BloomPostProcessor.RenderTargetScale">
            <summary>
            scale of the internal RenderTargets. For high resolution renders a half sized RT is usually more than enough. Defaults to 1.
            </summary>
        </member>
        <member name="M:Nez.BloomPostProcessor.SetBloomSettings(Nez.BloomSettings)">
            <summary>
            sets the settings used by the bloom and blur shaders
            </summary>
            <param name="settings">Settings.</param>
        </member>
        <member name="M:Nez.BloomPostProcessor.UpdateBlurEffectDeltas">
            <summary>
            updates the Effect with the new vertical and horizontal deltas
            </summary>
        </member>
        <member name="T:Nez.BloomSettings">
            <summary>
            Class holds all the settings used to tweak the bloom effect.
            </summary>
        </member>
        <member name="M:Nez.BloomSettings.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a new bloom settings descriptor.
            </summary>
        </member>
        <member name="F:Nez.BloomSettings.PresetSettings">
            <summary>
            Table of preset bloom settings. Note that BaseSat needs to be near 0 if the final render needs transparency!
            </summary>
        </member>
        <member name="P:Nez.CinematicLetterboxPostProcessor.Color">
            <summary>
            color of the letterbox
            </summary>
            <value>The color.</value>
        </member>
        <member name="P:Nez.CinematicLetterboxPostProcessor.LetterboxSize">
            <summary>
            size in pixels of the letterbox
            </summary>
            <value>The size of the letterbox.</value>
        </member>
        <member name="M:Nez.CinematicLetterboxPostProcessor.AnimateIn(System.Single,System.Single,Nez.Tweens.EaseType)">
            <summary>
            animates the letterbox in
            </summary>
            <returns>The in.</returns>
            <param name="letterboxSize">Letterbox size.</param>
            <param name="duration">Duration.</param>
            <param name="easeType">Ease type.</param>
        </member>
        <member name="M:Nez.CinematicLetterboxPostProcessor.AnimateOut(System.Single,Nez.Tweens.EaseType)">
            <summary>
            animates the letterbox out
            </summary>
            <returns>The out.</returns>
            <param name="duration">Duration.</param>
            <param name="easeType">Ease type.</param>
        </member>
        <member name="P:Nez.GaussianBlurPostProcessor.RenderTargetScale">
            <summary>
            scale of the internal RenderTargets. For high resolution renders a half sized RT is usually more than enough. Defaults to 1.
            </summary>
        </member>
        <member name="M:Nez.GaussianBlurPostProcessor.UpdateEffectDeltas">
            <summary>
            updates the Effect with the new vertical and horizontal deltas
            </summary>
        </member>
        <member name="T:Nez.PixelBloomPostProcessor">
            <summary>
            this PostProcessor expects that the layerRenderTarget is the top-most layer and that it contains 
            </summary>
        </member>
        <member name="T:Nez.PixelGlitchPostProcessor">
            <summary>
            glitch effect where the screen is divided into rows verticalSize high. Each row is shifted horizonalAmount left or right. It is best used
            by changing horizontalOffset every few frames for a second then going back to normal.
            </summary>
        </member>
        <member name="P:Nez.PixelGlitchPostProcessor.VerticalSize">
            <summary>
            vertical size in pixels or each row. default 5.0
            </summary>
            <value>The size of the vertical.</value>
        </member>
        <member name="P:Nez.PixelGlitchPostProcessor.HorizontalOffset">
            <summary>
            horizontal shift in pixels. default 10.0
            </summary>
            <value>The horizontal offset.</value>
        </member>
        <member name="T:Nez.PixelMosaicRenderDelegate">
            <summary>
            overlays a mosaic on top of the final render. Useful only for pixel perfect pixel art.
            </summary>
        </member>
        <member name="T:Nez.PolyLightPostProcessor">
            <summary>
            post processor to assist with making blended poly lights. Usage is as follows:
            - render all sprite lights with a separate Renderer to a RenderTarget. The clear color of the Renderer is your ambient light color.
            - render all normal objects in standard fashion
            - add this PostProcessor with the RenderTarget from your lights Renderer
            </summary>
        </member>
        <member name="P:Nez.PolyLightPostProcessor.MultiplicativeFactor">
            <summary>
            multiplicative factor for the blend of the base and light render targets. Defaults to 1.
            </summary>
            <value>The multiplicative factor.</value>
        </member>
        <member name="P:Nez.PolyLightPostProcessor.EnableBlur">
            <summary>
            enables/disables a gaussian blur of the light texture before it is combined with the scene render
            </summary>
            <value><c>true</c> if enable blur; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.PolyLightPostProcessor.BlurRenderTargetScale">
            <summary>
            scale of the internal RenderTargets used for the blur. For high resolution renders a half sized RT is usually more than enough.
            Defaults to 0.5.
            </summary>
        </member>
        <member name="P:Nez.PolyLightPostProcessor.BlurAmount">
            <summary>
            amount to blur. A range of 0.5 - 6 works well. Defaults to 2.
            </summary>
            <value>The blur amount.</value>
        </member>
        <member name="M:Nez.PolyLightPostProcessor.UpdateBlurEffectDeltas">
            <summary>
            updates the GaussianBlurEffect with the new vertical and horizontal deltas after a back buffer size or blurRenderTargetScale change
            </summary>
        </member>
        <member name="T:Nez.SpriteLightPostProcessor">
            <summary>
            post processor to assist with making blended sprite lights. Usage is as follows:
            - render all sprite lights with a separate Renderer to a RenderTarget. The clear color of the Renderer is your ambient light color.
            - render all normal objects in standard fashion
            - add this PostProcessor with the RenderTarget from your lights Renderer
            </summary>
        </member>
        <member name="P:Nez.SpriteLightPostProcessor.MultiplicativeFactor">
            <summary>
            multiplicative factor for the blend of the base and light render targets. Defaults to 1.
            </summary>
            <value>The multiplicative factor.</value>
        </member>
        <member name="T:Nez.PostProcessor`1">
            <summary>
            helper subclass for strongly typed Effects loaded from EffectResource. The effect will automatically be unloaded when the scene
            completes.
            </summary>
        </member>
        <member name="F:Nez.PostProcessor`1.Effect">
            <summary>
            The effect used to render the scene with
            </summary>
        </member>
        <member name="M:Nez.PostProcessor`1.Process(Microsoft.Xna.Framework.Graphics.RenderTarget2D,Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            we have to override the default implementation here because we use a custom Effect subclass that differes from the effect
            field of the base class
            will be null.
            </summary>
            <param name="source">Source.</param>
            <param name="destination">Destination.</param>
        </member>
        <member name="T:Nez.PrimitiveBatch">
            <summary>
            batcher that draws vertex colored triangles
            </summary>
        </member>
        <member name="M:Nez.PrimitiveBatch.Begin">
            <summary>
            draws directly in screen space at full viewport size
            </summary>
        </member>
        <member name="M:Nez.PrimitiveBatch.Begin(Microsoft.Xna.Framework.Matrix@,Microsoft.Xna.Framework.Matrix@)">
            <summary>
            Begin is called to tell the PrimitiveBatch what kind of primitives will be drawn, and to prepare the graphics card to render those primitives.
            Use camera.projectionMatrix and camera.transformMatrix if the batch should be in camera space.
            </summary>
            <param name="projection">The projection.</param>
            <param name="view">The view.</param>
        </member>
        <member name="M:Nez.PrimitiveBatch.Begin(Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Matrix)">
            <summary>
            Begin is called to tell the PrimitiveBatch what kind of primitives will be drawn, and to prepare the graphics card to render those primitives.
            Use camera.projectionMatrix and camera.transformMatrix if the batch should be in camera space.
            </summary>
            <param name="projection">The projection.</param>
            <param name="view">The view.</param>
        </member>
        <member name="M:Nez.PrimitiveBatch.End">
            <summary>
            End is called once all the primitives have been drawn using AddVertex.
            it will call Flush to actually submit the draw call to the graphics card, and
            then tell the basic effect to end.
            </summary>
        </member>
        <member name="M:Nez.DefaultRenderer.#ctor(System.Int32,Nez.Camera)">
            <summary>
            renders all renderLayers
            </summary>
            <param name="renderOrder">Render order.</param>
            <param name="camera">Camera.</param>
        </member>
        <member name="T:Nez.ReflectionMaterial">
            <summary>
            used in conjunction with the ReflectionRenderer
            </summary>
        </member>
        <member name="T:Nez.ReflectionRenderer">
            <summary>
            assists in creating a mirror effect. To use the ReflectionRenderer do the following:
            - call createAndSetupScene being sure to pass in a renderOrder BEFORE the renderer that contains your reflective surface.
            - reflectableObjectRenderLayers should contain all the renderLayers that contain objects that you want reflected
            - create a ReflectionMaterial which you will use to render your reflective surfaces. Note that your reflective
                surfaces should NOT be rendered by the ReflectionRenderer! It needs to create a RenderTexture with just the objects to reflect.
            - you can optionally set a normal map on the ReflectionEffect for a refraction effect
            - move the ReflectionRenderer.camera around to get the desired offset for your reflections. You can also change the zoom of the Camera.
            </summary>
        </member>
        <member name="T:Nez.WaterReflectionMaterial">
            <summary>
            used by the WaterReflectionPlane
            </summary>
        </member>
        <member name="F:Nez.WaterReflectionMaterial._renderTarget">
            <summary>
            we store a reference to the RenderTarget so we can update the Effect when it changes
            </summary>
        </member>
        <member name="F:Nez.WaterReflectionMaterial._renderTargetBinding">
            <summary>
            cache the array so we dont have to recreate it every frame
            </summary>
        </member>
        <member name="T:Nez.Renderer">
             <summary>
             Renderers are added to a Scene and handle all of the actual calls to RenderableComponent.render and Entity.debugRender.
             A simple Renderer could just start the Batcher.instanceGraphics.batcher or it could create its own local Batcher instance
             if it needs it for some kind of custom rendering.
            
             Note that it is a best practice to ensure all Renderers that render to a RenderTarget have lower renderOrders to avoid issues
             with clearing the back buffer (http://gamedev.stackexchange.com/questions/90396/monogame-setrendertarget-is-wiping-the-backbuffer).
             Giving them a negative renderOrder is a good strategy to deal with this.
             </summary>
        </member>
        <member name="F:Nez.Renderer.Material">
            <summary>
            Material used by the Batcher. Any RenderableComponent can override this.
            </summary>
        </member>
        <member name="F:Nez.Renderer.Camera">
            <summary>
            the Camera this renderer uses for rendering (really its transformMatrix and bounds for culling). This is a convenience field and isnt
            required. Renderer subclasses can pick the camera used when calling beginRender.
            </summary>
        </member>
        <member name="F:Nez.Renderer.RenderOrder">
            <summary>
            specifies the order in which the Renderers will be called by the scene
            </summary>
        </member>
        <member name="F:Nez.Renderer.RenderTexture">
            <summary>
            if renderTarget is not null this renderer will render into the RenderTarget instead of to the screen
            </summary>
        </member>
        <member name="F:Nez.Renderer.RenderTargetClearColor">
            <summary>
            if renderTarget is not null this Color will be used to clear the screen
            </summary>
        </member>
        <member name="F:Nez.Renderer.ShouldDebugRender">
            <summary>
            flag for this renderer that decides if it should debug render or not. The render method receives a bool (debugRenderEnabled)
            letting the renderer know if the global debug rendering is on/off. The renderer then uses the local bool to decide if it
            should debug render or not.
            </summary>
        </member>
        <member name="P:Nez.Renderer.WantsToRenderToSceneRenderTarget">
            <summary>
            if true, the Scene will call SetRenderTarget with the scene RenderTarget. The default implementaiton returns true if the Renderer
            has a renderTexture
            </summary>
            <value><c>true</c> if wants to render to scene render target; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Nez.Renderer.WantsToRenderAfterPostProcessors">
            <summary>
            if true, the Scene will call the render method AFTER all PostProcessors have finished. This must be set to true BEFORE calling
            Scene.addRenderer to take effect and the Renderer should NOT have a renderTexture. The main reason for this type of Renderer
            is so that you can render your UI without post processing on top of the rest of your Scene. The ScreenSpaceRenderer is an
            example Renderer that sets this to true;
            </summary>
        </member>
        <member name="F:Nez.Renderer._currentMaterial">
            <summary>
            holds the current Material of the last rendered Renderable (or the Renderer.material if no changes were made)
            </summary>
        </member>
        <member name="F:Nez.Renderer.Scene">
            <summary>
            the scene this Renderer is attached to
            </summary>
        </member>
        <member name="M:Nez.Renderer.OnAddedToScene(Nez.Scene)">
            <summary>
            called when the Renderer is added to the Scene
            </summary>
            <param name="scene">Scene.</param>
        </member>
        <member name="M:Nez.Renderer.Unload">
            <summary>
            called when a scene is ended or this Renderer is removed from the Scene. use this for cleanup.
            </summary>
        </member>
        <member name="M:Nez.Renderer.BeginRender(Nez.Camera)">
            <summary>
            if a RenderTarget is used this will set it up. The Batcher is also started. The passed in Camera will be used to set the ViewPort
            (if a ViewportAdapter is present) and for the Batcher transform Matrix.
            </summary>
            <param name="cam">Cam.</param>
        </member>
        <member name="M:Nez.Renderer.RenderAfterStateCheck(Nez.IRenderable,Nez.Camera)">
            <summary>
            renders the RenderableComponent flushing the Batcher and resetting current material if necessary
            </summary>
            <param name="renderable">Renderable.</param>
            <param name="cam">Cam.</param>
        </member>
        <member name="M:Nez.Renderer.FlushBatch(Nez.Camera)">
            <summary>
            force flushes the Batcher by calling End then Begin on it.
            </summary>
        </member>
        <member name="M:Nez.Renderer.EndRender">
            <summary>
            ends the Batcher and clears the RenderTarget if it had a RenderTarget
            </summary>
        </member>
        <member name="M:Nez.Renderer.DebugRender(Nez.Scene,Nez.Camera)">
            <summary>
            default debugRender method just loops through all entities and calls entity.debugRender. Note that you are in the middle of a batch
            at this point so you may want to call Batcher.End and Batcher.begin to clear out any Materials and items awaiting rendering.
            </summary>
            <param name="scene">Scene.</param>
        </member>
        <member name="M:Nez.Renderer.OnSceneBackBufferSizeChanged(System.Int32,System.Int32)">
            <summary>
            called when the default scene RenderTarget is resized and when adding a Renderer if the scene has already began. default implementation
            calls through to RenderTexture.onSceneBackBufferSizeChanged
            so that it can size itself appropriately if necessary.
            </summary>
            <param name="newWidth">New width.</param>
            <param name="newHeight">New height.</param>
        </member>
        <member name="T:Nez.RenderLayerExcludeRenderer">
            <summary>
            Renderer that only renders all but one renderLayer. Useful to keep UI rendering separate from the rest of the game when used in conjunction
            with a RenderLayerRenderer. Note that UI would most likely want to be rendered in screen space so the camera matrix shouldn't be passed to
            Batcher.Begin.
            </summary>
        </member>
        <member name="T:Nez.RenderLayerRenderer">
            <summary>
            Renderer that only renders the specified renderLayers. Useful to keep UI rendering separate from the rest of the game when used in conjunction
            with other RenderLayerRenderers rendering different renderLayers.
            </summary>
        </member>
        <member name="F:Nez.RenderLayerRenderer.RenderLayers">
            <summary>
            the renderLayers this Renderer will render
            </summary>
        </member>
        <member name="T:Nez.ScreenSpaceRenderer">
            <summary>
            Renderer that renders using its own Camera which doesnt move.
            </summary>
        </member>
        <member name="T:Nez.StencilLightRenderer">
            <summary>
            StencilLightRenderer is used for 2d lights and shadows. This works by taking each light and doing the following:
            - clear the stencil buffer
            - project from the light position to create the shadow projection of the light
            - render the shadow project only to the stencil buffer writing a 1 for each touched pixel
            - render the lights additively only where the stencil is 0 (where the shadow projection did not hit)
            
            Setup:
            - add the StencilLightRenderer and have it render before other renderers
            - add all your StencilLights or textured lights to the StencilLightRenderer RenderLayer
            - you will then have access to StencilLightRenderer.RenderTexture which will contain your lightmap. You can then render it whenever you want
            	either via a normal SpriteRenderer with multiplicative blending or via a PostProcessor
            </summary>
        </member>
        <member name="F:Nez.StencilLightRenderer.RenderLayer">
            <summary>
            the layer we will use for our lights
            </summary>
        </member>
        <member name="F:Nez.StencilLightRenderer.CollidesWithLayers">
            <summary>
            layer mask of all the layers this light should interact with. defaults to all layers.
            </summary>
        </member>
        <member name="T:Nez.ScissorStack">
            <summary>
            A stack of Rectangle objects to be used for clipping via GraphicsDevice.ScissorRectangle. When a new
            Rectangle is pushed onto the stack, it will be merged with the current top of stack.The minimum area of overlap is then set as
            the real top of the stack.
            </summary>
        </member>
        <member name="M:Nez.ScissorStack.PopScissors">
            <summary>
            Pops the current scissor rectangle from the stack and sets the new scissor area to the new top of stack rectangle.
            Any drawing should be flushed before popping scissors.
            </summary>
            <returns>The scissors.</returns>
        </member>
        <member name="M:Nez.ScissorStack.CalculateScissors(Nez.Camera,Microsoft.Xna.Framework.Matrix,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Calculates a screen space scissor rectangle using the given Camera. If the Camera is null than the scissor will
            be calculated only with the batchTransform
            </summary>
            <returns>The scissors.</returns>
            <param name="camera">Camera.</param>
            <param name="batchTransform">Batch transform.</param>
            <param name="scissor">Area.</param>
        </member>
        <member name="M:Nez.ScissorStack.CalculateScissors(Nez.Camera,Nez.Matrix2D,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Calculates a screen space scissor rectangle using the given Camera. If the Camera is null than the scissor will
            be calculated only with the batchTransform
            </summary>
            <returns>The scissors.</returns>
            <param name="camera">Camera.</param>
            <param name="batchTransform">Batch transform.</param>
            <param name="scissor">Area.</param>
        </member>
        <member name="T:Nez.Svg.FauxGraphicsPath">
            <summary>
            THIS IS A HORRIBLE ABOMINATION! PCLs dont have access to System.Drawing so this class is a wrapper for accessing the GraphicsPath class.
            It has the full public API that Nez needs for SVG files but the whole mess is all accessed via reflection. It is slow as all hell and not
            recommended for production use. It's only purpose is so that Nez works with SVG files out of the box to get up and running fast.
            </summary>
        </member>
        <member name="T:Nez.Svg.ISvgPathBuilder">
            <summary>
            dummy interface used by SvgPath.getTransformedDrawingPoints to workaround PCL not having System.Drawing
            </summary>
        </member>
        <member name="T:Nez.Svg.SvgPath">
            <summary>
            representation of a path element. Note that the best way to get points from the path is to use the getTransformedPoints method. It uses
            System.Drawing to generate the path points from any type of path. The getOptimized*DrawingPoints methods only work for cubic bezier
            curves.
            
            SvgPath can be instantiated directly. You can then just set the 'd' property to have the path parsed.
            </summary>
        </member>
        <member name="M:Nez.Svg.SvgPath.GetTransformedDrawingPoints(Nez.Svg.ISvgPathBuilder,System.Single)">
            <summary>
            gets the points that make up the path with any transforms present applied. The points can be used to approximate the path by
            drawing lines between them.
            
            Important notes: ISvgPathBuilder is a faux interface that is required because PCLs cannot access System.Drawing which is used
            to get the drawing points. In order to use this method you need to put the SvgPathBuilder in your main project and then pass in
            an SvgPathBuilder object to this method.
            </summary>
            <returns>The transformed drawing points.</returns>
            <param name="pathBuilder">Path builder.</param>
            <param name="flatness">Flatness.</param>
        </member>
        <member name="M:Nez.Svg.SvgPath.IsPathCubicBezier">
            <summary>
            returns true if all the segments are cubic curves
            </summary>
            <returns><c>true</c>, if path bezier was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Svg.SvgPath.GetBezierSplineForPath">
            <summary>
            gets a BezierSpline for the SvgPath
            </summary>
            <returns>The bezier spline for path.</returns>
        </member>
        <member name="M:Nez.Svg.SvgPath.GetOptimizedDrawingPoints(System.Single)">
            <summary>
            gets optimized drawing points with extra points in curves and less in straight lines. Returns a pooled list that should be returned to the ListPool when done.
            </summary>
            <returns>The optimized drawing points.</returns>
            <param name="distanceTolerance">Distance tolerance.</param>
        </member>
        <member name="M:Nez.Svg.SvgPath.GetOptimizedTransformedDrawingPoints(System.Single)">
            <summary>
            gets optimized drawing points with extra points in curves and less in straight lines with any transforms present applied
            </summary>
            <returns>The optimized drawing points.</returns>
            <param name="distanceTolerance">Distance tolerance.</param>
        </member>
        <member name="M:Nez.Svg.SvgPathParser.Parse(System.String)">
            <summary>
            parses the 'd' element of an SVG file and returns the command series
            </summary>
            <param name="path">Path.</param>
        </member>
        <member name="M:Nez.Svg.SvgPathParser.CreatePathSegment(System.Char,System.Collections.Generic.List{Nez.Svg.SvgPathSegment},System.Single[],System.Boolean)">
            <summary>
            creates an SvgPathSegment based on the command and coords passed in
            </summary>
            <param name="command">Command.</param>
            <param name="segments">Segments.</param>
            <param name="coords">Coords.</param>
            <param name="isRelative">If set to <c>true</c> is relative.</param>
        </member>
        <member name="M:Nez.Svg.SvgPathParser.ToAbsolute(System.Single,System.Single,System.Collections.Generic.List{Nez.Svg.SvgPathSegment},System.Boolean)">
            <summary>
            Creates point with absolute coordinates
            </summary>
            <returns>The absolute.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="segments">Segments.</param>
            <param name="areBothRelative">If set to <c>true</c> is relative both.</param>
        </member>
        <member name="M:Nez.Svg.SvgPathParser.ToAbsolute(System.Single,System.Single,System.Collections.Generic.List{Nez.Svg.SvgPathSegment},System.Boolean,System.Boolean)">
            <summary>
            Creates point with absolute coordinates
            </summary>
            <param name="x">Raw X-coordinate value.</param>
            <param name="y">Raw Y-coordinate value.</param>
            <param name="segments">Current path segments.</param>
            <param name="isRelativeX"><b>true</b> if <paramref name="x"/> contains relative coordinate value, otherwise <b>false</b>.</param>
            <param name="isRelativeY"><b>true</b> if <paramref name="y"/> contains relative coordinate value, otherwise <b>false</b>.</param>
            <returns><see cref="T:Microsoft.Xna.Framework.Vector2"/> that contains absolute coordinates.</returns>
        </member>
        <member name="T:Nez.Svg.SvgPathSegment">
            <summary>
            base class for all of the different SVG path types. Note that arcs are not supported at this time.
            </summary>
        </member>
        <member name="T:Nez.Svg.SvgReflectionPathBuilder">
            <summary>
            helper class used to parse paths and also fetch the drawing points from a series of SvgPathSegments. This is an insanely slow way
            to build paths since it is stuck using reflection for everything. It is highly recommended that you use the SvgPathBuilder class
            instead, which must be manually placed in your project.
            </summary>
        </member>
        <member name="M:Nez.Svg.SvgReflectionPathBuilder.ToDrawPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            helper to convert a Vector2 into a Point
            </summary>
            <returns>The draw point.</returns>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Svg.SvgReflectionPathBuilder.GetDrawingPoints(System.Collections.Generic.List{Nez.Svg.SvgPathSegment},System.Single)">
            <summary>
            takes in a parsed path and returns a list of points that can be used to draw the path
            </summary>
            <returns>The drawing points.</returns>
            <param name="segments">Segments.</param>
        </member>
        <member name="T:Nez.Svg.SvgImage">
            <summary>
            represents the image tag in an SVG document. This class will do its best to load the image from the href attribute. It will check for
            embedded images, web-based images and then fall back to using the href to load from a ContentManager.
            </summary>
        </member>
        <member name="P:Nez.Svg.SvgImage.Rect">
            <summary>
            the rect encompassing this image. Note that the rect is with no transforms applied.
            </summary>
            <value>The rect.</value>
        </member>
        <member name="F:Nez.Svg.SvgImage._didAttemptTextureLoad">
            <summary>
            flag that determines if we tried to load the texture. We only attempt to load it once.
            </summary>
        </member>
        <member name="F:Nez.Svg.SvgImage._texture">
            <summary>
            cached texture if loaded successfully
            </summary>
        </member>
        <member name="M:Nez.Svg.SvgImage.GetTexture(Nez.Systems.NezContentManager)">
            <summary>
            attempts to get a texture for the image
            - first it will check the href for a png file name. If it finds one it will load it with the ContentManager passed in
            - next it will see if the href is a url and if so it will load it
            - next it checks for an embedded, base64 image. It will load that if it finds one
            </summary>
            <returns>The texture.</returns>
            <param name="content">Content.</param>
        </member>
        <member name="M:Nez.Svg.SvgPolygon.GetRelativePoints">
            <summary>
            gets the points relative to the center. SVG by default uses absolute positions for points.
            </summary>
            <returns>The relative points.</returns>
        </member>
        <member name="M:Nez.Svg.SvgRectangle.GetTransformedPoints">
            <summary>
            gets the points for the rectangle with all transforms applied
            </summary>
            <returns>The transformed points.</returns>
        </member>
        <member name="T:Nez.Svg.SvgDebugComponent">
            <summary>
            assists in debugging the data from an SVG file. All the supported shapes will be displayed.
            </summary>
        </member>
        <member name="M:Nez.Svg.SvgDebugComponent.#ctor(System.String,Nez.Svg.ISvgPathBuilder)">
            <summary>
            beware! If pathBuilder is null the SvgReflectionPathBuilder will be used and it is slow as dirt.
            </summary>
            <param name="pathToSvgFile">Path to svg file relative to the Content folder</param>
            <param name="pathBuilder">Path builder.</param>
        </member>
        <member name="M:Nez.Svg.SvgDebugComponent.RenderImages(Nez.Batcher,Nez.Svg.SvgImage[])">
            <summary>
            attempts to load and draw the SvgImage. If it cannot load a Texture it will just draw a rect.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="images">Images.</param>
        </member>
        <member name="T:Nez.Svg.SvgDocument">
            <summary>
            handles parsing out groups, paths, rects, lines, circles, ellipses, polygons, polylines and images. This is just a small subset of the SVG
            spec! Only the basics are parsed out since this is not designed to be an image viewer.
            </summary>
        </member>
        <member name="T:Nez.Svg.SvgElement">
            <summary>
            base class for all SVG elements. Has some helpers for parsing colors and dealing with transforms.
            </summary>
        </member>
        <member name="P:Nez.Svg.SvgElement.RotationDegrees">
            <summary>
            helper property that just loops through all the transforms and if there is an SvgRotate transform it will return that angle
            </summary>
            <value>The rotation degrees.</value>
        </member>
        <member name="T:Nez.Svg.SvgGroup">
            <summary>
            container in SVG. The 'g' XML tag.
            </summary>
        </member>
        <member name="T:Nez.Svg.SvgTransformConverter">
            <summary>
            helpers for converting the transform string into SvgTransform objects
            </summary>
        </member>
        <member name="M:Nez.Textures.GaussianBlur.CreateBlurredTexture(Microsoft.Xna.Framework.Graphics.Texture2D,System.Double)">
            <summary>
            creates a new texture that is a gaussian blurred version of the original
            </summary>
            <returns>The blurred texture.</returns>
            <param name="image">Image.</param>
            <param name="deviation">Deviation.</param>
        </member>
        <member name="M:Nez.Textures.GaussianBlur.CreateBlurredGrayscaleTexture(Microsoft.Xna.Framework.Graphics.Texture2D,System.Double)">
            <summary>
            creates a new texture that is a gaussian blurred version of the original in grayscale
            </summary>
            <returns>The blurred texture.</returns>
            <param name="image">Image.</param>
            <param name="deviation">Deviation.</param>
        </member>
        <member name="F:Nez.Textures.NinePatchSprite.HasPadding">
            <summary>
            used to indicate if this nine patch has additional padding information
            </summary>
        </member>
        <member name="T:Nez.Textures.RenderTarget.TrackedRenderTarget2D">
            <summary>
            internal class with additional lastFrameUsed field for managing temporary RenderTargets
            </summary>
        </member>
        <member name="F:Nez.Textures.RenderTarget.instance">
            <summary>
            facilitates exposing a static API for easy access
            </summary>
        </member>
        <member name="M:Nez.Textures.RenderTarget.GetTemporary(System.Int32,System.Int32)">
            <summary>
            gets a temporary RenderTarget2D from the pool. When done using it call releaseTemporary to put it back in the pool. Note that the
            contents of the RenderTarget2D could be anything at all so clear it if you need to before using it.
            </summary>
            <returns>The temporary.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.GetTemporary(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            gets a temporary RenderTarget2D from the pool. When done using it call releaseTemporary to put it back in the pool. Note that the
            contents of the RenderTarget2D could be anything at all so clear it if you need to before using it.
            </summary>
            <returns>The temporary.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="depthFormat">Depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.ReleaseTemporary(Microsoft.Xna.Framework.Graphics.RenderTarget2D)">
            <summary>
            puts a temporary RenderTarget2D back in the pool. Do not attempt to put RenderTarget2Ds in the pool that were not acquired via getTemporary.
            </summary>
            <param name="renderTarget">Render target.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.Create">
            <summary>
            helper for creating a full screen RenderTarget2D
            </summary>
        </member>
        <member name="M:Nez.Textures.RenderTarget.Create(Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a full screen RenderTarget2D with a specific DepthFormat
            </summary>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.Create(System.Int32,System.Int32)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.Create(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTarget.Create(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="preferredFormat">Preferred format.</param>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="T:Nez.Textures.RenderTexture">
            <summary>
            wrapper for a RenderTarget2D that optionally takes care of resizing itself automatcially when the screen size changes
            </summary>
        </member>
        <member name="T:Nez.Textures.RenderTexture.RenderTextureResizeBehavior">
            <summary>
            handles what should happen when onSceneBackBufferSizeChanged. Defaults to SizeToSceneRenderTarget
            </summary>
        </member>
        <member name="F:Nez.Textures.RenderTexture.RenderTarget">
            <summary>
            the RenderTarget2D this RenderTexture manages
            </summary>
        </member>
        <member name="F:Nez.Textures.RenderTexture.ResizeBehavior">
            <summary>
            resize behavior that should occur when onSceneBackBufferSizeChanged is called
            </summary>
        </member>
        <member name="M:Nez.Textures.RenderTexture.#ctor">
            <summary>
            helper for creating a full screen RenderTarget2D
            </summary>
        </member>
        <member name="M:Nez.Textures.RenderTexture.#ctor(Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a full screen RenderTarget2D with a specific DepthFormat
            </summary>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTexture.#ctor(System.Int32,System.Int32)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.Textures.RenderTexture.#ctor(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTexture.#ctor(System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Microsoft.Xna.Framework.Graphics.DepthFormat)">
            <summary>
            helper for creating a RenderTarget2D
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="preferredFormat">Preferred format.</param>
            <param name="preferredDepthFormat">Preferred depth format.</param>
        </member>
        <member name="M:Nez.Textures.RenderTexture.OnSceneBackBufferSizeChanged(System.Int32,System.Int32)">
            <summary>
            called by Renderers automatically when appropriate. Lets the resizeBehavior kick in so auto resizing can occur
            </summary>
            <param name="newWidth">New width.</param>
            <param name="newHeight">New height.</param>
        </member>
        <member name="M:Nez.Textures.RenderTexture.ResizeToFitBackbuffer">
            <summary>
            resizes the RenderTarget2D to match the back buffer size
            </summary>
        </member>
        <member name="M:Nez.Textures.RenderTexture.Resize(System.Int32,System.Int32)">
            <summary>
            resizes the RenderTarget2D to the specified size
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="T:Nez.Textures.Sprite">
            <summary>
            represents a single element in a texture atlas consisting of a texture and the source rectangle for the frame
            </summary>
        </member>
        <member name="F:Nez.Textures.Sprite.Texture2D">
            <summary>
            the actual Texture2D
            </summary>
        </member>
        <member name="F:Nez.Textures.Sprite.SourceRect">
            <summary>
            rectangle in the Texture2D for this element
            </summary>
        </member>
        <member name="F:Nez.Textures.Sprite.Uvs">
            <summary>
            UVs for the texture region
            </summary>
        </member>
        <member name="F:Nez.Textures.Sprite.Center">
            <summary>
            center of the sourceRect if it had a 0,0 origin. This is basically the center in sourceRect-space.
            </summary>
            <value>The center.</value>
        </member>
        <member name="F:Nez.Textures.Sprite.Origin">
            <summary>
            the origin that a RenderableComponent should use when using this Sprite. Defaults to the center.
            </summary>
        </member>
        <member name="M:Nez.Textures.Sprite.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            convenience constructor that casts floats to ints for the sourceRect
            </summary>
            <param name="texture">Texture.</param>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.Textures.Sprite.GenerateNinePatchRects(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            generates nine patch Rectangles. destArray should have 9 elements. renderRect is the final area in which the nine patch will be rendered.
            To just get the source rects for rendering pass in the Sprite.sourceRect. Pass in a larger Rectangle to get final destination
            rendering Rectangles.
            </summary>
            <param name="renderRect">Render rect.</param>
            <param name="destArray">Destination array.</param>
            <param name="marginTop">Margin top.</param>
            <param name="marginBottom">Margin bottom.</param>
            <param name="marginLeft">Margin left.</param>
            <param name="marginRight">Margin right.</param>
        </member>
        <member name="M:Nez.Textures.Sprite.Clone">
            <summary>
            clones the Sprite
            </summary>
        </member>
        <member name="M:Nez.Textures.Sprite.SpritesFromAtlas(Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            provides a List of Sprites given an atlas with equally spaced rows/columns of sprites
            </summary>
            <returns>The from atlas.</returns>
            <param name="texture">Texture.</param>
            <param name="cellWidth">Cell width.</param>
            <param name="cellHeight">Cell height.</param>
            <param name="cellOffset">the first cell to include while processing. 0 based indexing.</param>
            <param name="maxCellsToInclude">Max cells to included.</param>
        </member>
        <member name="T:Nez.Textures.TextureUtils">
            <summary>
            various utilties for creating textures on the fly. These can be pretty heavy on the CPU so it's best to not try to use them every frame.
            </summary>
        </member>
        <member name="M:Nez.Textures.TextureUtils.TextureFromStreamPreMultiplied(System.IO.Stream)">
            <summary>
            loads a Texture2D and premultiplies the alpha
            </summary>
        </member>
        <member name="M:Nez.Textures.TextureUtils.CreateFlatHeightmap(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color)">
            <summary>
            processes each pixel of the passed in Texture and in the output texture transparent pixels will be transparentColor and opaque pixels
            will be opaqueColor. This is useful for creating normal maps for rim lighting by applying a grayscale blur then using createNormalMap*
            by doing something like the following. The first step is used only for making rim lighting normal maps:
            - var maskTex = createFlatHeightmap( tex, Color.White, Color.Black )
            - var blurredTex = createBlurredGrayscaleTexture( maskTex, 1 )
            - createNormalMap( blurredTex, 50f )
            </summary>
            <returns>The flat heightmap.</returns>
            <param name="image">Image.</param>
            <param name="opaqueColor">Opaque color.</param>
            <param name="transparentColor">Transparent color.</param>
        </member>
        <member name="M:Nez.Textures.TextureUtils.CreateBlurredGrayscaleTexture(Microsoft.Xna.Framework.Graphics.Texture2D,System.Double)">
            <summary>
            creates a new texture that is a gaussian blurred version of the original in grayscale
            </summary>
            <returns>The blurred texture.</returns>
            <param name="image">Image.</param>
            <param name="deviation">Deviation.</param>
        </member>
        <member name="M:Nez.Textures.TextureUtils.CreateBlurredTexture(Microsoft.Xna.Framework.Graphics.Texture2D,System.Double)">
            <summary>
            creates a new texture that is a gaussian blurred version of the original
            </summary>
            <returns>The blurred texture.</returns>
            <param name="image">Image.</param>
            <param name="deviation">Deviation.</param>
        </member>
        <member name="M:Nez.Textures.TextureUtils.CreateNormalMap(Microsoft.Xna.Framework.Graphics.Texture2D,Nez.Textures.TextureUtils.EdgeDetectionFilter,System.Single,System.Boolean,System.Boolean)">
            <summary>
            generates a normal map from a height map calculating it with a sobel filter
            </summary>
            <returns>The sobel filter.</returns>
            <param name="image">Image.</param>
            <param name="normalStrength">Normal strength.</param>
        </member>
        <member name="T:Nez.CrossFadeTransition">
            <summary>
            fades from the current Scene to the new Scene
            </summary>
        </member>
        <member name="F:Nez.CrossFadeTransition.FadeDuration">
            <summary>
            duration for the fade
            </summary>
        </member>
        <member name="F:Nez.CrossFadeTransition.FadeEaseType">
            <summary>
            ease equation to use for the cross fade
            </summary>
        </member>
        <member name="T:Nez.FadeTransition">
            <summary>
            fades to fadeToColor then fades to the new Scene
            </summary>
        </member>
        <member name="F:Nez.FadeTransition.FadeToColor">
            <summary>
            the color we will fade to/from
            </summary>
        </member>
        <member name="F:Nez.FadeTransition.FadeOutDuration">
            <summary>
            duration to fade to fadeToColor
            </summary>
        </member>
        <member name="F:Nez.FadeTransition.DelayBeforeFadeInDuration">
            <summary>
            delay to start fading out
            </summary>
        </member>
        <member name="F:Nez.FadeTransition.FadeInDuration">
            <summary>
            duration to fade from fadeToColor to the new Scene
            </summary>
        </member>
        <member name="F:Nez.FadeTransition.FadeEaseType">
            <summary>
            ease equation to use for the fade
            </summary>
        </member>
        <member name="T:Nez.ImageMaskTransition">
            <summary>
            uses an image to mask out part of the scene scaling it from max-to-min then from min-to-max with rotation. Note that the Texture
            should be loaded in the main Core.contentManager, not a Scene contentManager. The transition will unload it for you. The Texture
            should be transparent where it should be masked out and white where it should be masked in.
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.Duration">
            <summary>
            duration of the transition both in and out
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.DelayBeforeMaskOut">
            <summary>
            delay after the mask-in before the mark-out begins
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.MinScale">
            <summary>
            minimum scale of the mask
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.MaxScale">
            <summary>
            maximum scale of the mask
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.ScaleEaseType">
            <summary>
            ease equation to use for the scale animation
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.MinRotation">
            <summary>
            minimum rotation of the mask animation
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.MaxRotation">
            <summary>
            maximum rotation of the mask animation
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition.RotationEaseType">
            <summary>
            ease equation to use for the rotation animation
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition._maskTexture">
            <summary>
            the Texture used as a mask. It should be white where the mask shows the underlying Scene and transparent elsewhere
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition._maskPosition">
            <summary>
            position of the mask, the center of the screen
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition._maskOrigin">
            <summary>
            origin of the mask, the center of the Texture
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition._blendState">
            <summary>
            multiplicative BlendState used for rendering the mask
            </summary>
        </member>
        <member name="F:Nez.ImageMaskTransition._maskRenderTarget">
            <summary>
            the mask is first rendered into a RenderTarget
            </summary>
        </member>
        <member name="T:Nez.SceneTransition">
             <summary>
             SceneTransition is used to transition from one Scene to another or within a scene with an effect. If sceneLoadAction is null Nez
             will perform an in-Scene transition as opposed to loading a new Scene mid transition.
            
             The general gist of a transition is the following:
             - onBeginTransition will be called allowing you to yield for multipart transitions
             - for two part transitions with Effects you can yield on a call to TickEffectProgressProperty for part one to obscure the screen
             - next, yield a call to loadNextScene to load up the new Scene
             - finally, yield again on TickEffectProgressProperty to un-obscure the screen and show the new Scene
             </summary>
        </member>
        <member name="F:Nez.SceneTransition.PreviousSceneRender">
            <summary>
            contains the last render of the previous Scene. Can be used to obscure the screen while loading a new Scene.
            </summary>
        </member>
        <member name="F:Nez.SceneTransition.WantsPreviousSceneRender">
            <summary>
            if true, Nez will render the previous scene into previousSceneRender so that you can use it with your transition
            </summary>
        </member>
        <member name="F:Nez.SceneTransition.LoadSceneOnBackgroundThread">
            <summary>
            if true, the next Scene will be loaded on a background thread. Note that if raw PNG files are used they cannot be loaded
            on a background thread.
            </summary>
        </member>
        <member name="F:Nez.SceneTransition.sceneLoadAction">
            <summary>
            function that should return the newly loaded scene
            </summary>
        </member>
        <member name="P:Nez.SceneTransition.HasPreviousSceneRender">
            <summary>
            used internally to decide if the previous Scene should render into previousSceneRender. Does double duty to ensure that the
            render only happens once.
            </summary>
            <value><c>true</c> if has previous scene render; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Nez.SceneTransition.OnScreenObscured">
            <summary>
            called when loadNextScene is executing. This is useful when doing inter-Scene transitions so that you know when you can more the
            Camera or reset any Entities
            </summary>
        </member>
        <member name="F:Nez.SceneTransition.OnTransitionCompleted">
            <summary>
            called when the Transition has completed it's execution, so that other work can be called, such as Starting another transition.
            </summary>
        </member>
        <member name="F:Nez.SceneTransition._loadsNewScene">
            <summary>
            flag indicating if this transition will load a new scene or not
            </summary>
        </member>
        <member name="F:Nez.SceneTransition._isNewSceneLoaded">
            <summary>
            use this for two part transitions. For example, a fade would fade to black first then when _isNewSceneLoaded becomes true it would
            fade in. For in-Scene transitions _isNewSceneLoaded should be set to true at the midpoint just as if a new Scene was loaded.
            </summary>
        </member>
        <member name="M:Nez.SceneTransition.OnBeginTransition">
            <summary>
            called after the previousSceneRender occurs for the first (and only) time. At this point you can load your new Scene after
            yielding one frame (so the first render call happens before scene loading).
            </summary>
        </member>
        <member name="M:Nez.SceneTransition.PreRender(Nez.Batcher)">
            <summary>
            called before the Scene is rendered. This allows a transition to render to a RenderTarget if needed and avoids issues with MonoGame
            clearing the framebuffer when a RenderTarget is used.
            </summary>
        </member>
        <member name="M:Nez.SceneTransition.Render(Nez.Batcher)">
            <summary>
            do all of your rendering here.static This is a base implementation. Any special rendering should override
            this method.
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="M:Nez.SceneTransition.TransitionComplete">
            <summary>
            this will be called when your transition is complete and the new Scene has been set. It will clean up
            </summary>
        </member>
        <member name="M:Nez.SceneTransition.TickEffectProgressProperty(Microsoft.Xna.Framework.Graphics.Effect,System.Single,Nez.Tweens.EaseType,System.Boolean)">
            <summary>
            the most common type of transition seems to be one that ticks progress from 0 - 1. This method takes care of that for you
            if your transition needs to have a _progress property ticked after the scene loads.
            </summary>
            <param name="duration">duration</param>
            <param name="reverseDirection">if true, _progress will go from 1 to 0. If false, it goes form 0 to 1</param>
        </member>
        <member name="T:Nez.SquaresTransition">
            <summary>
            builds up a cover of squares then removes them
            </summary>
        </member>
        <member name="P:Nez.SquaresTransition.SquareColor">
            <summary>
            color of the squares
            </summary>
            <value>The color of the square.</value>
        </member>
        <member name="P:Nez.SquaresTransition.Size">
            <summary>
            size of the squares. If you want perfect squares use size, size / aspectRatio_of_screen
            </summary>
            <value>The size.</value>
        </member>
        <member name="F:Nez.SquaresTransition.SquaresInDuration">
            <summary>
            duration for squares to populate the screen
            </summary>
        </member>
        <member name="F:Nez.SquaresTransition.DelayBeforeSquaresInDuration">
            <summary>
            delay before removing squares
            </summary>
        </member>
        <member name="F:Nez.SquaresTransition.SquaresOutDuration">
            <summary>
            duration for squares to unpopulate screen
            </summary>
        </member>
        <member name="F:Nez.SquaresTransition.EaseType">
            <summary>
            ease equation to use for the animation
            </summary>
        </member>
        <member name="T:Nez.TextureWipeTransition">
            <summary>
            uses a texture (transitionTexture) to control a wipe animation. the blue channel of the texture determines if color is shown or the
            previous scenes render. Sample textures are 
            based on: https://www.youtube.com/watch?v=LnAoD7hgDxw
            </summary>
        </member>
        <member name="P:Nez.TextureWipeTransition.Opacity">
            <summary>
            opacity of the wipe
            </summary>
            <value>The opacity.</value>
        </member>
        <member name="P:Nez.TextureWipeTransition.Color">
            <summary>
            color to wipe to
            </summary>
            <value>The color.</value>
        </member>
        <member name="P:Nez.TextureWipeTransition.TransitionTexture">
            <summary>
            texture used for the transition. During the transition whenever the blue channel of this texture is less than progress (which is ticked
            from 0 - 1) the color will be used else the previous scene render will be used
            </summary>
            <value>The transition texture.</value>
        </member>
        <member name="P:Nez.TextureWipeTransition.UseRedGreenChannelsForDistortion">
            <summary>
            if true, the red and green channels of the transitionTexture will be used to offset the texture lookup during the transition
            </summary>
            <value><c>true</c> if use red green channels for distortion; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Nez.TextureWipeTransition.Duration">
            <summary>
            duration for the wind transition
            </summary>
        </member>
        <member name="F:Nez.TextureWipeTransition.EaseType">
            <summary>
            ease equation to use for the animation
            </summary>
        </member>
        <member name="F:Nez.TransformTransition.Duration">
            <summary>
            duration for the animation
            </summary>
        </member>
        <member name="F:Nez.TransformTransition.TransitionEaseType">
            <summary>
            ease equation for the transition
            </summary>
        </member>
        <member name="T:Nez.WindTransition">
            <summary>
            sweeps wind accross the screen revealing the new Scene
            </summary>
        </member>
        <member name="P:Nez.WindTransition.WindSegments">
            <summary>
            how many wind segments should be used. Defaults to 100. (1 - 1000)
            </summary>
            <value>The wind segments.</value>
        </member>
        <member name="P:Nez.WindTransition.Size">
            <summary>
            size of the wind streaks. defaults to 0.3. (0.1 - 1)
            </summary>
            <value>The size.</value>
        </member>
        <member name="F:Nez.WindTransition.Duration">
            <summary>
            duration for the wind transition
            </summary>
        </member>
        <member name="F:Nez.WindTransition.EaseType">
            <summary>
            ease equation to use for the animation
            </summary>
        </member>
        <member name="T:Nez.Clipboard">
            <summary>
            prep for a proper multi-platform clipboard system. For now it just mocks the clipboard and will only work in-app
            </summary>
        </member>
        <member name="F:Nez.GamePadData.IsLeftStickVerticalInverted">
            <summary>
            toggles inverting the left sticks vertical value
            </summary>
        </member>
        <member name="F:Nez.GamePadData.IsRightStickVerticalInverted">
            <summary>
            toggles inverting the right sticks vertical value
            </summary>
        </member>
        <member name="M:Nez.GamePadData.IsConnected">
            <summary>
            returns true if this game pad is connected
            </summary>
            <returns><c>true</c>, if connected was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.GamePadData.HasGamepadStateChanged">
            <summary>
            returns true if the game pad state changed
            </summary>
            <returns><c>true</c>, if previous state does not equal current state, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.GamePadData.IsButtonPressed(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            only true if down this frame
            </summary>
            <returns><c>true</c>, if button pressed was ised, <c>false</c> otherwise.</returns>
            <param name="button">Button.</param>
        </member>
        <member name="M:Nez.GamePadData.IsButtonDown(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            true the entire time the button is down
            </summary>
            <returns><c>true</c>, if button down was ised, <c>false</c> otherwise.</returns>
            <param name="button">Button.</param>
        </member>
        <member name="M:Nez.GamePadData.IsButtonReleased(Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            true only the frame the button is released
            </summary>
            <returns><c>true</c>, if button released was ised, <c>false</c> otherwise.</returns>
            <param name="button">Button.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftStickLeftPressed(System.Single)">
            <summary>
            true only the frame the stick passes the deadzone in the direction
            </summary>
            <returns><c>true</c>, if left stick left pressed was ised, <c>false</c> otherwise.</returns>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftStickRightPressed(System.Single)">
            <summary>
            true only the frame the stick passes the deadzone in the direction
            </summary>
            <returns><c>true</c>, if left stick right pressed was ised, <c>false</c> otherwise.</returns>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftStickUpPressed(System.Single)">
            <summary>
            true only the frame the stick passes the deadzone in the direction
            </summary>
            <returns><c>true</c>, if left stick up pressed was ised, <c>false</c> otherwise.</returns>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftStickDownPressed(System.Single)">
            <summary>
            true only the frame the stick passes the deadzone in the direction
            </summary>
            <returns><c>true</c>, if left stick down pressed was ised, <c>false</c> otherwise.</returns>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="P:Nez.GamePadData.DpadLeftDown">
            <summary>
            true the entire time the dpad is down
            </summary>
            <value><c>true</c> if dpad left down; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadLeftPressed">
            <summary>
            true only the first frame the dpad is down
            </summary>
            <value><c>true</c> if dpad left pressed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadLeftReleased">
            <summary>
            true only the frame the dpad is released
            </summary>
            <value><c>true</c> if dpad left released; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadRightDown">
            <summary>
            true the entire time the dpad is down
            </summary>
            <value><c>true</c> if dpad left down; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadRightPressed">
            <summary>
            true only the first frame the dpad is down
            </summary>
            <value><c>true</c> if dpad left pressed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadRightReleased">
            <summary>
            true only the frame the dpad is released
            </summary>
            <value><c>true</c> if dpad left released; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadUpDown">
            <summary>
            true the entire time the dpad is down
            </summary>
            <value><c>true</c> if dpad left down; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadUpPressed">
            <summary>
            true only the first frame the dpad is down
            </summary>
            <value><c>true</c> if dpad left pressed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadUpReleased">
            <summary>
            true only the frame the dpad is released
            </summary>
            <value><c>true</c> if dpad left released; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadDownDown">
            <summary>
            true the entire time the dpad is down
            </summary>
            <value><c>true</c> if dpad left down; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadDownPressed">
            <summary>
            true only the first frame the dpad is down
            </summary>
            <value><c>true</c> if dpad left pressed; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.GamePadData.DpadDownReleased">
            <summary>
            true only the frame the dpad is released
            </summary>
            <value><c>true</c> if dpad left released; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.GamePadData.IsLeftTriggerDown(System.Single)">
            <summary>
            true whenever the trigger is down past the threshold
            </summary>
            <returns><c>true</c>, if left trigger down was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftTriggerPressed(System.Single)">
            <summary>
            true only the frame that the trigger passed the threshold
            </summary>
            <returns><c>true</c>, if left trigger pressed was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.GamePadData.IsLeftTriggerReleased(System.Single)">
            <summary>
            true the frame the trigger is released
            </summary>
            <returns><c>true</c>, if left trigger released was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.GamePadData.IsRightTriggerDown(System.Single)">
            <summary>
            true whenever the trigger is down past the threshold
            </summary>
            <returns><c>true</c>, if left trigger down was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.GamePadData.IsRightTriggerPressed(System.Single)">
            <summary>
            true only the frame that the trigger passed the threshold
            </summary>
            <returns><c>true</c>, if left trigger pressed was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.GamePadData.IsRightTriggerReleased(System.Single)">
            <summary>
            true the frame the trigger is released
            </summary>
            <returns><c>true</c>, if left trigger released was ised, <c>false</c> otherwise.</returns>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="F:Nez.Input.Touch">
            <summary>
            the TouchInput details when on a device that supports touch
            </summary>
        </member>
        <member name="P:Nez.Input.ResolutionScale">
            <summary>
            set by the Scene and used to scale mouse input for cases where the Scene render target is a different size
            than the backbuffer. This situation basically results in mouse coordinates in screen space instead of
            in the render target coordinate system;
            </summary>
        </member>
        <member name="P:Nez.Input.ResolutionOffset">
            <summary>
            set by the Scene and used to get mouse input from raw screen coordinates to render target coordinates. Any
            SceneResolutionPolicy that can result in letterboxing could potentially have an offset (basically, the
            letterbox portion of the render).
            </summary>
            <returns></returns>
        </member>
        <member name="P:Nez.Input.MaxSupportedGamePads">
            <summary>
            gets/sets the maximum supported gamepads
            </summary>
            <value></value>
        </member>
        <member name="M:Nez.Input.ScaledPosition(Microsoft.Xna.Framework.Vector2)">
            <summary>
            this takes into account the SceneResolutionPolicy and returns the value scaled to the RenderTargets coordinates
            </summary>
            <value>The scaled position.</value>
        </member>
        <member name="M:Nez.Input.SetCurrentMouseState(Microsoft.Xna.Framework.Input.MouseState)">
            <summary>
            to be used with great care! This lets you override the current MouseState. This is useful
            when the Nez render is embedded in a larger window so that mouse coordinates can be translated
            to Nez space from the outer window coordinates and for simulating mouse input.
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Nez.Input.SetPreviousMouseState(Microsoft.Xna.Framework.Input.MouseState)">
            <summary>
            useful for simulating mouse input
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:Nez.Input.SetCurrentKeyboardState(Microsoft.Xna.Framework.Input.KeyboardState)">
            <summary>
            useful for simulating keyboard input
            </summary>
            <param name="state">State.</param>
        </member>
        <member name="M:Nez.Input.SetPreviousKeyboardState(Microsoft.Xna.Framework.Input.KeyboardState)">
            <summary>
            useful for simulating keyboard input
            </summary>
            <param name="state">State.</param>
        </member>
        <member name="P:Nez.Input.PreviousKeyboardState">
            <summary>
            returns the previous KeyboardState from the last frame
            </summary>
            <value></value>
        </member>
        <member name="P:Nez.Input.CurrentKeyboardState">
            <summary>
            returns the KeyboardState from this frame
            </summary>
            <value></value>
        </member>
        <member name="M:Nez.Input.IsKeyPressed(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            only true if down this frame and not down the previous frame
            </summary>
            <returns><c>true</c>, if key pressed was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyPressed(Microsoft.Xna.Framework.Input.Keys[])">
            <summary>
            only true if any of the keys are down this frame and not down the previous frame
            </summary>
            <returns><c>true</c>, if any of the keys pressed was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyDown(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            true the entire time the key is down
            </summary>
            <returns><c>true</c>, if key down was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyDown(Microsoft.Xna.Framework.Input.Keys[])">
            <summary>
            only true if any of the keys are down
            </summary>
            <returns><c>true</c>, if any of the keys down was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            true only the frame the key is released
            </summary>
            <returns><c>true</c>, if key up was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyReleased(Microsoft.Xna.Framework.Input.Keys[])">
            <summary>
            true only if any of the keys are released
            </summary>
            <returns><c>true</c>, if any of the keys up was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyPressed(Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            only true if one of the keys is down this frame
            </summary>
            <returns><c>true</c>, if key pressed was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyDown(Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            true while either of the keys are down
            </summary>
            <returns><c>true</c>, if key down was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.IsKeyReleased(Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            true only the frame one of the keys are released
            </summary>
            <returns><c>true</c>, if key up was gotten, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Input.HasKeyboardStateChanged">
            <summary>
            returns true if the keyboard state changed
            </summary>
            <returns><c>true</c>, if previous keyboard state does not equal current keyboard state, <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Nez.Input.PreviousMouseState">
            <summary>
            returns the previous mouse state. Use with caution as it only contains raw data and does not take camera scaling into affect like
            Input.mousePosition does.
            </summary>
            <value>The state of the previous mouse.</value>
        </member>
        <member name="P:Nez.Input.CurrentMouseState">
            <summary>
            returns the current mouse state. Use with caution as it only contains raw data and does not take camera scaling into affect like
            Input.mousePosition does.
            </summary>
        </member>
        <member name="P:Nez.Input.LeftMouseButtonPressed">
            <summary>
            only true if down this frame
            </summary>
        </member>
        <member name="P:Nez.Input.LeftMouseButtonDown">
            <summary>
            true while the button is down
            </summary>
        </member>
        <member name="P:Nez.Input.LeftMouseButtonReleased">
            <summary>
            true only the frame the button is released
            </summary>
        </member>
        <member name="P:Nez.Input.RightMouseButtonPressed">
            <summary>
            only true if pressed this frame
            </summary>
        </member>
        <member name="P:Nez.Input.RightMouseButtonDown">
            <summary>
            true while the button is down
            </summary>
        </member>
        <member name="P:Nez.Input.RightMouseButtonReleased">
            <summary>
            true only the frame the button is released
            </summary>
        </member>
        <member name="P:Nez.Input.MiddleMouseButtonPressed">
            <summary>
            only true if down this frame
            </summary>
        </member>
        <member name="P:Nez.Input.MiddleMouseButtonDown">
            <summary>
            true while the button is down
            </summary>
        </member>
        <member name="P:Nez.Input.MiddleMouseButtonReleased">
            <summary>
            true only the frame the button is released
            </summary>
        </member>
        <member name="P:Nez.Input.FirstExtendedMouseButtonPressed">
            <summary>
            only true if down this frame
            </summary>
        </member>
        <member name="P:Nez.Input.FirstExtendedMouseButtonDown">
            <summary>
            true while the button is down
            </summary>
        </member>
        <member name="P:Nez.Input.FirstExtendedMouseButtonReleased">
            <summary>
            true only the frame the button is released
            </summary>
        </member>
        <member name="P:Nez.Input.SecondExtendedMouseButtonPressed">
            <summary>
            only true if down this frame
            </summary>
        </member>
        <member name="P:Nez.Input.SecondExtendedMouseButtonDown">
            <summary>
            true while the button is down
            </summary>
        </member>
        <member name="P:Nez.Input.SecondExtendedMouseButtonReleased">
            <summary>
            true only the frame the button is released
            </summary>
        </member>
        <member name="P:Nez.Input.MouseWheel">
            <summary>
            gets the raw ScrollWheelValue
            </summary>
            <value>The mouse wheel.</value>
        </member>
        <member name="P:Nez.Input.MouseWheelDelta">
            <summary>
            gets the delta ScrollWheelValue
            </summary>
            <value>The mouse wheel delta.</value>
        </member>
        <member name="P:Nez.Input.RawMousePosition">
            <summary>
            unscaled mouse position. This is the actual screen space value
            </summary>
            <value>The raw mouse position.</value>
        </member>
        <member name="P:Nez.Input.MousePosition">
            <summary>
            alias for scaledMousePosition
            </summary>
            <value>The mouse position.</value>
        </member>
        <member name="P:Nez.Input.ScaledMousePosition">
            <summary>
            this takes into account the SceneResolutionPolicy and returns the value scaled to the RenderTargets coordinates
            </summary>
            <value>The scaled mouse position.</value>
        </member>
        <member name="M:Nez.Input.HasMouseStateChanged">
            <summary>
            returns true if the mouse state changed
            </summary>
            <returns><c>true</c>, if previous mouse state does not equal current mouse state, <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Nez.InputEventTypeComparer">
            <summary>
            comparer that should be passed to a dictionary constructor to avoid boxing/unboxing when using an enum as a key
            on Mono
            </summary>
        </member>
        <member name="T:Nez.TouchInput">
            <summary>
            to enable touch input you must first call enableTouchSupport()
            </summary>
        </member>
        <member name="T:Nez.VirtualAxis">
            <summary>
            A virtual input represented as a float between -1 and 1
            </summary>
        </member>
        <member name="F:Nez.VirtualAxis.GamePadLeftStickY.InvertResult">
            <summary>
            if true, pressing up will return -1 and down will return 1 matching GamePadDpadUpDown
            </summary>
        </member>
        <member name="T:Nez.VirtualButton">
            <summary>
            A virtual input that is represented as a boolean. As well as simply checking the current button state, you can ask whether
            it was just pressed or released this frame. You can also keep the button press stored in a buffer for a limited time, or
            until it is consumed by calling consumeBuffer()
            </summary>
        </member>
        <member name="M:Nez.VirtualButton.AddKeyboardKey(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            adds a keyboard key to this VirtualButton
            </summary>
            <returns>The keyboard key.</returns>
            <param name="key">Key.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddKeyboardKey(Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            adds a keyboard key with modifier to this VirtualButton. modifier must be in the down state for isPressed/isDown to be true.
            </summary>
            <returns>The keyboard key.</returns>
            <param name="key">Key.</param>
            <param name="modifier">Modifier.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddGamePadButton(System.Int32,Microsoft.Xna.Framework.Input.Buttons)">
            <summary>
            adds a GamePad buttons press to this VirtualButton
            </summary>
            <returns>The game pad button.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="button">Button.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddGamePadLeftTrigger(System.Int32,System.Single)">
            <summary>
            adds a GamePad left trigger press to this VirtualButton
            </summary>
            <returns>The game pad left trigger.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddGamePadRightTrigger(System.Int32,System.Single)">
            <summary>
            adds a GamePad right trigger press to this VirtualButton
            </summary>
            <returns>The game pad right trigger.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddGamePadDPad(System.Int32,Nez.Direction)">
            <summary>
            adds a GamePad DPad press to this VirtualButton
            </summary>
            <returns>The game pad DP ad.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="direction">Direction.</param>
        </member>
        <member name="M:Nez.VirtualButton.AddMouseLeftButton">
            <summary>
            adds a left mouse click to this VirtualButton
            </summary>
            <returns>The mouse left button.</returns>
        </member>
        <member name="M:Nez.VirtualButton.AddMouseRightButton">
            <summary>
            adds a right mouse click to this VirtualButton
            </summary>
            <returns>The mouse right button.</returns>
        </member>
        <member name="M:Nez.VirtualButton.AddMouseMiddleButton">
            <summary>
            adds a right mouse click to this VirtualButton
            </summary>
            <returns>The mouse right button.</returns>
        </member>
        <member name="M:Nez.VirtualButton.AddMouseFirstExtendedButton">
            <summary>
            adds a right mouse click to this VirtualButton
            </summary>
            <returns>The mouse right button.</returns>
        </member>
        <member name="M:Nez.VirtualButton.AddMouseSecondExtendedButton">
            <summary>
            adds a right mouse click to this VirtualButton
            </summary>
            <returns>The mouse right button.</returns>
        </member>
        <member name="T:Nez.VirtualButton.KeyboardModifiedKey">
            <summary>
            works like KeyboardKey except the modifier key must also be down for isDown/isPressed to be true. isReleased checks only key.
            </summary>
        </member>
        <member name="T:Nez.VirtualInput">
            <summary>
            Represents a virtual button, axis or joystick whose state is determined by the state of its VirtualInputNodes
            </summary>
        </member>
        <member name="F:Nez.VirtualInput.OverlapBehavior.CancelOut">
            <summary>
            duplicate input will result in canceling each other out and no input will be recorded. Example: press left arrow key and while
            holding it down press right arrow. This will result in canceling each other out.
            </summary>
        </member>
        <member name="F:Nez.VirtualInput.OverlapBehavior.TakeOlder">
            <summary>
            the first input found will be used
            </summary>
        </member>
        <member name="F:Nez.VirtualInput.OverlapBehavior.TakeNewer">
            <summary>
            the last input found will be used
            </summary>
        </member>
        <member name="M:Nez.VirtualInput.Deregister">
            <summary>
            deregisters the VirtualInput from the Input system. Call this when you are done polling the VirtualInput
            </summary>
        </member>
        <member name="T:Nez.VirtualInputNode">
            <summary>
            Add these to your VirtualInput to define how it determines its current input state. 
            For example, if you want to check whether a keyboard key is pressed, create a VirtualButton and add to it a VirtualButton.KeyboardKey
            </summary>
        </member>
        <member name="T:Nez.VirtualIntegerAxis">
            <summary>
            A virtual input that is represented as a int that is either -1, 0, or 1. It corresponds to input that can range from on to nuetral to off
            such as GamePad DPad left/right. Can also use two keyboard Keys as the positive/negative checks.
            </summary>
        </member>
        <member name="P:Nez.VirtualIntegerAxis.DirectionJustPushed">
            <summary>
            The direction that this axis was pushed (or repeated, if repeating is enabled) this frame.
            </summary>
            <value>-1 or 1 if it was just pushed in that direction, or 0 if it was not.</value>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.JustPushed(System.Int32)">
            <summary>
            Returns true if this input was pushed in a direction (from 0) this frame. If SetRepeat() is used, this will
            repeatedly return true after the provided intervals.
            </summary>
            <param name="direction">The direction to check, should be -1 or 1.</param>
            <returns></returns>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.SetRepeat(System.Single)">
            <summary>
            Set the repeat interval used for JustPushed().
            </summary>
            <param name="repeatTime">Interval between repetitions.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.SetRepeat(System.Single,System.Single)">
            <summary>
            Set the repeat interval used for JustPushed().
            </summary>
            <param name="firstRepeatTime">Delay after the initial push.</param>
            <param name="multiRepeatTime">Delay after subsequent repetitions.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadLeftStickX(System.Int32,System.Single)">
            <summary>
            adds GamePad left stick X to this VirtualInput
            </summary>
            <returns>The game pad left stick x.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadLeftStickY(System.Int32,System.Single)">
            <summary>
            adds GamePad left stick Y to this VirtualInput
            </summary>
            <returns>The game pad left stick y.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadRightStickX(System.Int32,System.Single)">
            <summary>
            adds GamePad right stick X to this VirtualInput
            </summary>
            <returns>The game pad right stick x.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadRightStickY(System.Int32,System.Single)">
            <summary>
            adds GamePad right stick Y to this VirtualInput
            </summary>
            <returns>The game pad right stick y.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadDPadUpDown(System.Int32)">
            <summary>
            adds GamePad DPad up/down to this VirtualInput
            </summary>
            <returns>The game pad DP ad up down.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddGamePadDPadLeftRight(System.Int32)">
            <summary>
            adds GamePad DPad left/right to this VirtualInput
            </summary>
            <returns>The game pad DP ad left right.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
        </member>
        <member name="M:Nez.VirtualIntegerAxis.AddKeyboardKeys(Nez.VirtualInput.OverlapBehavior,Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            adds keyboard Keys to emulate left/right or up/down to this VirtualInput
            </summary>
            <returns>The keyboard keys.</returns>
            <param name="overlapBehavior">Overlap behavior.</param>
            <param name="negative">Negative.</param>
            <param name="positive">Positive.</param>
        </member>
        <member name="T:Nez.VirtualJoystick">
            <summary>
            A virtual input that is represented as a Vector2, with both X and Y as values between -1 and 1
            </summary>
        </member>
        <member name="M:Nez.VirtualJoystick.AddGamePadLeftStick(System.Int32,System.Single)">
            <summary>
            adds GamePad left stick input to this VirtualJoystick
            </summary>
            <returns>The game pad left stick.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualJoystick.AddGamePadRightStick(System.Int32,System.Single)">
            <summary>
            adds GamePad right stick input to this VirtualJoystick
            </summary>
            <returns>The game pad right stick.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
            <param name="deadzone">Deadzone.</param>
        </member>
        <member name="M:Nez.VirtualJoystick.AddGamePadDPad(System.Int32)">
            <summary>
            adds GamePad DPad input to this VirtualJoystick
            </summary>
            <returns>The game pad DP ad.</returns>
            <param name="gamepadIndex">Gamepad index.</param>
        </member>
        <member name="M:Nez.VirtualJoystick.AddKeyboardKeys(Nez.VirtualInput.OverlapBehavior,Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys,Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            adds keyboard keys input to this VirtualJoystick. Four keyboard keys will emulate left/right/up/down. For example WASD or the arrow
            keys.
            </summary>
            <returns>The keyboard keys.</returns>
            <param name="overlapBehavior">Overlap behavior.</param>
            <param name="left">Left.</param>
            <param name="right">Right.</param>
            <param name="up">Up.</param>
            <param name="down">Down.</param>
        </member>
        <member name="T:Nez.Splines.Bezier">
            <summary>
            cubic and quadratic bezier helper
            </summary>
        </member>
        <member name="M:Nez.Splines.Bezier.GetPoint(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            evaluate quadratic bezier
            </summary>
            <returns>The point.</returns>
            <param name="p0">P0.</param>
            <param name="p1">P1.</param>
            <param name="p2">P2.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.Bezier.GetFirstDerivative(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            gets the first derivative for a quadratic bezier
            </summary>
            <returns>The first derivative.</returns>
            <param name="p0">P0.</param>
            <param name="p1">P1.</param>
            <param name="p2">P2.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.Bezier.GetPoint(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            evaluate a cubic bezier
            </summary>
            <returns>The point.</returns>
            <param name="start">P0.</param>
            <param name="firstControlPoint">P1.</param>
            <param name="secondControlPoint">P2.</param>
            <param name="end">P3.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.Bezier.GetFirstDerivative(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            gets the first derivative for a cubic bezier
            </summary>
            <returns>The first derivative.</returns>
            <param name="start">P0.</param>
            <param name="firstControlPoint">P1.</param>
            <param name="secondControlPoint">P2.</param>
            <param name="end">P3.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.Bezier.RecursiveGetOptimizedDrawingPoints(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2},System.Single)">
            <summary>
            recursively subdivides a bezier curve until distanceTolerance is met. Flat sections will have less points then curved with this
            algorithm.
            
            This image defines the midpoints calculated and makes the variable names sensical:
            http://www.antigrain.com/research/adaptive_bezier/bezier09.gif
            based on http://www.antigrain.com/research/adaptive_bezier/index.html
            </summary>
            <param name="start">Start.</param>
            <param name="firstCtrlPoint">First ctrl point.</param>
            <param name="secondCtrlPoint">Second ctrl point.</param>
            <param name="end">End.</param>
            <param name="points">Points.</param>
            <param name="distanceTolerance">Distance tolerance.</param>
        </member>
        <member name="M:Nez.Splines.Bezier.GetOptimizedDrawingPoints(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            recursively subdivides a bezier curve until distanceTolerance is met. Flat sections will have less points then curved with this
            algorithm. Returns a pooled list that should be returned to the ListPool when done.
            </summary>
            <param name="start">Start.</param>
            <param name="firstCtrlPoint">First ctrl point.</param>
            <param name="secondCtrlPoint">Second ctrl point.</param>
            <param name="end">End.</param>
            <param name="distanceTolerance">Distance tolerance.</param>
        </member>
        <member name="T:Nez.Splines.BezierSpline">
            <summary>
            houses a series of cubic bezier points and provides helper methods to access the bezier
            </summary>
        </member>
        <member name="M:Nez.Splines.BezierSpline.PointIndexAtTime(System.Single@)">
            <summary>
            helper that gets the bezier point index at time t. t is modified in the process to be in the range of the curve segment.
            </summary>
            <returns>The index at time.</returns>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.SetControlPoint(System.Int32,Microsoft.Xna.Framework.Vector2)">
            <summary>
            sets a control point taking into account if this is a shared point and adjusting appropriately if it is
            </summary>
            <param name="index">Index.</param>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.GetPointAtTime(System.Single)">
            <summary>
            gets the point on the bezier at time t
            </summary>
            <returns>The point at time.</returns>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.GetVelocityAtTime(System.Single)">
            <summary>
            gets the velocity (first derivative) of the bezier at time t
            </summary>
            <returns>The velocity at time.</returns>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.GetDirectionAtTime(System.Single)">
            <summary>
            gets the direction (normalized first derivative) of the bezier at time t
            </summary>
            <returns>The direction at time.</returns>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.AddCurve(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            adds a curve to the bezier
            </summary>
            <param name="start">Start.</param>
            <param name="firstControlPoint">First control point.</param>
            <param name="secondControlPoint">Second control point.</param>
        </member>
        <member name="M:Nez.Splines.BezierSpline.Reset">
            <summary>
            resets the bezier removing all points
            </summary>
        </member>
        <member name="M:Nez.Splines.BezierSpline.GetDrawingPoints(System.Int32)">
            <summary>
            breaks up the spline into totalSegments parts and returns all the points required to draw using lines
            </summary>
            <returns>The drawing points.</returns>
            <param name="totalSegments">Total segments.</param>
        </member>
        <member name="T:Nez.Flags">
            <summary>
            utility class to assist with dealing with bitmasks. All methods except isFlagSet expect the flag parameter to be a non-shifted flag.
            This lets you use plain old ints (0, 1, 2, 3, etc) to set/unset your flags.
            </summary>
        </member>
        <member name="M:Nez.Flags.IsFlagSet(System.Int32,System.Int32)">
            <summary>
            checks to see if the bit flag is set in the int. This check expects flag to be shifted already!
            </summary>
            <returns><c>true</c>, if flag set was ised, <c>false</c> otherwise.</returns>
            <param name="self">Self.</param>
            <param name="flag">Flag.</param>
        </member>
        <member name="M:Nez.Flags.IsUnshiftedFlagSet(System.Int32,System.Int32)">
            <summary>
            checks to see if the bit flag is set in the int
            </summary>
            <returns><c>true</c>, if flag set was ised, <c>false</c> otherwise.</returns>
            <param name="self">Self.</param>
            <param name="flag">Flag.</param>
        </member>
        <member name="M:Nez.Flags.SetFlagExclusive(System.Int32@,System.Int32)">
            <summary>
            sets the flag bit of the int removing any already set flags
            </summary>
            <param name="self">Self.</param>
            <param name="flag">Flag.</param>
        </member>
        <member name="M:Nez.Flags.SetFlag(System.Int32@,System.Int32)">
            <summary>
            sets the flag bit of the int
            </summary>
            <param name="self">Self.</param>
            <param name="flag">Flag.</param>
        </member>
        <member name="M:Nez.Flags.UnsetFlag(System.Int32@,System.Int32)">
            <summary>
            unsets the flag bit of the int
            </summary>
            <param name="self">Self.</param>
            <param name="flag">Flag.</param>
        </member>
        <member name="M:Nez.Flags.InvertFlags(System.Int32@)">
            <summary>
            inverts the set bits of the int
            </summary>
            <param name="self">Self.</param>
        </member>
        <member name="M:Nez.Flags.BinaryStringRepresentation(System.Int32,System.Int32)">
            <summary>
            prints the binary representation of the int. Handy for debugging int flag overlaps visually.
            </summary>
            <returns>The string representation.</returns>
            <param name="self">Self.</param>
            <param name="leftPadWidth">Left pad width.</param>
        </member>
        <member name="M:Nez.Mathf.FastCeilToInt(System.Single)">
            <summary>
            ceils the float to the nearest int value above y. note that this only works for values in the range of short
            </summary>
            <returns>The ceil to int.</returns>
            <param name="y">F.</param>
        </member>
        <member name="M:Nez.Mathf.Radians(System.Single)">
            <summary>Returns the result of converting a float value from degrees to radians.</summary>
        </member>
        <member name="M:Nez.Mathf.Degrees(System.Single)">
            <summary>Returns the result of converting a double value from radians to degrees.</summary>
        </member>
        <member name="M:Nez.Mathf.FastFloorToInt(System.Single)">
            <summary>
            floors the float to the nearest int value below x. note that this only works for values in the range of short
            </summary>
            <returns>The floor to int.</returns>
            <param name="x">The x coordinate.</param>
        </member>
        <member name="M:Nez.Mathf.TruncateToInt(System.Single)">
            <summary>
            Calculates the integral part of a number cast to an int
            </summary>
            <returns>The to int.</returns>
            <param name="f">F.</param>
        </member>
        <member name="M:Nez.Mathf.Clamp01(System.Single)">
            <summary>
            clamps value between 0 and 1
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Mathf.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Restricts a value to be within a specified range.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value. If <c>value</c> is less than <c>min</c>, <c>min</c> will be returned.</param>
            <param name="max">The maximum value. If <c>value</c> is greater than <c>max</c>, <c>max</c> will be returned.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:Nez.Mathf.LerpAngle(System.Single,System.Single,System.Single)">
            <summary>
            lerps an angle in degrees between a and b. handles wrapping around 360
            </summary>
            <returns>The angle.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Mathf.LerpAngleRadians(System.Single,System.Single,System.Single)">
            <summary>
            lerps an angle in radians between a and b. handles wrapping around 2*Pi
            </summary>
            <returns>The angle.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.Mathf.Repeat(System.Single,System.Single)">
            <summary>
            loops t so that it is never larger than length and never smaller than 0
            </summary>
            <param name="t">T.</param>
            <param name="length">Length.</param>
        </member>
        <member name="M:Nez.Mathf.IncrementWithWrap(System.Int32,System.Int32)">
            <summary>
            increments t and ensures it is always greater than or equal to 0 and less than length
            </summary>
            <param name="t">T.</param>
            <param name="length">Length.</param>
        </member>
        <member name="M:Nez.Mathf.DecrementWithWrap(System.Int32,System.Int32)">
            <summary>
            decrements t and ensures it is always greater than or equal to 0 and less than length
            </summary>
            <returns>The with wrap.</returns>
            <param name="t">T.</param>
            <param name="length">Length.</param>
        </member>
        <member name="M:Nez.Mathf.PingPong(System.Single,System.Single)">
            <summary>
            ping-pongs t so that it is never larger than length and never smaller than 0
            </summary>
            <returns>The pong.</returns>
            <param name="t">T.</param>
            <param name="length">Length.</param>
        </member>
        <member name="M:Nez.Mathf.SignThreshold(System.Single,System.Single)">
            <summary>
            if value >= threshold returns its sign else returns 0
            </summary>
            <returns>The threshold.</returns>
            <param name="value">Value.</param>
            <param name="threshold">Threshold.</param>
        </member>
        <member name="M:Nez.Mathf.DeltaAngle(System.Single,System.Single)">
            <summary>
            Calculates the shortest difference between two given angles in degrees
            </summary>
            <returns>The angle.</returns>
            <param name="current">Current.</param>
            <param name="target">Target.</param>
        </member>
        <member name="M:Nez.Mathf.DeltaAngleRadians(System.Single,System.Single)">
            <summary>
            Calculates the shortest difference between two given angles given in radians
            </summary>
            <returns>The angle.</returns>
            <param name="current">Current.</param>
            <param name="target">Target.</param>
        </member>
        <member name="M:Nez.Mathf.Approach(System.Single,System.Single,System.Single)">
            <summary>
            moves start towards end by shift amount clamping the result. start can be less than or greater than end.
            example: start is 2, end is 10, shift is 4 results in 6
            </summary>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="shift">Shift.</param>
        </member>
        <member name="M:Nez.Mathf.ApproachAngle(System.Single,System.Single,System.Single)">
            <summary>
            moves start angle towards end angle by shift amount clamping the result and choosing the shortest path. start can be less than or greater than end.
            example 1: start is 30, end is 100, shift is 25 results in 55
            example 2: start is 340, end is 30, shift is 25 results in 5 (365 is wrapped to 5)
            </summary>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="shift">Shift.</param>
        </member>
        <member name="M:Nez.Mathf.ApproachAngleRadians(System.Single,System.Single,System.Single)">
            <summary>
            moves start angle towards end angle by shift amount (all in radians) clamping the result and choosing the shortest path. start can be less than or greater than end.
            this method works very similar to approachAngle, the only difference is use of radians instead of degrees and wrapping at 2*Pi instead of 360.
            </summary>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="shift">Shift.</param>
        </member>
        <member name="M:Nez.Mathf.Approximately(System.Single,System.Single,System.Single)">
            <summary>
            checks to see if two values are approximately the same using an acceptable tolerance for the check
            </summary>
            <param name="value1">Value1.</param>
            <param name="value2">Value2.</param>
            <param name="tolerance">Tolerance.</param>
        </member>
        <member name="M:Nez.Mathf.MinOf(System.Single,System.Single,System.Single)">
            <summary>
            returns the minimum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
        </member>
        <member name="M:Nez.Mathf.MaxOf(System.Single,System.Single,System.Single)">
            <summary>
            returns the maximum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
        </member>
        <member name="M:Nez.Mathf.MinOf(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns the minimum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
            <param name="d">D.</param>
        </member>
        <member name="M:Nez.Mathf.MinOf(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns the minimum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
            <param name="d">D.</param>
        </member>
        <member name="M:Nez.Mathf.MaxOf(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns the maximum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
            <param name="d">D.</param>
        </member>
        <member name="M:Nez.Mathf.MaxOf(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns the maximum of the passed in values
            </summary>
            <returns>The of.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
            <param name="d">D.</param>
        </member>
        <member name="M:Nez.Mathf.Between(System.Single,System.Single,System.Single)">
            <summary>
            checks to see if value is between min/max inclusive of min/max
            </summary>
            <param name="value">Value.</param>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Mathf.Between(System.Int32,System.Int32,System.Int32)">
            <summary>
            checks to see if value is between min/max inclusive of min/max
            </summary>
            <param name="value">Value.</param>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Mathf.IsEven(System.Int32)">
            <summary>
            returns true if value is even
            </summary>
            <returns><c>true</c>, if even was ised, <c>false</c> otherwise.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Mathf.IsOdd(System.Int32)">
            <summary>
            returns true if value is odd
            </summary>
            <returns><c>true</c>, if odd was ised, <c>false</c> otherwise.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Mathf.RoundWithRoundedAmount(System.Single,System.Single@)">
            <summary>
            rounds value and returns it and the amount that was rounded
            </summary>
            <returns>The with remainder.</returns>
            <param name="value">Value.</param>
            <param name="roundedAmount">roundedAmount.</param>
        </member>
        <member name="M:Nez.Mathf.Map01(System.Single,System.Single,System.Single)">
            <summary>
            Maps a value from some arbitrary range to the 0 to 1 range
            </summary>
            <param name="value">Value.</param>
            <param name="min">Lminimum value.</param>
            <param name="max">maximum value</param>
        </member>
        <member name="M:Nez.Mathf.Map10(System.Single,System.Single,System.Single)">
            <summary>
            Maps a value from some arbitrary range to the 1 to 0 range. this is just the reverse of map01
            </summary>
            <param name="value">Value.</param>
            <param name="min">Lminimum value.</param>
            <param name="max">maximum value</param>
        </member>
        <member name="M:Nez.Mathf.Map(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            mapps value (which is in the range leftMin - leftMax) to a value in the range rightMin - rightMax
            </summary>
            <param name="value">Value.</param>
            <param name="leftMin">Left minimum.</param>
            <param name="leftMax">Left max.</param>
            <param name="rightMin">Right minimum.</param>
            <param name="rightMax">Right max.</param>
        </member>
        <member name="M:Nez.Mathf.RoundToNearest(System.Single,System.Single)">
            <summary>
            rounds value to the nearest number in steps of roundToNearest. Ex: found 127 to nearest 5 results in 125
            </summary>
            <returns>The to nearest.</returns>
            <param name="value">Value.</param>
            <param name="roundToNearest">Round to nearest.</param>
        </member>
        <member name="M:Nez.Mathf.WithinEpsilon(System.Single,System.Single)">
            <summary>
            Checks if the value passed falls under a certain threshold.
            Useful for small, precise comparisons.
            </summary>
            <param name="value">The value to check.</param>
            <param name="ep">The threshold to check the value with. <see cref="F:Nez.Mathf.Epsilon"/> is used by default.</param>
        </member>
        <member name="M:Nez.Mathf.Hypotenuse(System.Single,System.Single)">
            <summary>
            returns sqrt( x * x + y * y )
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Mathf.Sqrt(System.Single)">
            <summary>
            Returns the square root
            </summary>
            <param name="val">Value.</param>
        </member>
        <member name="M:Nez.Mathf.Sin(System.Single)">
            <summary>
            Returns the sine of angle in radians
            </summary>
            <param name="f">F.</param>
        </member>
        <member name="M:Nez.Mathf.Cos(System.Single)">
            <summary>
            Returns the cosine of angle in radians
            </summary>
            <param name="f">F.</param>
        </member>
        <member name="M:Nez.Mathf.Acos(System.Single)">
            <summary>
            Returns the arc-cosine of f: the angle in radians whose cosine is f
            </summary>
            <param name="f">F.</param>
        </member>
        <member name="M:Nez.Mathf.Atan2(System.Single,System.Single)">
            <summary>
            returns the angle whose tangent is the quotient (y/x) of two specified numbers
            </summary>
            <param name="y">The y coordinate.</param>
            <param name="x">The x coordinate.</param>
        </member>
        <member name="M:Nez.Mathf.RotateAround(Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            helper for moving a value around in a circle.
            </summary>
        </member>
        <member name="M:Nez.Mathf.RotateAround(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            the rotation is relative to the current position not the total rotation. For example, if you are currently at 90 degrees and
            want to rotate to 135 degrees, you would use an angle of 45, not 135.
            </summary>
            <returns>The around.</returns>
            <param name="point">Point.</param>
            <param name="center">Center.</param>
            <param name="angleInDegrees">Angle in degrees.</param>
        </member>
        <member name="M:Nez.Mathf.RotateAroundRadians(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            the rotation is relative to the current position not the total rotation. For example, if you are currently at 1 Pi radians and
            want to rotate to 1.5 Pi radians, you would use an angle of 0.5 Pi, not 1.5 Pi.
            </summary>
            <returns>The around.</returns>
            <param name="point">Point.</param>
            <param name="center">Center.</param>
            <param name="angleInDegrees">Angle in radians.</param>
        </member>
        <member name="M:Nez.Mathf.PointOnCircle(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            gets a point on the circumference of the circle given its center, radius and angle. 0 degrees is 3 o'clock.
            </summary>
            <returns>The on circle.</returns>
            <param name="circleCenter">Circle center.</param>
            <param name="radius">Radius.</param>
            <param name="angleInDegrees">Angle in degrees.</param>
        </member>
        <member name="M:Nez.Mathf.PointOnCircleRadians(Microsoft.Xna.Framework.Vector2,System.Single,System.Single)">
            <summary>
            gets a point on the circumference of the circle given its center, radius and angle. 0 radians is 3 o'clock.
            </summary>
            <returns>The on circle.</returns>
            <param name="circleCenter">Circle center.</param>
            <param name="radius">Radius.</param>
            <param name="angleInDegrees">Angle in radians.</param>
        </member>
        <member name="M:Nez.Mathf.Lissajou(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            lissajou curve
            </summary>
            <param name="xFrequency">X frequency.</param>
            <param name="yFrequency">Y frequency.</param>
            <param name="xMagnitude">X magnitude.</param>
            <param name="yMagnitude">Y magnitude.</param>
            <param name="phase">Phase.</param>
        </member>
        <member name="M:Nez.Mathf.LissajouDamped(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            damped version of a lissajou curve with oscillation between 0 and max magnitude over time. Damping should be between 0 and 1 for best
            results. oscillationInterval is the time in seconds for half of the animation loop to complete.
            </summary>
            <returns>The damped.</returns>
            <param name="xFrequency">X frequency.</param>
            <param name="yFrequency">Y frequency.</param>
            <param name="xMagnitude">X magnitude.</param>
            <param name="yMagnitude">Y magnitude.</param>
            <param name="phase">Phase.</param>
            <param name="damping">Damping.</param>
            <param name="oscillationInterval">Oscillation interval.</param>
        </member>
        <member name="T:Nez.Matrix2D">
            <summary>
            Represents the right-handed 3x3 floating point matrix, which can store translation, scale and rotation information.
            </summary>
        </member>
        <member name="P:Nez.Matrix2D.Identity">
            <summary>
            Returns the identity matrix.
            </summary>
        </member>
        <member name="P:Nez.Matrix2D.Translation">
            <summary>
            Position stored in this matrix.
            </summary>
        </member>
        <member name="P:Nez.Matrix2D.Rotation">
            <summary>
            rotation in radians stored in this matrix
            </summary>
            <value>The rotation.</value>
        </member>
        <member name="P:Nez.Matrix2D.RotationDegrees">
            <summary>
            rotation in degrees stored in this matrix
            </summary>
            <value>The rotation degrees.</value>
        </member>
        <member name="P:Nez.Matrix2D.Scale">
            <summary>
            Scale stored in this matrix.
            </summary>
        </member>
        <member name="M:Nez.Matrix2D.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructs a matrix.
            </summary>
        </member>
        <member name="M:Nez.Matrix2D.Add(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> which contains sum of two matrixes.
            </summary>
            <param name="matrix1">The first matrix to add.</param>
            <param name="matrix2">The second matrix to add.</param>
            <returns>The result of the matrix addition.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Add(Nez.Matrix2D@,Nez.Matrix2D@,Nez.Matrix2D@)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> which contains sum of two matrixes.
            </summary>
            <param name="matrix1">The first matrix to add.</param>
            <param name="matrix2">The second matrix to add.</param>
            <param name="result">The result of the matrix addition as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateRotation(System.Single)">
            <summary>
            Creates a new rotation <see cref="T:Nez.Matrix2D"/> around Z axis.
            </summary>
            <param name="radians">Angle in radians.</param>
            <returns>The rotation <see cref="T:Nez.Matrix2D"/> around Z axis.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateRotation(System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new rotation <see cref="T:Nez.Matrix2D"/> around Z axis.
            </summary>
            <param name="radians">Angle in radians.</param>
            <param name="result">The rotation <see cref="T:Nez.Matrix2D"/> around Z axis as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(System.Single)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="scale">Scale value for all three axises.</param>
            <returns>The scaling <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="scale">Scale value for all three axises.</param>
            <param name="result">The scaling <see cref="T:Nez.Matrix2D"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(System.Single,System.Single)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="xScale">Scale value for X axis.</param>
            <param name="yScale">Scale value for Y axis.</param>
            <returns>The scaling <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(System.Single,System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="xScale">Scale value for X axis.</param>
            <param name="yScale">Scale value for Y axis.</param>
            <param name="result">The scaling <see cref="T:Nez.Matrix2D"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="scale"><see cref="T:Microsoft.Xna.Framework.Vector2"/> representing x and y scale values.</param>
            <returns>The scaling <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateScale(Microsoft.Xna.Framework.Vector2@,Nez.Matrix2D@)">
            <summary>
            Creates a new scaling <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="scale"><see cref="T:Microsoft.Xna.Framework.Vector3"/> representing x,y and z scale values.</param>
            <param name="result">The scaling <see cref="T:Nez.Matrix2D"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateTranslation(System.Single,System.Single)">
            <summary>
            Creates a new translation <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="xPosition">X coordinate of translation.</param>
            <param name="yPosition">Y coordinate of translation.</param>
            <returns>The translation <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateTranslation(Microsoft.Xna.Framework.Vector2@,Nez.Matrix2D@)">
            <summary>
            Creates a new translation <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="position">X,Y and Z coordinates of translation.</param>
            <param name="result">The translation <see cref="T:Nez.Matrix2D"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.CreateTranslation(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a new translation <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="position">X,Y and Z coordinates of translation.</param>
            <returns>The translation <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Matrix2D.CreateTranslation(System.Single,System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new translation <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="xPosition">X coordinate of translation.</param>
            <param name="yPosition">Y coordinate of translation.</param>
            <param name="result">The translation <see cref="T:Nez.Matrix2D"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Divide(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by the elements of another matrix.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">Divisor <see cref="T:Nez.Matrix2D"/>.</param>
            <returns>The result of dividing the matrix.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Divide(Nez.Matrix2D@,Nez.Matrix2D@,Nez.Matrix2D@)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by the elements of another matrix.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">Divisor <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="result">The result of dividing the matrix as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Divide(Nez.Matrix2D,System.Single)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by a scalar.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="divider">Divisor scalar.</param>
            <returns>The result of dividing a matrix by a scalar.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Divide(Nez.Matrix2D@,System.Single,Nez.Matrix2D@)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by a scalar.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="divider">Divisor scalar.</param>
            <param name="result">The result of dividing a matrix by a scalar as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Lerp(Nez.Matrix2D,Nez.Matrix2D,System.Single)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains linear interpolation of the values in specified matrixes.
            </summary>
            <param name="matrix1">The first <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">The second <see cref="T:Microsoft.Xna.Framework.Vector2"/>.</param>
            <param name="amount">Weighting value(between 0.0 and 1.0).</param>
            <returns>>The result of linear interpolation of the specified matrixes.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Lerp(Nez.Matrix2D@,Nez.Matrix2D@,System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains linear interpolation of the values in specified matrixes.
            </summary>
            <param name="matrix1">The first <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">The second <see cref="T:Microsoft.Xna.Framework.Vector2"/>.</param>
            <param name="amount">Weighting value(between 0.0 and 1.0).</param>
            <param name="result">The result of linear interpolation of the specified matrixes as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Multiply(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains a multiplication of two matrix.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <returns>Result of the matrix multiplication.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Multiply(Nez.Matrix2D@,Nez.Matrix2D@,Nez.Matrix2D@)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains a multiplication of two matrix.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="result">Result of the matrix multiplication as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Multiply(Nez.Matrix2D,System.Single)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains a multiplication of <see cref="T:Nez.Matrix2D"/> and a scalar.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="scaleFactor">Scalar value.</param>
            <returns>Result of the matrix multiplication with a scalar.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Multiply(Nez.Matrix2D@,System.Single,Nez.Matrix2D@)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains a multiplication of <see cref="T:Nez.Matrix2D"/> and a scalar.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="scaleFactor">Scalar value.</param>
            <param name="result">Result of the matrix multiplication with a scalar as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.op_Addition(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Adds two matrixes.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the add sign.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/> on the right of the add sign.</param>
            <returns>Sum of the matrixes.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Division(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by the elements of another <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the div sign.</param>
            <param name="matrix2">Divisor <see cref="T:Nez.Matrix2D"/> on the right of the div sign.</param>
            <returns>The result of dividing the matrixes.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Division(Nez.Matrix2D,System.Single)">
            <summary>
            Divides the elements of a <see cref="T:Nez.Matrix2D"/> by a scalar.
            </summary>
            <param name="matrix">Source <see cref="T:Nez.Matrix2D"/> on the left of the div sign.</param>
            <param name="divider">Divisor scalar on the right of the div sign.</param>
            <returns>The result of dividing a matrix by a scalar.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Equality(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Compares whether two <see cref="T:Nez.Matrix2D"/> instances are equal without any tolerance.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the equal sign.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/> on the right of the equal sign.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Inequality(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Compares whether two <see cref="T:Nez.Matrix2D"/> instances are not equal without any tolerance.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the not equal sign.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/> on the right of the not equal sign.</param>
            <returns><c>true</c> if the instances are not equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Multiply(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Multiplies two matrixes.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the mul sign.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/> on the right of the mul sign.</param>
            <returns>Result of the matrix multiplication.</returns>
            <remarks>
            Using matrix multiplication algorithm - see http://en.wikipedia.org/wiki/Matrix_multiplication.
            </remarks>
        </member>
        <member name="M:Nez.Matrix2D.op_Multiply(Nez.Matrix2D,System.Single)">
            <summary>
            Multiplies the elements of matrix by a scalar.
            </summary>
            <param name="matrix">Source <see cref="T:Nez.Matrix2D"/> on the left of the mul sign.</param>
            <param name="scaleFactor">Scalar value on the right of the mul sign.</param>
            <returns>Result of the matrix multiplication with a scalar.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_Subtraction(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Subtracts the values of one <see cref="T:Nez.Matrix2D"/> from another <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="matrix1">Source <see cref="T:Nez.Matrix2D"/> on the left of the sub sign.</param>
            <param name="matrix2">Source <see cref="T:Nez.Matrix2D"/> on the right of the sub sign.</param>
            <returns>Result of the matrix subtraction.</returns>
        </member>
        <member name="M:Nez.Matrix2D.op_UnaryNegation(Nez.Matrix2D)">
            <summary>
            Inverts values in the specified <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <param name="matrix">Source <see cref="T:Nez.Matrix2D"/> on the right of the sub sign.</param>
            <returns>Result of the inversion.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Subtract(Nez.Matrix2D,Nez.Matrix2D)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains subtraction of one matrix from another.
            </summary>
            <param name="matrix1">The first <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">The second <see cref="T:Nez.Matrix2D"/>.</param>
            <returns>The result of the matrix subtraction.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Subtract(Nez.Matrix2D@,Nez.Matrix2D@,Nez.Matrix2D@)">
            <summary>
            Creates a new <see cref="T:Nez.Matrix2D"/> that contains subtraction of one matrix from another.
            </summary>
            <param name="matrix1">The first <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="matrix2">The second <see cref="T:Nez.Matrix2D"/>.</param>
            <param name="result">The result of the matrix subtraction as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Transpose(Nez.Matrix2D)">
            <summary>
            Swap the matrix rows and columns.
            </summary>
            <param name="matrix">The matrix for transposing operation.</param>
            <returns>The new <see cref="T:Nez.Matrix2D"/> which contains the transposing result.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Transpose(Nez.Matrix2D@,Nez.Matrix2D@)">
            <summary>
            Swap the matrix rows and columns.
            </summary>
            <param name="matrix">The matrix for transposing operation.</param>
            <param name="result">The new <see cref="T:Nez.Matrix2D"/> which contains the transposing result as an output parameter.</param>
        </member>
        <member name="M:Nez.Matrix2D.Equals(Nez.Matrix2D)">
            <summary>
            Compares whether current instance is equal to specified <see cref="T:Nez.Matrix2D"/> without any tolerance.
            </summary>
            <param name="other">The <see cref="T:Nez.Matrix2D"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Matrix2D.Equals(System.Object)">
            <summary>
            Compares whether current instance is equal to specified <see cref="T:System.Object"/> without any tolerance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Matrix2D.GetHashCode">
            <summary>
            Gets the hash code of this <see cref="T:Nez.Matrix2D"/>.
            </summary>
            <returns>Hash code of this <see cref="T:Nez.Matrix2D"/>.</returns>
        </member>
        <member name="M:Nez.Random.GetSeed">
            <summary>
            returns current seed value
            </summary>
            <returns>Seed.</returns>
        </member>
        <member name="M:Nez.Random.SetSeed(System.Int32)">
            <summary>
            resets rng with new seed
            </summary>
            <param name="seed">Seed.</param>
        </member>
        <member name="M:Nez.Random.NextFloat">
            <summary>
            returns a random float between 0 (inclusive) and 1 (exclusive)
            </summary>
            <returns>The float.</returns>
        </member>
        <member name="M:Nez.Random.NextFloat(System.Single)">
            <summary>
            returns a random float between 0 (inclusive) and max (exclusive)
            </summary>
            <returns>The float.</returns>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Random.NextInt(System.Int32)">
            <summary>
            returns a random int between 0 (inclusive) and max (exclusive)
            </summary>
            <returns>The float.</returns>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Random.NextAngle">
            <summary>
            returns a random float between 0 and 2 * PI
            </summary>
            <returns>The angle.</returns>
        </member>
        <member name="M:Nez.Random.NextUnitVector">
            <summary>
            Returns a random unit vector with direction between 0 and 2 * PI
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nez.Random.NextColor">
            <summary>
            returns a random color
            </summary>
            <returns>The color.</returns>
        </member>
        <member name="M:Nez.Random.Range(System.Int32,System.Int32)">
            <summary>
            Returns a random integer between min (inclusive) and max (exclusive)
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.Random.Range(System.Single,System.Single)">
            <summary>
            Returns a random float between min (inclusive) and max (exclusive)
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.Random.Range(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Returns a random Vector2, and x- and y-values of which are between min (inclusive) and max (exclusive)
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <returns></returns>
        </member>
        <member name="M:Nez.Random.MinusOneToOne">
            <summary>
            returns a random float between -1 and 1
            </summary>
            <returns>The one to one.</returns>
        </member>
        <member name="M:Nez.Random.Chance(System.Single)">
            <summary>
            returns true if the next random is less than percent. Percent should be between 0 and 1
            </summary>
            <param name="percent">Percent.</param>
        </member>
        <member name="M:Nez.Random.Chance(System.Int32)">
            <summary>
            returns true if the next random is less than value. Value should be between 0 and 100.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Random.Choose``1(``0,``0)">
            <summary>
            randomly returns one of the given values
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Random.Choose``1(``0,``0,``0)">
            <summary>
            randomly returns one of the given values
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="third">Third.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Random.Choose``1(``0,``0,``0,``0)">
            <summary>
            randomly returns one of the given values
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="third">Third.</param>
            <param name="fourth">Fourth.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:Nez.RectangleF">
            <summary>
            Describes a 2D-rectangle. 
            </summary>
        </member>
        <member name="F:Nez.RectangleF.X">
            <summary>
            The x coordinate of the top-left corner of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="F:Nez.RectangleF.Y">
            <summary>
            The y coordinate of the top-left corner of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="F:Nez.RectangleF.Width">
            <summary>
            The width of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="F:Nez.RectangleF.Height">
            <summary>
            The height of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Empty">
            <summary>
            Returns a <see cref="T:Nez.RectangleF"/> with X=0, Y=0, Width=0, Height=0.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.MaxRect">
            <summary>
            returns a RectangleF of float.Min/Max values
            </summary>
            <value>The max rect.</value>
        </member>
        <member name="P:Nez.RectangleF.Left">
            <summary>
            Returns the x coordinate of the left edge of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Right">
            <summary>
            Returns the x coordinate of the right edge of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Top">
            <summary>
            Returns the y coordinate of the top edge of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Bottom">
            <summary>
            Returns the y coordinate of the bottom edge of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Max">
            <summary>
            gets the max point of the rectangle, the bottom-right corner
            </summary>
            <value>The max.</value>
        </member>
        <member name="P:Nez.RectangleF.Min">
            <summary>
            gets the min point of the rectangle, the top-left corner
            </summary>
            <value>The max.</value>
        </member>
        <member name="P:Nez.RectangleF.IsEmpty">
            <summary>
            Whether or not this <see cref="T:Nez.RectangleF"/> has a <see cref="F:Nez.RectangleF.Width"/> and
            <see cref="F:Nez.RectangleF.Height"/> of 0, and a <see cref="P:Nez.RectangleF.Location"/> of (0, 0).
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Location">
            <summary>
            The top-left coordinates of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Size">
            <summary>
            The width-height coordinates of this <see cref="T:Nez.RectangleF"/>.
            </summary>
        </member>
        <member name="P:Nez.RectangleF.Center">
            <summary>
            A <see cref="T:Microsoft.Xna.Framework.Point"/> located in the center of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <remarks>
            If <see cref="F:Nez.RectangleF.Width"/> or <see cref="F:Nez.RectangleF.Height"/> is an odd number,
            the center point will be rounded down.
            </remarks>
        </member>
        <member name="M:Nez.RectangleF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a new instance of <see cref="T:Nez.RectangleF"/> struct, with the specified
            position, width, and height.
            </summary>
            <param name="x">The x coordinate of the top-left corner of the created <see cref="T:Nez.RectangleF"/>.</param>
            <param name="y">The y coordinate of the top-left corner of the created <see cref="T:Nez.RectangleF"/>.</param>
            <param name="width">The width of the created <see cref="T:Nez.RectangleF"/>.</param>
            <param name="height">The height of the created <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.#ctor(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Creates a new instance of <see cref="T:Nez.RectangleF"/> struct, with the specified
            location and size.
            </summary>
            <param name="location">The x and y coordinates of the top-left corner of the created <see cref="T:Nez.RectangleF"/>.</param>
            <param name="size">The width and height of the created <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.FromMinMax(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            creates a RectangleF given min/max points (top-left, bottom-right points)
            </summary>
            <returns>The minimum max points.</returns>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.RectangleF.FromMinMax(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            creates a RectangleF given min/max points (top-left, bottom-right points)
            </summary>
            <returns>The minimum max points.</returns>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.RectangleF.RectEncompassingPoints(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            given the points of a polygon calculates the bounds
            </summary>
            <returns>The from polygon points.</returns>
            <param name="points">Points.</param>
        </member>
        <member name="M:Nez.RectangleF.GetSide(Nez.Edge)">
            <summary>
            gets the position of the specified edge
            </summary>
            <returns>The side.</returns>
            <param name="edge">Side.</param>
        </member>
        <member name="M:Nez.RectangleF.Contains(System.Int32,System.Int32)">
            <summary>
            Gets whether or not the provided coordinates lie within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="x">The x coordinate of the point to check for containment.</param>
            <param name="y">The y coordinate of the point to check for containment.</param>
            <returns><c>true</c> if the provided coordinates lie inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Contains(System.Single,System.Single)">
            <summary>
            Gets whether or not the provided coordinates lie within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="x">The x coordinate of the point to check for containment.</param>
            <param name="y">The y coordinate of the point to check for containment.</param>
            <returns><c>true</c> if the provided coordinates lie inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Contains(Microsoft.Xna.Framework.Point)">
            <summary>
            Gets whether or not the provided <see cref="T:Microsoft.Xna.Framework.Point"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The coordinates to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <returns><c>true</c> if the provided <see cref="T:Microsoft.Xna.Framework.Point"/> lies inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Contains(Microsoft.Xna.Framework.Point@,System.Boolean@)">
            <summary>
            Gets whether or not the provided <see cref="T:Microsoft.Xna.Framework.Point"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The coordinates to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result"><c>true</c> if the provided <see cref="T:Microsoft.Xna.Framework.Point"/> lies inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise. As an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Contains(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets whether or not the provided <see cref="T:Microsoft.Xna.Framework.Vector2"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The coordinates to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <returns><c>true</c> if the provided <see cref="T:Microsoft.Xna.Framework.Vector2"/> lies inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Contains(Microsoft.Xna.Framework.Vector2@,System.Boolean@)">
            <summary>
            Gets whether or not the provided <see cref="T:Microsoft.Xna.Framework.Vector2"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The coordinates to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result"><c>true</c> if the provided <see cref="T:Microsoft.Xna.Framework.Vector2"/> lies inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise. As an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Contains(Nez.RectangleF)">
            <summary>
            Gets whether or not the provided <see cref="T:Nez.RectangleF"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The <see cref="T:Nez.RectangleF"/> to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <returns><c>true</c> if the provided <see cref="T:Nez.RectangleF"/>'s bounds lie entirely inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Contains(Nez.RectangleF@,System.Boolean@)">
            <summary>
            Gets whether or not the provided <see cref="T:Nez.RectangleF"/> lies within the bounds of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="value">The <see cref="T:Nez.RectangleF"/> to check for inclusion in this <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result"><c>true</c> if the provided <see cref="T:Nez.RectangleF"/>'s bounds lie entirely inside this <see cref="T:Nez.RectangleF"/>; <c>false</c> otherwise. As an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Inflate(System.Int32,System.Int32)">
            <summary>
            Adjusts the edges of this <see cref="T:Nez.RectangleF"/> by specified horizontal and vertical amounts. 
            </summary>
            <param name="horizontalAmount">Value to adjust the left and right edges.</param>
            <param name="verticalAmount">Value to adjust the top and bottom edges.</param>
        </member>
        <member name="M:Nez.RectangleF.Inflate(System.Single,System.Single)">
            <summary>
            Adjusts the edges of this <see cref="T:Nez.RectangleF"/> by specified horizontal and vertical amounts. 
            </summary>
            <param name="horizontalAmount">Value to adjust the left and right edges.</param>
            <param name="verticalAmount">Value to adjust the top and bottom edges.</param>
        </member>
        <member name="M:Nez.RectangleF.Intersects(Nez.RectangleF)">
            <summary>
            Gets whether or not the other <see cref="T:Nez.RectangleF"/> intersects with this rectangle.
            </summary>
            <param name="value">The other rectangle for testing.</param>
            <returns><c>true</c> if other <see cref="T:Nez.RectangleF"/> intersects with this rectangle; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Intersects(Nez.RectangleF@,System.Boolean@)">
            <summary>
            Gets whether or not the other <see cref="T:Nez.RectangleF"/> intersects with this rectangle.
            </summary>
            <param name="value">The other rectangle for testing.</param>
            <param name="result"><c>true</c> if other <see cref="T:Nez.RectangleF"/> intersects with this rectangle; <c>false</c> otherwise. As an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Intersects(Nez.RectangleF@)">
            <summary>
            returns true if other intersects rect
            </summary>
            <param name="other">other.</param>
        </member>
        <member name="M:Nez.RectangleF.GetClosestPointOnRectangleFToPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the closest point that is in or on the RectangleF to the given point
            </summary>
            <returns>The closest point on rectangle to point.</returns>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.RectangleF.GetClosestPointOnRectangleBorderToPoint(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            gets the closest point that is on the rectangle border to the given point
            </summary>
            <returns>The closest point on rectangle border to point.</returns>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.RectangleF.Intersect(Nez.RectangleF,Nez.RectangleF)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> that contains overlapping region of two other rectangles.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <returns>Overlapping region of the two rectangles.</returns>
        </member>
        <member name="M:Nez.RectangleF.Intersect(Nez.RectangleF@,Nez.RectangleF@,Nez.RectangleF@)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> that contains overlapping region of two other rectangles.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result">Overlapping region of the two rectangles as an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Offset(System.Int32,System.Int32)">
            <summary>
            Changes the <see cref="P:Nez.RectangleF.Location"/> of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="offsetX">The x coordinate to add to this <see cref="T:Nez.RectangleF"/>.</param>
            <param name="offsetY">The y coordinate to add to this <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.Offset(System.Single,System.Single)">
            <summary>
            Changes the <see cref="P:Nez.RectangleF.Location"/> of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="offsetX">The x coordinate to add to this <see cref="T:Nez.RectangleF"/>.</param>
            <param name="offsetY">The y coordinate to add to this <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.Offset(Microsoft.Xna.Framework.Point)">
            <summary>
            Changes the <see cref="P:Nez.RectangleF.Location"/> of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="amount">The x and y components to add to this <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.Offset(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Changes the <see cref="P:Nez.RectangleF.Location"/> of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="amount">The x and y components to add to this <see cref="T:Nez.RectangleF"/>.</param>
        </member>
        <member name="M:Nez.RectangleF.Union(Nez.RectangleF,Nez.RectangleF)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> that completely contains two other rectangles.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <returns>The union of the two rectangles.</returns>
        </member>
        <member name="M:Nez.RectangleF.Union(Nez.RectangleF@,Nez.RectangleF@,Nez.RectangleF@)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> that completely contains two other rectangles.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result">The union of the two rectangles as an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.Overlap(Nez.RectangleF,Nez.RectangleF)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> where the rectangles overlap.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <returns>The overlap of the two rectangles.</returns>
        </member>
        <member name="M:Nez.RectangleF.Overlap(Nez.RectangleF@,Nez.RectangleF@,Nez.RectangleF@)">
            <summary>
            Creates a new <see cref="T:Nez.RectangleF"/> where the rectangles overlap.
            </summary>
            <param name="value1">The first <see cref="T:Nez.RectangleF"/>.</param>
            <param name="value2">The second <see cref="T:Nez.RectangleF"/>.</param>
            <param name="result">The overlap of the two rectangles as an output parameter.</param>
        </member>
        <member name="M:Nez.RectangleF.GetSweptBroadphaseBounds(System.Single,System.Single)">
            <summary>
            returns a RectangleF that spans the current rect and the provided delta positions
            </summary>
            <returns>The swept broadphase box.</returns>
            <param name="velocityX">Velocity x.</param>
            <param name="velocityY">Velocity y.</param>
        </member>
        <member name="M:Nez.RectangleF.CollisionCheck(Nez.RectangleF@,System.Single@,System.Single@)">
            <summary>
            returns true if the boxes are colliding
            moveX and moveY will return the movement that b1 must move to avoid the collision
            </summary>
            <param name="other">Other.</param>
            <param name="moveX">Move x.</param>
            <param name="moveY">Move y.</param>
        </member>
        <member name="M:Nez.RectangleF.GetIntersectionDepth(Nez.RectangleF@,Nez.RectangleF@)">
            <summary>
            Calculates the signed depth of intersection between two rectangles.
            </summary>
            <returns>
            The amount of overlap between two intersecting rectangles. These depth values can be negative depending on which sides the rectangles
            intersect. This allows callers to determine the correct direction to push objects in order to resolve collisions.
            If the rectangles are not intersecting, Vector2.Zero is returned.
            </returns>
        </member>
        <member name="M:Nez.RectangleF.Equals(System.Object)">
            <summary>
            Compares whether current instance is equal to specified <see cref="T:System.Object"/>.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.Equals(Nez.RectangleF)">
            <summary>
            Compares whether current instance is equal to specified <see cref="T:Nez.RectangleF"/>.
            </summary>
            <param name="other">The <see cref="T:Nez.RectangleF"/> to compare.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.GetHashCode">
            <summary>
            Gets the hash code of this <see cref="T:Nez.RectangleF"/>.
            </summary>
            <returns>Hash code of this <see cref="T:Nez.RectangleF"/>.</returns>
        </member>
        <member name="M:Nez.RectangleF.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation of this <see cref="T:Nez.RectangleF"/> in the format:
            {X:[<see cref="F:Nez.RectangleF.X"/>] Y:[<see cref="F:Nez.RectangleF.Y"/>] Width:[<see cref="F:Nez.RectangleF.Width"/>] Height:[<see cref="F:Nez.RectangleF.Height"/>]}
            </summary>
            <returns><see cref="T:System.String"/> representation of this <see cref="T:Nez.RectangleF"/>.</returns>
        </member>
        <member name="M:Nez.RectangleF.op_Equality(Nez.RectangleF,Nez.RectangleF)">
            <summary>
            Compares whether two <see cref="T:Nez.RectangleF"/> instances are equal.
            </summary>
            <param name="a"><see cref="T:Nez.RectangleF"/> instance on the left of the equal sign.</param>
            <param name="b"><see cref="T:Nez.RectangleF"/> instance on the right of the equal sign.</param>
            <returns><c>true</c> if the instances are equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.RectangleF.op_Inequality(Nez.RectangleF,Nez.RectangleF)">
            <summary>
            Compares whether two <see cref="T:Nez.RectangleF"/> instances are not equal.
            </summary>
            <param name="a"><see cref="T:Nez.RectangleF"/> instance on the left of the not equal sign.</param>
            <param name="b"><see cref="T:Nez.RectangleF"/> instance on the right of the not equal sign.</param>
            <returns><c>true</c> if the instances are not equal; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Nez.SubpixelFloat">
            <summary>
            simple helper class that manages a float value. It stores the value until the total accumulated is greater than 1. Once it exceeds
            1 the value will be added on to amount when update is called.
            
            General usage would be something like the following.
             - calculate your objects velocity however you normally would
             - multiply by deltaTime to keep it framerate independent
             - pass the calculated delta movement for this frame to the SubpixelFloat.update method for both x and y. This will result in deltaMove
               being rounded to an int and the SubpixelFloat will deal with accumulating the excess value.
            
               	var deltaMove = velocity * Time.deltaTime;
            	_x.update( ref deltaMove.X );
            	_y.update( ref deltaMove.Y );
            </summary>
        </member>
        <member name="M:Nez.SubpixelFloat.Update(System.Single@)">
            <summary>
            increments remainder by amount, truncates the value to an int, stores off the new remainder and sets amount to the current value.
            </summary>
            <param name="amount">Amount.</param>
        </member>
        <member name="M:Nez.SubpixelFloat.Reset">
            <summary>
            resets the remainder to 0. Useful when an object collides with an immovable object. In that case you will want to zero out the
            subpixel remainder since it is null and void due to the collision.
            </summary>
        </member>
        <member name="M:Nez.SubpixelVector2.Update(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            increments s/y remainders by amount, truncates the values to an int, stores off the new remainders and sets amount to the current value.
            </summary>
            <param name="amount">Amount.</param>
        </member>
        <member name="M:Nez.SubpixelVector2.Reset">
            <summary>
            resets the remainder to 0. Useful when an object collides with an immovable object. In that case you will want to zero out the
            subpixel remainder since it is null and void due to the collision.
            </summary>
        </member>
        <member name="T:Nez.ColliderTriggerHelper">
            <summary>
            helper class used by the Movers to manage trigger colliders interactions and calling ITriggerListeners.
            </summary>
        </member>
        <member name="F:Nez.ColliderTriggerHelper._activeTriggerIntersections">
            <summary>
            stores all the active intersection pairs that occured in the current frame
            </summary>
        </member>
        <member name="F:Nez.ColliderTriggerHelper._previousTriggerIntersections">
            <summary>
            stores the previous frames intersection pairs so that we can detect exits after moving this frame
            </summary>
        </member>
        <member name="M:Nez.ColliderTriggerHelper.Update">
            <summary>
            update should be called AFTER Entity is moved. It will take care of any ITriggerListeners that the Collider overlaps.
            </summary>
        </member>
        <member name="F:Nez.Physics.AllLayers">
            <summary>
            default value for all methods that accept a layerMask
            </summary>
        </member>
        <member name="F:Nez.Physics.Gravity">
            <summary>
            convenience field for storing a gravity value globally 
            </summary>
        </member>
        <member name="F:Nez.Physics.SpatialHashCellSize">
            <summary>
            cell size used when reset is called and a new SpatialHash is created
            </summary>
        </member>
        <member name="F:Nez.Physics.RaycastsHitTriggers">
            <summary>
            Do raycasts detect Colliders configured as triggers?
            </summary>
        </member>
        <member name="F:Nez.Physics.RaycastsStartInColliders">
            <summary>
            Do ray/line casts that start inside a collider detect those colliders?
            </summary>
        </member>
        <member name="F:Nez.Physics._hitArray">
            <summary>
            we keep this around to avoid allocating it every time a raycast happens
            </summary>
        </member>
        <member name="F:Nez.Physics._colliderArray">
            <summary>
            allocation avoidance for overlap checks and shape casts
            </summary>
        </member>
        <member name="M:Nez.Physics.Clear">
            <summary>
            removes all colliders from the SpatialHash
            </summary>
        </member>
        <member name="M:Nez.Physics.DebugDraw(System.Single)">
            <summary>
            debug draws the contents of the spatial hash. Note that Core.debugRenderEnabled must be true or nothing will be displayed.
            </summary>
            <param name="secondsToDisplay">Seconds to display.</param>
        </member>
        <member name="M:Nez.Physics.GetAllColliders">
            <summary>
            gets all the Colliders managed by the SpatialHash
            </summary>
            <returns>The all colliders.</returns>
        </member>
        <member name="M:Nez.Physics.AddCollider(Nez.Collider)">
            <summary>
            adds the collider to the physics system
            </summary>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Physics.RemoveCollider(Nez.Collider)">
            <summary>
            removes the collider from the physics system
            </summary>
            <returns>The collider.</returns>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Physics.UpdateCollider(Nez.Collider)">
            <summary>
            updates the colliders position in the physics system. This essentially just removes then re-adds the Collider with its
            new bounds
            </summary>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Physics.Linecast(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,System.Int32)">
            <summary>
            casts a line from start to end and returns the first hit of a collider that matches layerMask
            </summary>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.LinecastAll(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Nez.RaycastHit[],System.Int32)">
            <summary>
            casts a line through the spatial hash and fills the hits array up with any colliders that the line hits
            </summary>
            <returns>The all.</returns>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="hits">Hits.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.OverlapRectangle(Nez.RectangleF,System.Int32)">
            <summary>
            check if any collider falls within a rectangular area
            </summary>
            <returns>The rectangle.</returns>
            <param name="rect">Rect.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.OverlapRectangle(Nez.RectangleF@,System.Int32)">
            <summary>
            check if any collider falls within a rectangular area
            </summary>
            <returns>The rectangle.</returns>
            <param name="rect">Rect.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.OverlapRectangleAll(Nez.RectangleF@,Nez.Collider[],System.Int32)">
            <summary>
            gets all the colliders that fall within the specified rect
            </summary>
            <returns>the number of Colliders returned</returns>
            <param name="rect">Rect.</param>
            <param name="results">Results.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.OverlapCircle(Microsoft.Xna.Framework.Vector2,System.Single,System.Int32)">
            <summary>
            check if any collider falls within a circular area. Returns the first Collider encountered.
            </summary>
            <returns>The circle.</returns>
            <param name="center">Center.</param>
            <param name="radius">Radius.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.OverlapCircleAll(Microsoft.Xna.Framework.Vector2,System.Single,Nez.Collider[],System.Int32)">
            <summary>
            gets all the colliders that fall within the specified circle
            </summary>
            <returns>the number of Colliders returned</returns>
            <param name="center">Center.</param>
            <param name="radius">Radius.</param>
            <param name="results">Results.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.BoxcastBroadphase(Nez.RectangleF,System.Int32)">
            <summary>
            returns all colliders with bounds that are intersected by collider.bounds. Note that this is a broadphase check so it
            only checks bounds and does not do individual Collider-to-Collider checks!
            </summary>
            <param name="bounds">Bounds.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.BoxcastBroadphase(Nez.RectangleF@,System.Int32)">
            <summary>
            returns all colliders with bounds that are intersected by collider.bounds. Note that this is a broadphase check so it
            only checks bounds and does not do individual Collider-to-Collider checks!
            </summary>
            <param name="bounds">Bounds.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Physics.BoxcastBroadphaseExcludingSelf(Nez.Collider,System.Int32)">
            <summary>
            returns all colliders with bounds that are intersected by collider.bounds excluding the passed-in collider (self)
            </summary>
            <returns>The neighbors excluding self.</returns>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Physics.BoxcastBroadphaseExcludingSelf(Nez.Collider,Nez.RectangleF@,System.Int32)">
            <summary>
            returns all colliders that are intersected by bounds excluding the passed-in collider (self).
            this method is useful if you want to create the swept bounds on your own for other queries
            </summary>
            <returns>The excluding self.</returns>
            <param name="collider">Collider.</param>
            <param name="bounds">Bounds.</param>
        </member>
        <member name="M:Nez.Physics.BoxcastBroadphaseExcludingSelf(Nez.Collider,System.Single,System.Single,System.Int32)">
            <summary>
            returns all colliders that are intersected by collider.bounds expanded to incorporate deltaX/deltaY
            excluding the passed-in collider (self)
            </summary>
            <returns>The neighbors excluding self.</returns>
            <param name="collider">Collider.</param>
        </member>
        <member name="T:Nez.Ray2D">
            <summary>
            while technically not a ray (rays are just start and direction) it does double duty as both a line and a ray.
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Collider">
            <summary>
            The collider hit by the ray
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Fraction">
            <summary>
            Fraction of the distance along the ray that the hit occurred.
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Distance">
            <summary>
            The distance from the ray origin to the impact point
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Point">
            <summary>
            The point in world space where the ray hit the collider's surface
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Normal">
            <summary>
            The normal vector of the surface hit by the ray
            </summary>
        </member>
        <member name="F:Nez.RaycastHit.Centroid">
            <summary>
            The centroid of the primitive used to perform the cast. Where the shape would be positioned for it to contact.
            </summary>
        </member>
        <member name="T:Nez.PhysicsShapes.Box">
            <summary>
            special case of a Polygon. When doing SAT collision checks we only need to check 2 axes instead of 8
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.Box.BuildBox(System.Single,System.Single)">
            <summary>
            helper that builds the points a Polygon needs in the shape of a box
            </summary>
            <returns>The box.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Box.UpdateBox(System.Single,System.Single)">
            <summary>
            updates the Box points, recalculates the center and sets the width/height
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Circle.RecalculateBounds(System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            internal hack used by Particles so they can reuse a Circle for all collision checks
            </summary>
            <param name="radius">Radius.</param>
            <param name="pos">Position.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Circle.ContainsPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Gets whether or not the provided point lie within the bounds of this <see cref="T:Nez.PhysicsShapes.Circle"/>.
            </summary>
            <param name="point">the point</param>
            <returns><c>true</c> if the provided coordinates lie inside this <see cref="T:Nez.PhysicsShapes.Circle"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.PhysicsShapes.Circle.GetPointAlongEdge(System.Single)">
            <summary>
            Gets the point at the edge of this <see cref="T:Nez.PhysicsShapes.Circle"/> from the provided angle
            </summary>
            <param name="angle">an angle in radians</param>
            <returns><see cref="T:Microsoft.Xna.Framework.Vector2"/> representing the point on this <see cref="T:Nez.PhysicsShapes.Circle"/>'s surface at the specified angle</returns>
        </member>
        <member name="M:Nez.PhysicsShapes.Circle.ContainsPoint(System.Single,System.Single)">
            <summary>
            Gets whether or not the provided coordinates lie within the bounds of this <see cref="T:Nez.PhysicsShapes.Circle"/>.
            </summary>
            <param name="x">The x coordinate of the point to check for containment.</param>
            <param name="y">The y coordinate of the point to check for containment.</param>
            <returns><c>true</c> if the provided coordinates lie inside this <see cref="T:Nez.PhysicsShapes.Circle"/>; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.PhysicsShapes.Circle.ContainsPoint(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Gets whether or not the provided <see cref="T:Microsoft.Xna.Framework.Vector2"/> lies within the bounds of this <see cref="T:Nez.PhysicsShapes.Circle"/>.
            </summary>
            <param name="point">Point.</param>
        </member>
        <member name="F:Nez.PhysicsShapes.Polygon.Points">
            <summary>
            the points that make up the Polygon. They should be CW and convex.
            </summary>
        </member>
        <member name="P:Nez.PhysicsShapes.Polygon.EdgeNormals">
            <summary>
            edge normals are used for SAT collision detection. We cache them to avoid the squareroots. Note that Boxes will only have
            2 edgeNormals since the other two sides are parallel.
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.#ctor(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            constructs a Polygon from points. points should be specified in clockwise fashion without duplicating the first/last point and
            they should be centered around 0,0.
            </summary>
            <param name="points">Points.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.#ctor(System.Int32,System.Single)">
            <summary>
            creates a symmetrical polygon based on the radius and vertCount passed in
            </summary>
            <param name="vertCount">Vert count.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.SetPoints(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            resets the points and recalculates center and edge normals
            </summary>
            <param name="points"></param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.RecalculateCenterAndEdgeNormals">
            <summary>
            recalculates the Polygon centers. This must be called if the points are changed!
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.BuildEdgeNormals">
            <summary>
            builds the Polygon edge normals. These are lazily created and updated only by the edgeNormals getter
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.BuildSymmetricalPolygon(System.Int32,System.Single)">
            <summary>
            builds a symmetrical polygon (hexagon, octogon, n-gon) and returns the points
            </summary>
            <returns>The symmetrical polygon.</returns>
            <param name="vertCount">Vert count.</param>
            <param name="radius">Radius.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.RecenterPolygonVerts(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            recenters the points of the polygon
            </summary>
            <param name="points">Points.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.FindPolygonCenter(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            finds the center of the Polygon. Note that this will be accurate for regular polygons. Irregular polygons have no center.
            </summary>
            <returns>The polygon center.</returns>
            <param name="points">Points.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.GetClosestPointOnPolygonToPoint(Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Vector2,System.Single@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            iterates all the edges of the polygon and gets the closest point on any edge to point. Returns via out the squared distance
            to the closest point and the normal of the edge it is on. point should be in the space of the Polygon (point - poly.position)
            </summary>
            <returns>The closest point on polygon to point.</returns>
            <param name="point">Point.</param>
            <param name="distanceSquared">Distance squared.</param>
            <param name="edgeNormal">Edge normal.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.RotatePolygonVerts(System.Single,Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Vector2[])">
            <summary>
            rotates the originalPoints and copys the rotated values to rotatedPoints
            </summary>
            <param name="radians">Radians.</param>
            <param name="originalPoints">Original points.</param>
            <param name="rotatedPoints">Rotated points.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.Polygon.ContainsPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            essentially what the algorithm is doing is shooting a ray from point out. If it intersects an odd number of polygon sides
            we know it is inside the polygon.
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.BETA.RealtimeCollisions.Corner(Microsoft.Xna.Framework.Rectangle,System.Int32)">
            <summary>
            support function that returns the rectangle vert with index n
            </summary>
            <param name="b">The blue component.</param>
            <param name="n">N.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.BETA.RealtimeCollisions.TestCircleBox(Nez.PhysicsShapes.Circle,Nez.PhysicsShapes.Box,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            checks to see if circle overlaps box and returns (via out param) the point of intersection
            </summary>
            <returns><c>true</c>, if circle box was tested, <c>false</c> otherwise.</returns>
            <param name="circle">Circle.</param>
            <param name="box">Box.</param>
            <param name="point">Point.</param>
        </member>
        <member name="F:Nez.PhysicsShapes.Shape.Position">
            <summary>
            having a separate position field lets us alter the position of the shape for collisions checks as opposed to having to change the
            Entity.position which triggers collider/bounds/hash updates.
            </summary>
        </member>
        <member name="F:Nez.PhysicsShapes.Shape.Center">
            <summary>
            center is kind of a misnomer. This value isnt necessarily the center of an object. It is more accurately the Collider.localOffset
            with any Transform rotations applied
            </summary>
        </member>
        <member name="F:Nez.PhysicsShapes.Shape.Bounds">
            <summary>
            cached bounds for the Shape
            </summary>
        </member>
        <member name="T:Nez.PhysicsShapes.ShapeCollisions">
            <summary>
            various collision routines for Shapes. Most of these expect the first Shape to be in the space of the second (i.e. shape1.pos should
            be set to shape1.pos - shape2.pos).
            </summary>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.Collide(Nez.PhysicsShapes.Shape,Nez.PhysicsShapes.Shape,Microsoft.Xna.Framework.Vector2,Nez.RaycastHit@)">
            <summary>
            swept collision check
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="deltaMovement">Delta movement.</param>
            <param name="hit">Hit.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.BoxToBoxCast(Nez.PhysicsShapes.Box,Nez.PhysicsShapes.Box,Microsoft.Xna.Framework.Vector2,Nez.RaycastHit@)">
            <summary>
            checks the result of a box being moved by deltaMovement with second
            </summary>
            <returns><c>true</c>, if to box cast was boxed, <c>false</c> otherwise.</returns>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <param name="deltaMovement">Delta movement.</param>
            <param name="hit">Hit.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.CircleToBox(Nez.PhysicsShapes.Circle,Nez.PhysicsShapes.Box,Nez.CollisionResult@)">
            <summary>
            works for circles whos center is in the box as well as just overlapping with the center out of the box.
            </summary>
            <returns><c>true</c>, if to box was circled, <c>false</c> otherwise.</returns>
            <param name="circle">First.</param>
            <param name="box">Second.</param>
            <param name="result">Result.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.PolygonToPolygon(Nez.PhysicsShapes.Polygon,Nez.PhysicsShapes.Polygon,Nez.CollisionResult@)">
            <summary>
            checks for a collision between two Polygons
            </summary>
            <returns>The collision.</returns>
            <param name="first">Polygon a.</param>
            <param name="second">Polygon b.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.IntervalDistance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Calculates the distance between [minA, maxA] and [minB, maxB]. The distance will be negative if the intervals overlap
            </summary>
            <returns>The distance.</returns>
            <param name="minA">Minimum a.</param>
            <param name="maxA">Max a.</param>
            <param name="minB">Minimum b.</param>
            <param name="maxB">Max b.</param>
        </member>
        <member name="M:Nez.PhysicsShapes.ShapeCollisions.GetInterval(Microsoft.Xna.Framework.Vector2,Nez.PhysicsShapes.Polygon,System.Single@,System.Single@)">
            <summary>
            Calculates the projection of a polygon on an axis and returns it as a [min, max] interval
            </summary>
            <param name="axis">Axis.</param>
            <param name="polygon">Polygon.</param>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="F:Nez.CollisionResult.Collider">
            <summary>
            the collider that was collided with
            </summary>
        </member>
        <member name="F:Nez.CollisionResult.Normal">
            <summary>
            The normal vector of the surface hit by the shape
            </summary>
        </member>
        <member name="F:Nez.CollisionResult.MinimumTranslationVector">
            <summary>
            The translation to apply to the first shape to push the shapes appart
            </summary>
        </member>
        <member name="F:Nez.CollisionResult.Point">
            <summary>
            not used for all collisions types! Check the ShapeCollisions class before relying on this field!
            </summary>
        </member>
        <member name="M:Nez.CollisionResult.RemoveHorizontalTranslation(Microsoft.Xna.Framework.Vector2)">
            <summary>
            alters the minimumTranslationVector so that it removes the x-component of the translation if there was no movement in
            the same direction.
            </summary>
            <param name="deltaMovement">the original movement that caused the collision</param>
        </member>
        <member name="M:Nez.CollisionResult.InvertResult">
            <summary>
            inverts the normal and MTV
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._cellSize">
            <summary>
            the size of each cell in the hash
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._inverseCellSize">
            <summary>
            1 over the cell size. cached result due to it being used a lot.
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._overlapTestBox">
            <summary>
            cached box used for overlap checks
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._overlapTestCirce">
            <summary>
            cached circle used for overlap checks
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._cellDict">
            <summary>
            the Dictionary that holds all of the data
            </summary>
        </member>
        <member name="F:Nez.Spatial.SpatialHash._tempHashset">
            <summary>
            shared HashSet used to return collision info
            </summary>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.CellCoords(System.Int32,System.Int32)">
            <summary>
            gets the cell x,y values for a world-space x,y value
            </summary>
            <returns>The coords.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.CellCoords(System.Single,System.Single)">
            <summary>
            gets the cell x,y values for a world-space x,y value
            </summary>
            <returns>The coords.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.CellAtPosition(System.Int32,System.Int32,System.Boolean)">
            <summary>
            gets the cell at the world-space x,y value. If the cell is empty and createCellIfEmpty is true a new cell will be created.
            </summary>
            <returns>The at position.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="createCellIfEmpty">If set to <c>true</c> create cell if empty.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.Register(Nez.Collider)">
            <summary>
            adds the object to the SpatialHash
            </summary>
            <param name="collider">Object.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.Remove(Nez.Collider)">
            <summary>
            removes the object from the SpatialHash
            </summary>
            <param name="collider">Collider.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.RemoveWithBruteForce(Nez.Collider)">
            <summary>
            removes the object from the SpatialHash using a brute force approach
            </summary>
            <param name="obj">Object.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.DebugDraw(System.Single,System.Single)">
            <summary>
            debug draws the contents of the spatial hash. Note that Core.debugRenderEnabled must be true or nothing will be displayed.
            </summary>
            <param name="secondsToDisplay">Seconds to display.</param>
            <param name="textScale">Text scale.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.GetAllObjects">
            <summary>
            returns all the Colliders in the SpatialHash
            </summary>
            <returns>The all objects.</returns>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.AabbBroadphase(Nez.RectangleF@,Nez.Collider,System.Int32)">
            <summary>
            returns all objects in cells that the bounding box intersects
            </summary>
            <returns>The neighbors.</returns>
            <param name="bounds">Bounds.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.Linecast(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Nez.RaycastHit[],System.Int32)">
            <summary>
            casts a line through the spatial hash and fills the hits array up with any colliders that the line hits.
            https://github.com/francisengelmann/fast_voxel_traversal/blob/master/main.cpp
            http://www.cse.yorku.ca/~amana/research/grid.pdf
            </summary>
            <returns>the number of Colliders returned</returns>
            <param name="start">Start.</param>
            <param name="end">End.</param>
            <param name="hits">Hits.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.OverlapRectangle(Nez.RectangleF@,Nez.Collider[],System.Int32)">
            <summary>
            gets all the colliders that fall within the specified rect
            </summary>
            <returns>the number of Colliders returned</returns>
            <param name="rect">Rect.</param>
            <param name="results">Results.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <member name="M:Nez.Spatial.SpatialHash.OverlapCircle(Microsoft.Xna.Framework.Vector2,System.Single,Nez.Collider[],System.Int32)">
            <summary>
            gets all the colliders that fall within the specified circle
            </summary>
            <returns>the number of Colliders returned</returns>
            <param name="circleCenter">Circle center.</param>
            <param name="radius">Radius.</param>
            <param name="results">Results.</param>
            <param name="layerMask">Layer mask.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Nez.Spatial.IntIntDictionary" -->
        <member name="M:Nez.Spatial.IntIntDictionary.GetKey(System.Int32,System.Int32)">
            <summary>
            computes and returns a hash key based on the x and y value. basically just packs the 2 ints into a long.
            </summary>
            <returns>The key.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.Spatial.IntIntDictionary.Remove(Nez.Collider)">
            <summary>
            removes the collider from the Lists the Dictionary stores using a brute force approach
            </summary>
            <param name="obj">Object.</param>
        </member>
        <member name="M:Nez.Spatial.IntIntDictionary.GetAllObjects">
            <summary>
            gets all the Colliders currently in the dictionary
            </summary>
            <returns>The all objects.</returns>
        </member>
        <member name="M:Nez.Spatial.IntIntDictionary.Clear">
            <summary>
            clears the backing dictionary
            </summary>
        </member>
        <member name="M:Nez.Spatial.RaycastResultParser.CheckRayIntersection(System.Int32,System.Int32,System.Collections.Generic.List{Nez.Collider})">
            <summary>
            returns true if the hits array gets filled. cell must not be null!
            </summary>
            <returns><c>true</c>, if ray intersection was checked, <c>false</c> otherwise.</returns>
            <param name="ray">Ray.</param>
            <param name="cellX">Cell x.</param>
            <param name="cellY">Cell y.</param>
            <param name="cell">Cell.</param>
            <param name="hits">Hits.</param>
            <param name="hitCounter">Hit counter.</param>
        </member>
        <member name="T:Nez.Verlet.Ball">
            <summary>
            single Particle composite
            </summary>
        </member>
        <member name="T:Nez.Verlet.Box">
            <summary>
            creates a simple box with diagonal contraints to keep it rigid
            </summary>
        </member>
        <member name="M:Nez.Verlet.Cloth.#ctor(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,System.Int32,System.Single,System.Single,System.Boolean)">
            <summary>
            creates a Cloth. If connectHorizontalParticles is false it will not link horizontal Particles and create a hair-like cloth
            </summary>
            <param name="topLeftPosition">Top left position.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="segments">Segments.</param>
            <param name="stiffness">Stiffness.</param>
            <param name="tearSensitivity">Tear sensitivity.</param>
            <param name="connectHorizontalParticles">If set to <c>true</c> connect horizontal particles.</param>
        </member>
        <member name="T:Nez.Verlet.Composite">
            <summary>
            represents an object in the Verlet world. Consists of Particles and Constraints and handles updating them
            </summary>
        </member>
        <member name="F:Nez.Verlet.Composite.Friction">
            <summary>
            friction applied to all Particle movement to dampen it. Value should be very close to 1.
            </summary>
        </member>
        <member name="F:Nez.Verlet.Composite.DrawParticles">
            <summary>
            should Particles be rendered when doing a debugRender?
            </summary>
        </member>
        <member name="F:Nez.Verlet.Composite.DrawConstraints">
            <summary>
            should Constraints be rendered when doing a debugRender?
            </summary>
        </member>
        <member name="F:Nez.Verlet.Composite.CollidesWithLayers">
            <summary>
            layer mask of all the layers this Collider should collide with when Entity.move methods are used. defaults to all layers.
            </summary>
        </member>
        <member name="M:Nez.Verlet.Composite.AddParticle(Nez.Verlet.Particle)">
            <summary>
            adds a Particle to the Composite
            </summary>
            <returns>The particle.</returns>
            <param name="particle">Particle.</param>
        </member>
        <member name="M:Nez.Verlet.Composite.RemoveParticle(Nez.Verlet.Particle)">
            <summary>
            removes the Particle from the Composite
            </summary>
            <param name="particle">Particle.</param>
        </member>
        <member name="M:Nez.Verlet.Composite.RemoveAll">
            <summary>
            removes all Particles and Constraints from the Composite
            </summary>
        </member>
        <member name="M:Nez.Verlet.Composite.AddConstraint``1(``0)">
            <summary>
            adds a Constraint to the Composite
            </summary>
            <returns>The constraint.</returns>
            <param name="constraint">Constraint.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Verlet.Composite.RemoveConstraint(Nez.Verlet.Constraint)">
            <summary>
            removes a Constraint from the Composite
            </summary>
            <param name="constraint">Constraint.</param>
        </member>
        <member name="M:Nez.Verlet.Composite.ApplyForce(Microsoft.Xna.Framework.Vector2)">
            <summary>
            applies a force to all Particles in this Composite
            </summary>
            <param name="force">Force.</param>
        </member>
        <member name="M:Nez.Verlet.Composite.SolveConstraints">
            <summary>
            handles solving all Constraints
            </summary>
        </member>
        <member name="M:Nez.Verlet.Composite.UpdateParticles(System.Single,Microsoft.Xna.Framework.Vector2)">
            <summary>
            applies gravity to each Particle and does the verlet integration
            </summary>
            <param name="deltaTimeSquared">Delta time.</param>
            <param name="gravity">Gravity.</param>
        </member>
        <member name="T:Nez.Verlet.LineSegments">
            <summary>
            a series of points connected with DistanceConstraints
            </summary>
        </member>
        <member name="M:Nez.Verlet.LineSegments.PinParticleAtIndex(System.Int32)">
            <summary>
            pins the Particle at the given index
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="T:Nez.Verlet.Tree">
            <summary>
            fractal tree. Converted from https://github.com/subprotocol/verlet-js/blob/master/examples/tree.html
            </summary>
        </member>
        <member name="T:Nez.Verlet.AngleConstraint">
            <summary>
            constrains 3 particles to an angle
            </summary>
        </member>
        <member name="F:Nez.Verlet.AngleConstraint.Stiffness">
            <summary>
            [0-1]. the stiffness of the Constraint. Lower values are more springy and higher are more rigid.
            </summary>
        </member>
        <member name="F:Nez.Verlet.AngleConstraint.AngleInRadians">
            <summary>
            the angle in radians that the Constraint will attempt to maintain
            </summary>
        </member>
        <member name="F:Nez.Verlet.Constraint.composite">
            <summary>
            the Composite that owns this Constraint. Required so that Constraints can be broken.
            </summary>
        </member>
        <member name="F:Nez.Verlet.Constraint.CollidesWithColliders">
            <summary>
            if true, the Constraint will check for collisions with standard Nez Colliders. Inner Constraints do not need to have this set to
            true.
            </summary>
        </member>
        <member name="M:Nez.Verlet.Constraint.Solve">
            <summary>
            solves the Constraint
            </summary>
        </member>
        <member name="M:Nez.Verlet.Constraint.HandleCollisions(System.Int32)">
            <summary>
            if collidesWithColliders is true this will be called
            </summary>
        </member>
        <member name="M:Nez.Verlet.Constraint.DebugRender(Nez.Batcher)">
            <summary>
            debug renders the Constraint
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="T:Nez.Verlet.DistanceConstraint">
            <summary>
            maintains a specified distance betweeen two Particles. The stiffness adjusts how rigid or springy the constraint will be.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint.Stiffness">
            <summary>
            [0-1]. the stiffness of the Constraint. Lower values are more springy and higher are more rigid.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint.RestingDistance">
            <summary>
            the resting distnace of the Constraint. It will always try to get to this distance.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint.TearSensitivity">
            <summary>
            if the ratio of the current distance / restingDistance is greater than tearSensitivity the Constaint will be removed. Values
            should be above 1 and higher values mean rupture wont occur until the Constaint is stretched further.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint.ShouldApproximateCollisionsWithPoints">
            <summary>
            sets whether collisions should be approximated by points. This should be used for Constraints that need to collided on both
            sides. SAT only works with single sided collisions.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint.TotalPointsToApproximateCollisionsWith">
            <summary>
            if shouldApproximateCollisionsWithPoints is true, this controls how accurate the collisions check will be. Higher numbers mean
            more collisions checks.
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint._particleOne">
            <summary>
            the first Particle in the Constraint
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint._particleTwo">
            <summary>
            the second particle in the Constraint
            </summary>
        </member>
        <member name="F:Nez.Verlet.DistanceConstraint._polygon">
            <summary>
            Polygon shared amongst all DistanceConstraints. Used for collision detection.
            </summary>
        </member>
        <member name="M:Nez.Verlet.DistanceConstraint.Create(Nez.Verlet.Particle,Nez.Verlet.Particle,Nez.Verlet.Particle,System.Single,System.Single)">
            <summary>
            creates a faux angle constraint by figuring out the required distance from a to c for the given angle
            </summary>
            <param name="a">The alpha component.</param>
            <param name="center">Center.</param>
            <param name="c">C.</param>
            <param name="stiffness">Stiffness.</param>
            <param name="angleInDegrees">Angle in degrees.</param>
        </member>
        <member name="M:Nez.Verlet.DistanceConstraint.SetTearSensitivity(System.Single)">
            <summary>
            sets the tear sensitivity. if the ratio of the current distance / restingDistance is greater than tearSensitivity the
            Constaint will be removed
            </summary>
            <returns>The tear sensitvity.</returns>
            <param name="tearSensitivity">Tear sensitivity.</param>
        </member>
        <member name="M:Nez.Verlet.DistanceConstraint.SetCollidesWithColliders(System.Boolean)">
            <summary>
            sets whether this Constraint should collide with standard Colliders
            </summary>
            <returns>The collides with colliders.</returns>
            <param name="collidesWithColliders">If set to <c>true</c> collides with colliders.</param>
        </member>
        <member name="M:Nez.Verlet.DistanceConstraint.SetShouldApproximateCollisionsWithPoints(System.Boolean)">
            <summary>
            sets whether collisions should be approximated by points. This should be used for Constraints that need to collided on both
            sides. SAT only works with single sided collisions.
            </summary>
            <returns>The should approximate collisions with points.</returns>
            <param name="shouldApproximateCollisionsWithPoints">If set to <c>true</c> should approximate collisions with points.</param>
        </member>
        <member name="F:Nez.Verlet.Particle.Position">
            <summary>
            the current position of the Particle
            </summary>
        </member>
        <member name="F:Nez.Verlet.Particle.LastPosition">
            <summary>
            the position of the Particle prior to its latest move
            </summary>
        </member>
        <member name="F:Nez.Verlet.Particle.Mass">
            <summary>
            the mass of the Particle. Taken into account for all forces and constraints
            </summary>
        </member>
        <member name="F:Nez.Verlet.Particle.Radius">
            <summary>
            the radius of the Particle
            </summary>
        </member>
        <member name="F:Nez.Verlet.Particle.CollidesWithColliders">
            <summary>
            if true, the Particle will collide with standard Nez Colliders
            </summary>
        </member>
        <member name="M:Nez.Verlet.Particle.ApplyForce(Microsoft.Xna.Framework.Vector2)">
            <summary>
            applies a force taking mass into account to the Particle
            </summary>
            <param name="force">Force.</param>
        </member>
        <member name="M:Nez.Verlet.Particle.Pin">
            <summary>
            pins the Particle to its current position
            </summary>
        </member>
        <member name="M:Nez.Verlet.Particle.PinTo(Microsoft.Xna.Framework.Vector2)">
            <summary>
            pins the particle to the specified position
            </summary>
            <param name="position">Position.</param>
        </member>
        <member name="M:Nez.Verlet.Particle.Unpin">
            <summary>
            unpins the particle setting it free like the wind
            </summary>
        </member>
        <member name="T:Nez.Verlet.VerletWorld">
            <summary>
            the root of the Verlet simulation. Create a World and call its update method each frame.
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.Gravity">
            <summary>
            gravity for the simulation
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.ConstraintIterations">
            <summary>
            number of iterations that will be used for Constraint solving
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.MaximumStepIterations">
            <summary>
            max number of iterations for the simulation as a whole
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.SimulationBounds">
            <summary>
            Bounds of the Verlet World. Particles will be confined to this space if set.
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.AllowDragging">
            <summary>
            should Particles be allowed to be dragged?
            </summary>
        </member>
        <member name="F:Nez.Verlet.VerletWorld.SelectionRadiusSquared">
            <summary>
            squared selection radius of the mouse pointer
            </summary>
        </member>
        <member name="M:Nez.Verlet.VerletWorld.AddComposite``1(``0)">
            <summary>
            adds a Composite to the simulation
            </summary>
            <returns>The composite.</returns>
            <param name="composite">Composite.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.Verlet.VerletWorld.RemoveComposite(Nez.Verlet.Composite)">
            <summary>
            removes a Composite from the simulation
            </summary>
            <param name="composite">Composite.</param>
        </member>
        <member name="M:Nez.Verlet.VerletWorld.GetNearestParticle(Microsoft.Xna.Framework.Vector2)">
            <summary>
            gets the nearest Particle to the position. Uses the selectionRadiusSquared to determine if a Particle is near enough for consideration.
            </summary>
            <returns>The nearest particle.</returns>
            <param name="position">Position.</param>
        </member>
        <member name="T:Nez.UI.AlignInternal">
            <summary>
            used internally so that alignment can be stored as an int and can have an unlimited number of options by just setting it outside
            the bounds of the flags
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.GetElement``1">
            <summary>
            Returns the element for this cell casted to T, or null.
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Nez.UI.Cell.HasElement">
            <summary>
            Returns true if the cell's element is not null.
            </summary>
            <returns><c>true</c>, if element was hased, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Cell.SetElement(Nez.UI.Element)">
            <summary>
            Sets the element in this cell and adds the element to the cell's table. If null, removes any current element.
            </summary>
            <returns>The element.</returns>
            <param name="newelement">New element.</param>
        </member>
        <member name="M:Nez.UI.Cell.ClearElement">
            <summary>
            Removes the current element for the cell, if any.
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Nez.UI.Cell.Size(Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified value.
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.Size(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified values.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.Size(System.Single)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified value.
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.Size(System.Single,System.Single)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified values.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.Width(Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, and maxWidth to the specified value.
            </summary>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.UI.Cell.Width(System.Single)">
            <summary>
            Sets the minWidth, prefWidth, and maxWidth to the specified value.
            </summary>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.UI.Cell.Height(Nez.UI.Value)">
            <summary>
            Sets the minHeight, prefHeight, and maxHeight to the specified value.
            </summary>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.Height(System.Single)">
            <summary>
            Sets the minHeight, prefHeight, and maxHeight to the specified value.
            </summary>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.MinSize(Nez.UI.Value)">
            <summary>
            Sets the minWidth and minHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.MinSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the minWidth and minHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.MinSize(System.Single)">
            <summary>
            Sets the minWidth and minHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.MinSize(System.Single,System.Single)">
            <summary>
            Sets the minWidth and minHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.PrefSize(Nez.UI.Value)">
            <summary>
            Sets the prefWidth and prefHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.PrefSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the prefWidth and prefHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.PrefSize(System.Single,System.Single)">
            <summary>
            Sets the prefWidth and prefHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.PrefSize(System.Single)">
            <summary>
            Sets the prefWidth and prefHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.MaxSize(Nez.UI.Value)">
            <summary>
            Sets the maxWidth and maxHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.MaxSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the maxWidth and maxHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.MaxSize(System.Single)">
            <summary>
            Sets the maxWidth and maxHeight to the specified value.
            </summary>
            <returns>The size.</returns>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Cell.MaxSize(System.Single,System.Single)">
            <summary>
            Sets the maxWidth and maxHeight to the specified values.
            </summary>
            <returns>The size.</returns>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Cell.Space(Nez.UI.Value)">
            <summary>
            Sets the spaceTop, spaceLeft, spaceBottom, and spaceRight to the specified value.
            </summary>
            <param name="space">Space.</param>
        </member>
        <member name="M:Nez.UI.Cell.Space(System.Single)">
            <summary>
            Sets the spaceTop, spaceLeft, spaceBottom, and spaceRight to the specified value.
            </summary>
            <param name="space">Space.</param>
        </member>
        <member name="M:Nez.UI.Cell.Pad(Nez.UI.Value)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value.
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Cell.Pad(System.Single)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value.
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Cell.Fill">
            <summary>
            Sets fillX and fillY to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.SetFillX">
            <summary>
            Sets fillX to 1
            </summary>
            <returns>The fill x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.SetFillY">
            <summary>
            Sets fillY to 1
            </summary>
            <returns>The fill y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.Fill(System.Boolean,System.Boolean)">
            <summary>
            Sets fillX and fillY to 1 if true, 0 if false.
            </summary>
            <param name="x">If set to <c>true</c> x.</param>
            <param name="y">If set to <c>true</c> y.</param>
        </member>
        <member name="M:Nez.UI.Cell.Fill(System.Boolean)">
            <summary>
            Sets fillX and fillY to 1 if true, 0 if false.
            </summary>
            <param name="fill">If set to <c>true</c> fill.</param>
        </member>
        <member name="M:Nez.UI.Cell.SetAlign(Nez.UI.Align)">
            <summary>
            Sets the alignment of the element within the cell. Set to {@link Align#center}, {@link Align#top}, {@link Align#bottom},
            {@link Align#left}, {@link Align#right}, or any combination of those.
            </summary>
            <returns>The align.</returns>
            <param name="align">Align.</param>
        </member>
        <member name="M:Nez.UI.Cell.Center">
            <summary>
            Sets the alignment of the element within the cell to {@link Align#center}. This clears any other alignment.
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Top">
            <summary>
            Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the element within the cell.
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Left">
            <summary>
            Adds {@link Align#left} and clears {@link Align#right} for the alignment of the element within the cell
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Bottom">
            <summary>
            Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the element within the cell
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Right">
            <summary>
            Adds {@link Align#right} and clears {@link Align#left} for the alignment of the element within the cell
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Grow">
            <summary>
            Sets expandX, expandY, fillX, and fillY to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.GrowX">
            <summary>
            Sets expandX and fillX to 1
            </summary>
            <returns>The x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GrowY">
            <summary>
            Sets expandY and fillY to 1
            </summary>
            <returns>The y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.Expand">
            <summary>
            Sets expandX and expandY to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.SetExpandX">
            <summary>
            Sets expandX to 1
            </summary>
            <returns>The expand x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.SetExpandY">
            <summary>
            Sets expandY to 1
            </summary>
            <returns>The expand y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.Expand(System.Boolean,System.Boolean)">
            <summary>
            Sets expandX and expandY to 1 if true, 0 if false
            </summary>
            <param name="x">If set to <c>true</c> x.</param>
            <param name="y">If set to <c>true</c> y.</param>
        </member>
        <member name="M:Nez.UI.Cell.Uniform">
            <summary>
            Sets uniformX and uniformY to true
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.SetUniformX">
            <summary>
            Sets uniformX to true
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.SetUniformY">
            <summary>
            Sets uniformY to true
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.GetMinWidthValue">
            <summary>
            May be null if this cell is row defaults.
            </summary>
            <returns>The minimum width value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetMinHeightValue">
            <summary>
            May be null if this cell is row defaults
            </summary>
            <returns>The minimum height value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPrefWidthValue">
            <summary>
            May be null if this cell is row defaults.
            </summary>
            <returns>The preference width value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPrefHeightValue">
            <summary>
            May be null if this cell is row defaults.
            </summary>
            <returns>The preference height value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetMaxWidthValue">
            <summary>
            May be null if this cell is row defaults
            </summary>
            <returns>The max width value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetMaxHeightValue">
            <summary>
            May be null if this cell is row defaults
            </summary>
            <returns>The max height value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetSpaceTopValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The space top value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetSpaceLeftValue">
            <summary>
            May be null if this value is not set.
            </summary>
            <returns>The space left value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetSpaceBottomValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The space bottom value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetSpaceRightValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The space right value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadTopValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad top value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadLeftValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad left value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadBottomValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad bottom value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadRightValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad right value.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadX">
            <summary>
            Returns {@link #getPadLeft()} plus {@link #getPadRight()}
            </summary>
            <returns>The pad x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetPadY">
            <summary>
            Returns {@link #getPadTop()} plus {@link #getPadBottom()}
            </summary>
            <returns>The pad y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetFillX">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The fill x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetFillY">
            <summary>
            May be null
            </summary>
            <returns>The fill y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetAlign">
            <summary>
            May be null
            </summary>
            <returns>The align.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetExpandX">
            <summary>
            May be null
            </summary>
            <returns>The expand x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetExpandY">
            <summary>
            May be null
            </summary>
            <returns>The expand y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetColspan">
            <summary>
            May be null
            </summary>
            <returns>The colspan.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetUniformX">
            <summary>
            May be null
            </summary>
            <returns>The uniform x.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetUniformY">
            <summary>
            May be null
            </summary>
            <returns>The uniform y.</returns>
        </member>
        <member name="M:Nez.UI.Cell.IsEndRow">
            <summary>
            May be null
            </summary>
            <returns><c>true</c>, if end row was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetComputedPadTop">
            <summary>
            The actual amount of combined padding and spacing from the last layout.
            </summary>
            <returns>The computed pad top.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetComputedPadLeft">
            <summary>
            The actual amount of combined padding and spacing from the last layout.
            </summary>
            <returns>The computed pad left.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetComputedPadBottom">
            <summary>
            The actual amount of combined padding and spacing from the last layout
            </summary>
            <returns>The computed pad bottom.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetComputedPadRight">
            <summary>
            The actual amount of combined padding and spacing from the last layout
            </summary>
            <returns>The computed pad right.</returns>
        </member>
        <member name="M:Nez.UI.Cell.GetDefaults">
            <summary>
            Returns the defaults to use for all cells. This can be used to avoid needing to set the same defaults for every table (eg,
            for spacing).
            </summary>
            <returns>The defaults.</returns>
        </member>
        <member name="M:Nez.UI.Cell.Clear">
            <summary>
            Sets all constraint fields to null
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Reset">
            <summary>
            Reset state so the cell can be reused, setting all constraints to their {@link #defaults() default} values.
            </summary>
        </member>
        <member name="M:Nez.UI.Cell.Merge(Nez.UI.Cell)">
            <summary>
            cell may be null
            </summary>
            <param name="cell">Cell.</param>
        </member>
        <member name="P:Nez.UI.Element.NeedsLayout">
            <summary>
            true if the widget's layout has been {@link #invalidate() invalidated}.
            </summary>
            <value><c>true</c> if needs layout; otherwise, <c>false</c>.</value>
        </member>
        <member name="F:Nez.UI.Element.UserData">
            <summary>
            use this to stuff any relevant data required for your UI setup
            </summary>
        </member>
        <member name="M:Nez.UI.Element.Draw(Nez.Batcher,System.Single)">
            <summary>
            If this method is overridden, the super method or {@link #validate()} should be called to ensure the widget is laid out.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="parentAlpha">Parent alpha.</param>
        </member>
        <member name="M:Nez.UI.Element.GetStage">
            <summary>
            Returns the stage that this element is currently in, or null if not in a stage.
            </summary>
            <returns>The stage.</returns>
        </member>
        <member name="M:Nez.UI.Element.SetStage(Nez.UI.Stage)">
            <summary>
            Called by the framework when this element or any parent is added to a group that is in the stage.
            stage May be null if the element or any parent is no longer in a stage
            </summary>
            <param name="stage">Stage.</param>
        </member>
        <member name="M:Nez.UI.Element.HasParent">
            <summary>
            Returns true if the element's parent is not null
            </summary>
            <returns><c>true</c>, if parent was hased, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Element.GetParent">
            <summary>
            Returns the parent element, or null if not in a group
            </summary>
            <returns>The parent.</returns>
        </member>
        <member name="M:Nez.UI.Element.SetParent(Nez.UI.Group)">
            <summary>
            Called by the framework when an element is added to or removed from a group.
            </summary>
            <param name="newParent">parent May be null if the element has been removed from the parent</param>
        </member>
        <member name="M:Nez.UI.Element.IsTouchable">
            <summary>
            Returns true if input events are processed by this element.
            </summary>
            <returns>The touchable.</returns>
        </member>
        <member name="M:Nez.UI.Element.SetTouchable(Nez.UI.Touchable)">
            <summary>
            Determines how touch events are distributed to this element. Default is {@link Touchable#enabled}.
            </summary>
            <param name="touchable">Touchable.</param>
        </member>
        <member name="M:Nez.UI.Element.SetVisible(System.Boolean)">
            <summary>
            If false, the element will not be drawn and will not receive touch events. Default is true.
            </summary>
            <param name="visible">Visible.</param>
        </member>
        <member name="M:Nez.UI.Element.GetX">
            <summary>
            Returns the X position of the element's left edge
            </summary>
            <returns>The x.</returns>
        </member>
        <member name="M:Nez.UI.Element.GetX(System.Int32)">
            <summary>
            Returns the X position of the specified {@link Align alignment}.
            </summary>
            <returns>The x.</returns>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.Element.GetY">
            <summary>
            Returns the Y position of the element's bottom edge
            </summary>
            <returns>The y.</returns>
        </member>
        <member name="M:Nez.UI.Element.GetY(System.Int32)">
            <summary>
            Returns the Y position of the specified {@link Align alignment}
            </summary>
            <returns>The y.</returns>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.Element.SetPosition(System.Single,System.Single)">
            <summary>
            Sets the position of the element's bottom left corner
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.Element.SetPosition(System.Single,System.Single,System.Int32)">
            <summary>
            Sets the position using the specified {@link Align alignment}. Note this may set the position to non-integer coordinates
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.Element.MoveBy(System.Single,System.Single)">
            <summary>
            Add x and y to current position
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.Element.GetBottom">
            <summary>
            Returns y plus height
            </summary>
            <returns>The top.</returns>
        </member>
        <member name="M:Nez.UI.Element.GetRight">
            <summary>
            Returns x plus width
            </summary>
            <returns>The right.</returns>
        </member>
        <member name="M:Nez.UI.Element.SetBounds(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the x, y, width, and height.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Element.SetOrigin(System.Single,System.Single)">
            <summary>
            Sets the origin position which is relative to the element's bottom left corner
            </summary>
            <param name="originX">Origin x.</param>
            <param name="originY">Origin y.</param>
        </member>
        <member name="M:Nez.UI.Element.SetOrigin(System.Int32)">
            <summary>
            Sets the origin position to the specified {@link Align alignment}.
            </summary>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.Element.SetScale(System.Single)">
            <summary>
            Sets the scale for both X and Y
            </summary>
            <param name="scaleXY">Scale X.</param>
        </member>
        <member name="M:Nez.UI.Element.SetScale(System.Single,System.Single)">
            <summary>
            Sets the scale X and scale Y
            </summary>
            <param name="scaleX">Scale x.</param>
            <param name="scaleY">Scale y.</param>
        </member>
        <member name="M:Nez.UI.Element.ScaleBy(System.Single)">
            <summary>
            Adds the specified scale to the current scale
            </summary>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.UI.Element.ScaleBy(System.Single,System.Single)">
            <summary>
            Adds the specified scale to the current scale
            </summary>
            <param name="scaleX">Scale x.</param>
            <param name="scaleY">Scale y.</param>
        </member>
        <member name="M:Nez.UI.Element.RotateBy(System.Single)">
            <summary>
            Adds the specified rotation to the current rotation
            </summary>
            <param name="amountInDegrees">Amount in degrees.</param>
        </member>
        <member name="M:Nez.UI.Element.GetColor">
            <summary>
            Returns the color the element will be tinted when drawn
            </summary>
            <returns>The color.</returns>
        </member>
        <member name="M:Nez.UI.Element.ToFront">
            <summary>
            Changes the z-order for this element so it is in front of all siblings
            </summary>
        </member>
        <member name="M:Nez.UI.Element.ToBack">
            <summary>
            Changes the z-order for this element so it is in back of all siblings
            </summary>
        </member>
        <member name="M:Nez.UI.Element.SetZIndex(System.Int32)">
            <summary>
            Sets the z-index of this element. The z-index is the index into the parent's {@link Group#getChildren() children}, where a
            lower index is below a higher index. Setting a z-index higher than the number of children will move the child to the front.
            Setting a z-index less than zero is invalid.
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.UI.Element.ClipBegin(Nez.Batcher)">
            <summary>
            Calls clipBegin(Batcher, float, float, float, float) to clip this actor's bounds
            </summary>
            <returns>The begin.</returns>
        </member>
        <member name="M:Nez.UI.Element.ClipBegin(Nez.Batcher,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Clips the specified screen aligned rectangle, specified relative to the transform matrix of the stage's Batch. The
            transform matrix and the stage's camera must not have rotational components. Calling this method must be followed by a call
            to clipEnd() if true is returned.
            </summary>
        </member>
        <member name="M:Nez.UI.Element.ClipEnd(Nez.Batcher)">
            <summary>
            Ends clipping begun by clipBegin(Batcher, float, float, float, float)
            </summary>
            <returns>The end.</returns>
        </member>
        <member name="M:Nez.UI.Element.SetDebug(System.Boolean)">
            <summary>
            If true, {@link #debugDraw} will be called for this element
            </summary>
            <param name="enabled">Enabled.</param>
        </member>
        <member name="M:Nez.UI.Element.ScreenToLocalCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the specified point in screen coordinates to the element's local coordinate system
            </summary>
            <returns>The to local coordinates.</returns>
            <param name="screenCoords">Screen coords.</param>
        </member>
        <member name="M:Nez.UI.Element.StageToLocalCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the specified point in the stage's coordinates to the element's local coordinate system.
            </summary>
            <returns>The to local coordinates.</returns>
            <param name="stageCoords">Stage coords.</param>
        </member>
        <member name="M:Nez.UI.Element.LocalToStageCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the specified point in the element's coordinates to be in the stage's coordinates
            </summary>
            <returns>The to stage coordinates.</returns>
            <param name="localCoords">Local coords.</param>
        </member>
        <member name="M:Nez.UI.Element.LocalToAscendantCoordinates(Nez.UI.Element,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Converts coordinates for this element to those of a parent element. The ascendant does not need to be a direct parent
            </summary>
            <returns>The to ascendant coordinates.</returns>
            <param name="ascendant">Ascendant.</param>
            <param name="localCoords">Local coords.</param>
        </member>
        <member name="M:Nez.UI.Element.ParentToLocalCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Converts the coordinates given in the parent's coordinate system to this element's coordinate system.
            </summary>
            <returns>The to local coordinates.</returns>
            <param name="parentCoords">Parent coords.</param>
        </member>
        <member name="M:Nez.UI.Element.LocalToParentCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the specified point in the element's coordinates to be in the parent's coordinates.
            </summary>
            <returns>The to parent coordinates.</returns>
            <param name="localCoords">Local coords.</param>
        </member>
        <member name="M:Nez.UI.Element.DistanceOutsideBoundsToPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the distance from point to the bounds of element in the largest dimension or a negative number if the point is inside the bounds.
            Note that point should be in the element's coordinate system already.
            </summary>
            <returns>The outside bounds to point.</returns>
            <param name="Point">Point.</param>
        </member>
        <member name="M:Nez.UI.Element.DebugRender(Nez.Batcher)">
            <summary>
            Draws this element's debug lines
            </summary>
            <param name="batcher">Batcher.</param>
        </member>
        <member name="M:Nez.UI.Element.AreParentsVisible">
            <summary>
            returns true if this Element and all parent Elements are visible
            </summary>
            <returns><c>true</c>, if parents visible was ared, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Element.Remove">
            <summary>
            Removes this element from its parent, if it has a parent
            </summary>
        </member>
        <member name="M:Nez.UI.Group.GetChildren">
            <summary>
            Returns an ordered list of child elements in this group
            </summary>
            <returns>The children.</returns>
        </member>
        <member name="M:Nez.UI.Group.SetStage(Nez.UI.Stage)">
            <summary>
            sets the stage on all children in case the Group is added to the Stage after it is configured
            </summary>
            <param name="stage">Stage.</param>
        </member>
        <member name="M:Nez.UI.Group.Clear">
            <summary>
            Removes all children
            </summary>
        </member>
        <member name="M:Nez.UI.Group.ClearChildren">
            <summary>
            Removes all elements from this group
            </summary>
        </member>
        <member name="M:Nez.UI.Group.OnChildrenChanged">
            <summary>
            Called when elements are added to or removed from the group.
            </summary>
        </member>
        <member name="M:Nez.UI.Group.ComputeTransform">
            <summary>
            Returns the transform for this group's coordinate system
            </summary>
            <returns>The transform.</returns>
        </member>
        <member name="M:Nez.UI.Group.ApplyTransform(Nez.Batcher,Microsoft.Xna.Framework.Matrix)">
            <summary>
            Set the batch's transformation matrix, often with the result of {@link #computeTransform()}. Note this causes the batch to
            be flushed. {@link #resetTransform(Batch)} will restore the transform to what it was before this call.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="transform">Transform.</param>
        </member>
        <member name="M:Nez.UI.Group.ResetTransform(Nez.Batcher)">
            <summary>
            Restores the batch transform to what it was before {@link #applyTransform(Batch, Matrix4)}. Note this causes the batch to
            be flushed
            </summary>
            <param name="batch">Batch.</param>
        </member>
        <member name="M:Nez.UI.Group.SetDebug(System.Boolean,System.Boolean)">
            <summary>
            If true, drawDebug() will be called for this group and, optionally, all children recursively.
            </summary>
            <param name="enabled">If set to <c>true</c> enabled.</param>
            <param name="recursively">If set to <c>true</c> recursively.</param>
        </member>
        <member name="M:Nez.UI.Group.DebugAll">
            <summary>
            Calls {setDebug(true, true)
            </summary>
            <returns>The all.</returns>
        </member>
        <member name="T:Nez.UI.IGamepadFocusable">
            <summary>
            interface applied to any Element that wants to take part in gamepad focus. By default, the Button class implements this which cascades
            down to Checkbox and TextButton. When using the properties you must set shouldUseExplicitFocusableControl to true. If you want a direction
            to not change focus make that direction null. If shouldUseExplicitFocusableControl the Stage will attempt to find the next focusable
            in the direction pressed.
            </summary>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.EnableExplicitFocusableControl(Nez.UI.IGamepadFocusable,Nez.UI.IGamepadFocusable,Nez.UI.IGamepadFocusable,Nez.UI.IGamepadFocusable)">
            <summary>
            enables shouldUseExplicitFocusableControl and sets the elements corresponding to each direction
            </summary>
            <param name="upEle">Up ele.</param>
            <param name="downEle">Down ele.</param>
            <param name="leftEle">Left ele.</param>
            <param name="rightEle">Right ele.</param>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.OnUnhandledDirectionPressed(Nez.UI.Direction)">
            <summary>
            called only when the following conditions are met:
            - shouldUseExplicitFocusableControl is true
            - this Element is focused
            - a gamepad direction was pressed with a null gamepadDIRECTIONElement
            </summary>
            <param name="direction">Direction.</param>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.OnFocused">
            <summary>
            called when gamepad focuses on the Element
            </summary>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.OnUnfocused">
            <summary>
            called when gamepad focus is removed from the Element
            </summary>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.OnActionButtonPressed">
            <summary>
            called when the action button is pressed while the Element is focused
            </summary>
        </member>
        <member name="M:Nez.UI.IGamepadFocusable.OnActionButtonReleased">
            <summary>
            called when the action button is released while the Element is focused
            </summary>
        </member>
        <member name="M:Nez.UI.IInputListener.OnLeftMousePressed(Microsoft.Xna.Framework.Vector2)">
            <summary>
            if true is returned then onMouseDown/Up will be called else they will not be called
            </summary>
            <returns><c>true</c>, if mouse pressed was oned, <c>false</c> otherwise.</returns>
            <param name="mousePos">Mouse position.</param>
        </member>
        <member name="M:Nez.UI.IInputListener.OnRightMousePressed(Microsoft.Xna.Framework.Vector2)">
            <summary>
            if true is returned then onMouseDown/Up will be called else they will not be called
            </summary>
            <returns><c>true</c>, if right mouse pressed was oned, <c>false</c> otherwise.</returns>
            <param name="mousePos">Mouse position.</param>
        </member>
        <member name="M:Nez.UI.IInputListener.OnMouseMoved(Microsoft.Xna.Framework.Vector2)">
            <summary>
            called when the mouse moves only on an element that returned true for onMousePressed. It is safe to call stage.removeInputFocusListener
            here if you are uninterested in the onMouseUp event.
            </summary>
            <param name="mousePos">Mouse position.</param>
        </member>
        <member name="M:Nez.UI.IInputListener.OnLeftMouseUp(Microsoft.Xna.Framework.Vector2)">
            <summary>
            called when the left mouse button is released
            </summary>
            <param name="mousePos">Mouse position.</param>
        </member>
        <member name="M:Nez.UI.IInputListener.OnRightMouseUp(Microsoft.Xna.Framework.Vector2)">
            <summary>
            called when the right mouse button is released
            </summary>
            <param name="mousePos">Mouse position.</param>
        </member>
        <member name="M:Nez.UI.IInputListener.OnMouseScrolled(System.Int32)">
            <summary>
            if true is returned the scroll event will be consumed by the Element
            </summary>
            <returns>The mouse scrolled.</returns>
        </member>
        <member name="M:Nez.UI.IKeyboardListener.KeyDown(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            called when a key is first pressed
            </summary>
            <param name="key">Key.</param>
        </member>
        <member name="M:Nez.UI.IKeyboardListener.KeyPressed(Microsoft.Xna.Framework.Input.Keys,System.Char)">
            <summary>
            called the same frame as keyDown and for repeating keys (key held down). This is only called for non-modifier keys.
            </summary>
            <param name="key">Key.</param>
        </member>
        <member name="M:Nez.UI.IKeyboardListener.KeyReleased(Microsoft.Xna.Framework.Input.Keys)">
            <summary>
            called when a key is released
            </summary>
            <param name="key">Key.</param>
        </member>
        <member name="M:Nez.UI.IKeyboardListener.GainedFocus">
            <summary>
            called when keyboard focus is gained
            </summary>
        </member>
        <member name="M:Nez.UI.IKeyboardListener.LostFocus">
            <summary>
            called when keyboard focus is lost
            </summary>
        </member>
        <member name="T:Nez.UI.ILayout">
            <summary>
            Provides methods for an element to participate in layout and to provide a minimum, preferred, and maximum size.
            </summary>
        </member>
        <member name="P:Nez.UI.ILayout.FillParent">
            <summary>
            If true, this element will be sized to the parent in {@link #validate()}. If the parent is the stage, the element will be sized 
            to the stage. This method is for convenience only when the widget's parent does not set the size of its children (such as
            the stage).
            </summary>
            <value><c>true</c> if fill parent; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.UI.ILayout.LayoutEnabled">
            <summary>
            Enables or disables the layout for this element and all child elements, recursively. When false, {@link #validate()} will not
            cause a layout to occur. This can be useful when an element will be manipulated externally, such as with actions.
            Default is true.
            </summary>
            <value><c>true</c> if layout enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.UI.ILayout.MaxWidth">
            <summary>
            Zero indicates no max width
            </summary>
            <value>The width of the max.</value>
        </member>
        <member name="P:Nez.UI.ILayout.MaxHeight">
            <summary>
            Zero indicates no max height
            </summary>
            <value>The height of the max.</value>
        </member>
        <member name="M:Nez.UI.ILayout.Layout">
            <summary>
            Computes and caches any information needed for drawing and, if this element has children, positions and sizes each child, 
            calls {@link #invalidate()} any each child whose width or height has changed, and calls {@link #validate()} on each child.
            This method should almost never be called directly, instead {@link #validate()} should be used
            </summary>
        </member>
        <member name="M:Nez.UI.ILayout.Invalidate">
            <summary>
            Invalidates this element's layout, causing {@link #layout()} to happen the next time {@link #validate()} is called. This
            method should be called when state changes in the element that requires a layout but does not change the minimum, preferred,
            maximum, or actual size of the element (meaning it does not affect the parent element's layout).
            </summary>
        </member>
        <member name="M:Nez.UI.ILayout.InvalidateHierarchy">
            <summary>
            Invalidates this element and all its parents, calling {@link #invalidate()} on each. This method should be called when state
            changes in the element that affects the minimum, preferred, maximum, or actual size of the element (meaning it it potentially
            affects the parent element's layout).
            </summary>
        </member>
        <member name="M:Nez.UI.ILayout.Validate">
            <summary>
            Ensures the element has been laid out. Calls {@link #layout()} if {@link #invalidate()} has been called since the last time
            {@link #validate()} was called, or if the element otherwise needs to be laid out. This method is usually called in
            {@link element#draw(Batch, float)} before drawing is performed.
            </summary>
        </member>
        <member name="M:Nez.UI.ILayout.Pack">
            <summary>
            Sizes this element to its preferred width and height, then calls {@link #validate()}.
            Generally this method should not be called in an element's constructor because it calls {@link #layout()}, which means a
            subclass would have layout() called before the subclass' constructor. Instead, in constructors simply set the element's size
            to {@link #getPrefWidth()} and {@link #getPrefHeight()}. This allows the element to have a size at construction time for more
            convenient use with groups that do not layout their children.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.Fit">
            <summary>
            Scales the source to fit the target while keeping the same aspect ratio. This may cause the source to be smaller than the
            target in one direction
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.Fill">
            <summary>
            Scales the source to fill the target while keeping the same aspect ratio. This may cause the source to be larger than the
            target in one direction.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.FillX">
            <summary>
            Scales the source to fill the target in the x direction while keeping the same aspect ratio. This may cause the source to be
            smaller or larger than the target in the y direction.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.FillY">
            <summary>
            Scales the source to fill the target in the y direction while keeping the same aspect ratio. This may cause the source to be
            smaller or larger than the target in the x direction.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.Stretch">
            <summary>
            Scales the source to fill the target. This may cause the source to not keep the same aspect ratio.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.StretchX">
            <summary>
            Scales the source to fill the target in the x direction, without changing the y direction. This may cause the source to not
            keep the same aspect ratio.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.StretchY">
            <summary>
            Scales the source to fill the target in the y direction, without changing the x direction. This may cause the source to not
            keep the same aspect ratio.
            </summary>
        </member>
        <member name="F:Nez.UI.Scaling.None">
            <summary>
            The source is not scaled.
            </summary>
        </member>
        <member name="M:Nez.UI.ScalingExt.Apply(Nez.UI.Scaling,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Returns the size of the source scaled to the target
            </summary>
            <param name="self">Self.</param>
            <param name="sourceWidth">Source width.</param>
            <param name="sourceHeight">Source height.</param>
            <param name="targetWidth">Target width.</param>
            <param name="targetHeight">Target height.</param>
        </member>
        <member name="F:Nez.UI.Touchable.Enabled">
            <summary>
            All touch input events will be received by the element and any children.
            </summary>
        </member>
        <member name="F:Nez.UI.Touchable.Disabled">
            <summary>
            No touch input events will be received by the element or any children.
            </summary>
        </member>
        <member name="F:Nez.UI.Touchable.ChildrenOnly">
            <summary>
            No touch input events will be received by the element, but children will still receive events. Note that events on the
            children will still bubble to the parent.
            </summary>
        </member>
        <member name="T:Nez.UI.Value">
            <summary>
            Value placeholder, allowing the value to be computed on request. Values are provided an element for context which reduces the
            number of value instances that need to be created and reduces verbosity in code that specifies values
            </summary>
        </member>
        <member name="M:Nez.UI.Value.Get(Nez.UI.Element)">
            <summary>
            context May be null
            </summary>
            <param name="context">Context.</param>
        </member>
        <member name="F:Nez.UI.Value.Zero">
            <summary>
            A value that is always zero.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.Fixed">
            <summary>
            A fixed value that is not computed each time it is used.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.MinWidthValue">
            <summary>
            Value that is the minWidth of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.MinHeightValue">
            <summary>
            Value that is the minHeight of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PrefWidthValue">
            <summary>
            Value that is the prefWidth of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PrefHeightValue">
            <summary>
            Value that is the prefHeight of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.MaxWidthValue">
            <summary>
            Value that is the maxWidth of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.MaxHeightValue">
            <summary>
            Value that is the maxHeight of the element in the cell.
            </summary>
        </member>
        <member name="M:Nez.UI.Value.PercentWidth(System.Single)">
            <summary>
            Value that is the maxHeight of the element in the cell.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PercentWidthValue">
            <summary>
            Returns a value that is a percentage of the element's width.
            </summary>
        </member>
        <member name="M:Nez.UI.Value.PercentWidth(System.Single,Nez.UI.Element)">
            <summary>
            Returns a value that is a percentage of the specified elements's width. The context element is ignored.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PercentWidthDelegateValue">
            <summary>
            Returns a value that is a percentage of the specified elements's width. The context element is ignored.
            </summary>
        </member>
        <member name="M:Nez.UI.Value.PercentHeight(System.Single)">
            <summary>
            Returns a value that is a percentage of the element's height.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PercentageHeightValue">
            <summary>
            Returns a value that is a percentage of the element's height.
            </summary>
        </member>
        <member name="M:Nez.UI.Value.PercentHeight(System.Single,Nez.UI.Element)">
            <summary>
            Returns a value that is a percentage of the specified elements's height. The context element is ignored.
            </summary>
        </member>
        <member name="T:Nez.UI.Value.PercentHeightDelegateValue">
            <summary>
            Returns a value that is a percentage of the specified elements's height. The context element is ignored.
            </summary>
        </member>
        <member name="T:Nez.UI.Container">
            <summary>
            A group with a single child that sizes and positions the child using constraints. This provides layout similar to a
            {@link Table} with a single cell but is more lightweight.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.#ctor">
            <summary>
            Creates a container with no element
            </summary>
        </member>
        <member name="M:Nez.UI.Container.DrawBackground(Nez.Batcher,System.Single,System.Single,System.Single)">
            <summary>
            Called to draw the background, before clipping is applied (if enabled). Default implementation draws the background drawable.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="parentAlpha">Parent alpha.</param>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.Container.SetBackground(Nez.UI.IDrawable)">
            <summary>
            Sets the background drawable and adjusts the container's padding to match the background.
            </summary>
            <param name="background">Background.</param>
        </member>
        <member name="M:Nez.UI.Container.SetBackground(Nez.UI.IDrawable,System.Boolean)">
            <summary>
            Sets the background drawable and, if adjustPadding is true, sets the container's padding to
            {@link Drawable#getBottomHeight()} , {@link Drawable#getTopHeight()}, {@link Drawable#getLeftWidth()}, and
            {@link Drawable#getRightWidth()}.
            If background is null, the background will be cleared and padding removed.
            </summary>
            <param name="background">Background.</param>
            <param name="adjustPadding">If set to <c>true</c> adjust padding.</param>
        </member>
        <member name="M:Nez.UI.Container.SetElement(Nez.UI.Element)">
            <summary>
            element may be null
            </summary>
            <returns>The element.</returns>
            <param name="element">element.</param>
        </member>
        <member name="M:Nez.UI.Container.GetElement``1">
            <summary>
            May be null
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetElement">
            <summary>
            May be null
            </summary>
            <returns>The element.</returns>
        </member>
        <member name="M:Nez.UI.Container.SetSize(Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified value
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified values
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetSize(System.Single)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified value
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetSize(System.Single,System.Single)">
            <summary>
            Sets the minWidth, prefWidth, maxWidth, minHeight, prefHeight, and maxHeight to the specified values
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetWidth(Nez.UI.Value)">
            <summary>
            Sets the minWidth, prefWidth, and maxWidth to the specified value
            </summary>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.UI.Container.SetWidth(System.Single)">
            <summary>
            Sets the minWidth, prefWidth, and maxWidth to the specified value
            </summary>
            <param name="width">Width.</param>
        </member>
        <member name="M:Nez.UI.Container.SetHeight(Nez.UI.Value)">
            <summary>
            Sets the minHeight, prefHeight, and maxHeight to the specified value.
            </summary>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetHeight(System.Single)">
            <summary>
            Sets the minHeight, prefHeight, and maxHeight to the specified value
            </summary>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMinSize(Nez.UI.Value)">
            <summary>
            Sets the minWidth and minHeight to the specified value
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMinSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the minimum size.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMinSize(System.Single)">
            <summary>
            Sets the minWidth and minHeight to the specified value
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMinSize(System.Single,System.Single)">
            <summary>
            Sets the minWidth and minHeight to the specified values
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.PrefSize(Nez.UI.Value)">
            <summary>
            Sets the prefWidth and prefHeight to the specified value.
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.PrefSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the prefWidth and prefHeight to the specified values.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetPrefSize(System.Single,System.Single)">
            <summary>
            Sets the prefWidth and prefHeight to the specified value.
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetPrefSize(System.Single)">
            <summary>
            Sets the prefWidth and prefHeight to the specified values
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMaxSize(Nez.UI.Value)">
            <summary>
            Sets the maxWidth and maxHeight to the specified value.
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMaxSize(Nez.UI.Value,Nez.UI.Value)">
            <summary>
            Sets the maxWidth and maxHeight to the specified values
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMaxSize(System.Single)">
            <summary>
            Sets the maxWidth and maxHeight to the specified value
            </summary>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.UI.Container.SetMaxSize(System.Single,System.Single)">
            <summary>
            Sets the maxWidth and maxHeight to the specified values
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.Container.SetPad(Nez.UI.Value)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value.
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Container.SetPad(System.Single)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Container.SetFill">
            <summary>
            Sets fillX and fillY to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetFillX">
            <summary>
            Sets fillX to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetFillY">
            <summary>
            Sets fillY to 1
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetFill(System.Boolean,System.Boolean)">
            <summary>
            Sets fillX and fillY to 1 if true, 0 if false
            </summary>
            <param name="x">If set to <c>true</c> x.</param>
            <param name="y">If set to <c>true</c> y.</param>
        </member>
        <member name="M:Nez.UI.Container.SetFill(System.Boolean)">
            <summary>
            Sets fillX and fillY to 1 if true, 0 if false
            </summary>
            <param name="fill">If set to <c>true</c> fill.</param>
        </member>
        <member name="M:Nez.UI.Container.SetAlign(Nez.UI.Align)">
            <summary>
            Sets the alignment of the element within the container. Set to {@link Align#center}, {@link Align#top}, {@link Align#bottom},
            {@link Align#left}, {@link Align#right}, or any combination of those.
            </summary>
            <param name="align">Align.</param>
        </member>
        <member name="M:Nez.UI.Container.SetAlignCenter">
            <summary>
            Sets the alignment of the element within the container to {@link Align#center}. This clears any other alignment.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetTop">
            <summary>
            Sets {@link Align#top} and clears {@link Align#bottom} for the alignment of the element within the container.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetLeft">
            <summary>
            Sets {@link Align#left} and clears {@link Align#right} for the alignment of the element within the container.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetBottom">
            <summary>
            Sets {@link Align#bottom} and clears {@link Align#top} for the alignment of the element within the container.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.SetRight">
            <summary>
            Sets {@link Align#right} and clears {@link Align#left} for the alignment of the element within the container.
            </summary>
        </member>
        <member name="M:Nez.UI.Container.GetPadTopValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad top value.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetPadLeftValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad left value.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetPadBottomValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad bottom value.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetPadRightValue">
            <summary>
            May be null if this value is not set
            </summary>
            <returns>The pad right value.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetPadX">
            <summary>
            Returns {@link #getPadLeft()} plus {@link #getPadRight()}.
            </summary>
            <returns>The pad x.</returns>
        </member>
        <member name="M:Nez.UI.Container.GetPadY">
            <summary>
            Returns {@link #getPadTop()} plus {@link #getPadBottom()}
            </summary>
            <returns>The pad y.</returns>
        </member>
        <member name="M:Nez.UI.Container.SetRound(System.Boolean)">
            <summary>
            If true (the default), positions and sizes are rounded to integers
            </summary>
            <param name="round">If set to <c>true</c> round.</param>
        </member>
        <member name="M:Nez.UI.Container.SetClip(System.Boolean)">
            <summary>
            Causes the contents to be clipped if they exceed the container bounds. Enabling clipping will set
            {@link #setTransform(bool)} to true
            </summary>
            <param name="enabled">If set to <c>true</c> enabled.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetAlignment(Nez.UI.Align)">
            <summary>
            Sets the alignment of widgets within the vertical group. Set to {@link Align#center}, {@link Align#top},
            {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those
            </summary>
            <param name="align">Align.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetReverse(System.Boolean)">
            <summary>
            If true, the children will be ordered from bottom to top rather than the default top to bottom.
            </summary>
            <param name="reverse">If set to <c>true</c> reverse.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetSpacing(System.Single)">
            <summary>
            Sets the space between children
            </summary>
            <param name="spacing">Spacing.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetPad(System.Single)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetRound(System.Boolean)">
            <summary>
            If true (the default), positions and sizes are rounded to integers.
            </summary>
            <param name="round">If set to <c>true</c> round.</param>
        </member>
        <member name="M:Nez.UI.HorizontalGroup.SetFill(System.Single)">
            <summary>
            fill 0 will use pref width
            </summary>
            <param name="fill">Fill.</param>
        </member>
        <member name="T:Nez.UI.ScrollPane">
             <summary>
             A group that scrolls a child widget using scrollbars and/or mouse or touch dragging.
            
             The widget is sized to its preferred size.If the widget's preferred width or height is less than the size of this scroll pane,
             it is set to the size of this scroll pane. Scrollbars appear when the widget is larger than the scroll pane.
            
             The scroll pane's preferred size is that of the child widget. At this size, the child widget will not need to scroll, so
             scroll pane is typically sized by ignoring the preferred size in one or both directions.
             </summary>
        </member>
        <member name="M:Nez.UI.ScrollPane.Cancel">
            <summary>
            If currently scrolling by tracking a touch down, stop scrolling.
            </summary>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetStyle">
            <summary>
            Returns the scroll pane's style. Modifying the returned style may not have an effect until {@link #setStyle(ScrollPaneStyle)} is called.
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetWidget(Nez.UI.Element)">
            <summary>
            Sets the {@link Element} embedded in this scroll pane
            </summary>
            <param name="widget">Widget.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetWidget">
            <summary>
            Returns the Element embedded in this scroll pane, or null
            </summary>
            <returns>The widget.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollSpeed(System.Single)">
            <summary>
            sets the scroll speed when the mouse wheel is used to scroll the ScrollPane
            </summary>
            <param name="scrollSpeed">Scroll speed.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetScrollSpeed">
            <summary>
            Returns the x scroll speed
            </summary>
            <returns>The scroll x.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollX(System.Single)">
            <summary>
            sets x scroll amount
            </summary>
            <param name="pixelsX">Pixels x.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetScrollX">
            <summary>
            Returns the x scroll position in pixels, where 0 is the left of the scroll pane.
            </summary>
            <returns>The scroll x.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollY(System.Single)">
            <summary>
            Called whenever the y scroll amount is changed
            </summary>
            <param name="pixelsY">Pixels y.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetScrollY">
            <summary>
            Returns the y scroll position in pixels, where 0 is the top of the scroll pane.
            </summary>
            <returns>The scroll y.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetUseNaturalScrolling(System.Boolean)">
            <summary>
            sets how the mouse wheel/trackpad operates. Natural scrolling moves the contents of a window the same direction as
            your fingers.
            </summary>
            <param name="useNaturalScrolling">Use natural scrolling.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.UpdateVisualScroll">
            <summary>
            Sets the visual scroll amount equal to the scroll amount. This can be used when setting the scroll amount without animating.
            </summary>
            <returns>The visual scroll.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetMaxX">
            <summary>
            Returns the maximum scroll value in the x direction.
            </summary>
            <returns>The max x.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetMaxY">
            <summary>
            Returns the maximum scroll value in the y direction.
            </summary>
            <returns>The max y.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetScrollWidth">
            <summary>
            Returns the width of the scrolled viewport.
            </summary>
            <returns>The scroll width.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetScrollHeight">
            <summary>
            Returns the height of the scrolled viewport.
            </summary>
            <returns>The scroll height.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.IsScrollX">
            <summary>
            Returns true if the widget is larger than the scroll pane horizontally.
            </summary>
            <returns>The scroll x.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.IsScrollY">
            <summary>
            Returns true if the widget is larger than the scroll pane vertically.
            </summary>
            <returns>The scroll y.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollingDisabled(System.Boolean,System.Boolean)">
            <summary>
            Disables scrolling in a direction. The widget will be sized to the FlickScrollPane in the disabled direction.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetVelocityX">
            <summary>
            Gets the flick scroll x velocity
            </summary>
            <returns>The velocity x.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.GetVelocityY">
            <summary>
            Gets the flick scroll y velocity
            </summary>
            <returns>The velocity y.</returns>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetOverscroll(System.Boolean,System.Boolean)">
            <summary>
            For flick scroll, if true the widget can be scrolled slightly past its bounds and will animate back to its bounds
            when scrolling is stopped. Default is true.
            </summary>
            <param name="overscrollX">Overscroll x.</param>
            <param name="overscrollY">Overscroll y.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetupOverscroll(System.Single,System.Single,System.Single)">
            <summary>
            For flick scroll, sets the overscroll distance in pixels and the speed it returns to the widget's bounds in seconds.
            Default is 50, 30, 200.
            </summary>
            <param name="distance">Distance.</param>
            <param name="speedMin">Speed minimum.</param>
            <param name="speedMax">Speed max.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetForceScroll(System.Boolean,System.Boolean)">
            <summary>
            Forces enabling scrollbars (for non-flick scroll) and overscrolling (for flick scroll) in a direction, even if the
            contents do not exceed the bounds in that direction.
            </summary>
            <returns>The force scroll.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetFlingTime(System.Single)">
            <summary>
            For flick scroll, sets the amount of time in seconds that a fling will continue to scroll. Default is 1.
            </summary>
            <param name="flingTime">Fling time.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetClamp(System.Boolean)">
            <summary>
            For flick scroll, prevents scrolling out of the widget's bounds. Default is true.
            </summary>
            <param name="clamp">Clamp.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollBarPositions(System.Boolean,System.Boolean)">
            <summary>
            Set the position of the vertical and horizontal scroll bars.
            </summary>
            <param name="bottom">Bottom.</param>
            <param name="right">Right.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetFadeScrollBars(System.Boolean)">
            <summary>
            When true the scrollbars don't reduce the scrollable size and fade out after some time of not being used.
            </summary>
            <param name="fadeScrollBars">Fade scroll bars.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetScrollbarsOnTop(System.Boolean)">
            <summary>
            When false (the default), the widget is clipped so it is not drawn under the scrollbars. When true, the widget is clipped
            to the entire scroll pane bounds and the scrollbars are drawn on top of the widget. If {@link #setFadeScrollBars(boolean)}
            is true, the scroll bars are always drawn on top.
            </summary>
            <param name="scrollbarsOnTop">Scrollbars on top.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetVariableSizeKnobs(System.Boolean)">
            <summary>
            If true, the scroll knobs are sized based on getMaxX() or getMaxY(). If false, the scroll knobs are sized
            based on Drawable#getMinWidth() or Drawable#getMinHeight(). Default is true.
            </summary>
            <param name="variableSizeKnobs">Variable size knobs.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.ScrollTo(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Sets the scroll offset so the specified rectangle is fully in view, if possible. Coordinates are in the scroll pane
            widget's coordinate system.
            </summary>
            <returns>The to.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.ScrollTo(System.Single,System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Sets the scroll offset so the specified rectangle is fully in view, and optionally centered vertically and/or horizontally,
            if possible. Coordinates are in the scroll pane widget's coordinate system.
            </summary>
            <returns>The to.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="centerHorizontal">Center horizontal.</param>
            <param name="centerVertical">Center vertical.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetVisualScrollX(System.Single)">
            <summary>
            Called whenever the visual x scroll amount is changed
            </summary>
            <returns>The visual scroll x.</returns>
            <param name="pixelsX">Pixels x.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.SetVisualScrollY(System.Single)">
            <summary>
            Called whenever the visual y scroll amount is changed
            </summary>
            <returns>The visual scroll y.</returns>
            <param name="pixelsY">Pixels y.</param>
        </member>
        <member name="M:Nez.UI.ScrollPane.Fling(System.Single,System.Single,System.Single)">
            <summary>
            Generate fling gesture
            </summary>
            <param name="flingTime">Fling time.</param>
            <param name="velocityX">Velocity x.</param>
            <param name="velocityY">Velocity y.</param>
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.Background">
            Optional. 
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.Corner">
            Optional. 
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.HScroll">
            Optional. 
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.HScrollKnob">
            Optional. 
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.VScroll">
            Optional. 
        </member>
        <member name="F:Nez.UI.ScrollPaneStyle.VScrollKnob">
            Optional. 
        </member>
        <member name="M:Nez.UI.SplitPane.SetSplitAmount(System.Single)">
            <summary>
            The split amount between the min and max amount
            </summary>
            <param name="amount">Amount.</param>
        </member>
        <member name="T:Nez.UI.Stack">
            <summary>
            A stack is a container that sizes its children to its size and positions them at 0,0 on top of each other.
            
            The preferred and min size of the stack is the largest preferred and min size of any children. The max size of the stack is the
            smallest max size of any children.
            </summary>
        </member>
        <member name="T:Nez.UI.Table">
             <summary>
             A group that sizes and positions children using table constraints. By default, {@link #getTouchable()} is
             {@link Touchable#childrenOnly}.
            
             The preferred and minimum sizes are that of the chdebugn when laid out in columns and rows.
             </summary>
        </member>
        <member name="M:Nez.UI.Table.DrawBackground(Nez.Batcher,System.Single,System.Single,System.Single)">
            <summary>
            Called to draw the background, before clipping is applied (if enabled). Default implementation draws the background
            drawable.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Add(Nez.UI.Element)">
            <summary>
            Adds a new cell to the table with the specified element.
            </summary>
            <param name="element">element.</param>
        </member>
        <member name="M:Nez.UI.Table.Add(System.String)">
            <summary>
            Adds a new cell with a label
            </summary>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.UI.Table.Add">
            <summary>
            Adds a cell without an element
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Stack(Nez.UI.Element[])">
            <summary>
            Adds a new cell to the table with the specified elements in a {@link Stack}.
            </summary>
            <param name="elements">Elements.</param>
        </member>
        <member name="M:Nez.UI.Table.ClearChildren">
            <summary>
            Removes all elements and cells from the table
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Reset">
            <summary>
            Removes all elements and cells from the table (same as {@link #clear()}) and additionally resets all table properties and
            cell, column, and row defaults.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Row">
            <summary>
            Indicates that subsequent cells should be added to a new row and returns the cell values that will be used as the defaults
            for all cells in the new row.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.GetColumnDefaults(System.Int32)">
            <summary>
            Gets the cell values that will be used as the defaults for all cells in the specified column. Columns are indexed starting at 0
            </summary>
            <returns>The column defaults.</returns>
            <param name="column">Column.</param>
        </member>
        <member name="M:Nez.UI.Table.Defaults">
            <summary>
            The cell values that will be used as the defaults for all cells.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.SetBackground(Nez.UI.IDrawable)">
            <summary>
            background may be null to clear the background.
            </summary>
            <param name="background">Background.</param>
        </member>
        <member name="M:Nez.UI.Table.Round(System.Boolean)">
            <summary>
            If true (the default), positions and sizes are rounded to integers.
            </summary>
            <param name="round">If set to <c>true</c> round.</param>
        </member>
        <member name="M:Nez.UI.Table.Pad(Nez.UI.Value)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Table.PadTop(Nez.UI.Value)">
            <summary>
            Padding at the top edge of the table.
            </summary>
            <param name="padTop">Pad top.</param>
        </member>
        <member name="M:Nez.UI.Table.PadLeft(Nez.UI.Value)">
            <summary>
            Padding at the left edge of the table.
            </summary>
            <param name="padLeft">Pad left.</param>
        </member>
        <member name="M:Nez.UI.Table.PadBottom(Nez.UI.Value)">
            <summary>
            Padding at the bottom edge of the table.
            </summary>
            <param name="padBottom">Pad bottom.</param>
        </member>
        <member name="M:Nez.UI.Table.PadRight(Nez.UI.Value)">
            <summary>
            Padding at the right edge of the table.
            </summary>
            <param name="padRight">Pad right.</param>
        </member>
        <member name="M:Nez.UI.Table.Pad(System.Single)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight around the table to the specified value.
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.Table.PadTop(System.Single)">
            <summary>
            Padding at the top edge of the table.
            </summary>
            <param name="padTop">Pad top.</param>
        </member>
        <member name="M:Nez.UI.Table.PadLeft(System.Single)">
            <summary>
            Padding at the left edge of the table.
            </summary>
            <param name="padLeft">Pad left.</param>
        </member>
        <member name="M:Nez.UI.Table.PadBottom(System.Single)">
            <summary>
            Padding at the bottom edge of the table.
            </summary>
            <param name="padBottom">Pad bottom.</param>
        </member>
        <member name="M:Nez.UI.Table.PadRight(System.Single)">
            <summary>
            Padding at the right edge of the table.
            </summary>
            <param name="padRight">Pad right.</param>
        </member>
        <member name="M:Nez.UI.Table.Align(System.Int32)">
            <summary>
            Alignment of the logical table within the table element. Set to {@link Align#center}, {@link Align#top}, {@link Align#bottom}
            {@link Align#left}, {@link Align#right}, or any combination of those.
            </summary>
            <param name="align">Align.</param>
        </member>
        <member name="M:Nez.UI.Table.Center">
            <summary>
            Sets the alignment of the logical table within the table element to {@link Align#center}. This clears any other alignment.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Top">
            <summary>
            Adds {@link Align#top} and clears {@link Align#bottom} for the alignment of the logical table within the table element.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Left">
            <summary>
            Adds {@link Align#left} and clears {@link Align#right} for the alignment of the logical table within the table element.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Bottom">
            <summary>
            Adds {@link Align#bottom} and clears {@link Align#top} for the alignment of the logical table within the table element.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.Right">
            <summary>
            Adds {@link Align#right} and clears {@link Align#left} for the alignment of the logical table within the table element.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.SetDebug(System.Boolean)">
            <summary>
            enables/disables all debug lines (table, cell, and widget)
            </summary>
            <param name="enabled">If set to <c>true</c> enabled.</param>
        </member>
        <member name="M:Nez.UI.Table.DebugAll">
            <summary>
            Turn on all debug lines (table, cell, and element)
            </summary>
            <returns>The all.</returns>
        </member>
        <member name="M:Nez.UI.Table.DebugTable">
            <summary>
            Turns on table debug lines.
            </summary>
            <returns>The table.</returns>
        </member>
        <member name="M:Nez.UI.Table.DebugCell">
            <summary>
            Turns on cell debug lines.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.DebugElement">
            <summary>
            Turns on element debug lines.
            </summary>
        </member>
        <member name="M:Nez.UI.Table.SetTableDebug(Nez.UI.Table.TableDebug)">
            <summary>
            Turns debug lines on or off.
            </summary>
            <param name="tableDebug">Table debug.</param>
        </member>
        <member name="M:Nez.UI.Table.GetRowDefaults">
            <summary>
            gets the current Cell defaults. This is the same value returned by a call to row()
            </summary>
            <returns>The row defaults.</returns>
        </member>
        <member name="M:Nez.UI.Table.GetCell(Nez.UI.Element)">
            <summary>
            Returns the cell for the specified element in this table, or null.
            </summary>
            <returns>The cell.</returns>
            <param name="element">element.</param>
        </member>
        <member name="M:Nez.UI.Table.GetCells">
            <summary>
            returns all the Cells in the table
            </summary>
            <returns>The cells.</returns>
        </member>
        <member name="M:Nez.UI.Table.GetPadX">
            <summary>
            Returns {@link #getPadLeft()} plus {@link #getPadRight()}.
            </summary>
            <returns>The pad x.</returns>
        </member>
        <member name="M:Nez.UI.Table.GetPadY">
            <summary>
            Returns {@link #getPadTop()} plus {@link #getPadBottom()}.
            </summary>
            <returns>The pad y.</returns>
        </member>
        <member name="M:Nez.UI.Table.GetRowHeight(System.Int32)">
            <summary>
            Returns the height of the specified row.
            </summary>
            <returns>The row height.</returns>
            <param name="rowIndex">Row index.</param>
        </member>
        <member name="M:Nez.UI.Table.GetColumnWidth(System.Int32)">
            <summary>
            Returns the width of the specified column.
            </summary>
            <returns>The column width.</returns>
            <param name="columnIndex">Column index.</param>
        </member>
        <member name="M:Nez.UI.Table.Layout(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Positions and sizes children of the table using the cell associated with each child. The values given are the position
            within the parent and size of the table.
            </summary>
            <param name="layoutX">Layout x.</param>
            <param name="layoutY">Layout y.</param>
            <param name="layoutWidth">Layout width.</param>
            <param name="layoutHeight">Layout height.</param>
        </member>
        <member name="T:Nez.UI.Table.BackgroundTopValue">
            <summary>
            Value that is the top padding of the table's background
            </summary>
        </member>
        <member name="T:Nez.UI.Table.BackgroundLeftValue">
            <summary>
            Value that is the left padding of the table's background
            </summary>
        </member>
        <member name="T:Nez.UI.Table.BackgroundBottomValue">
            <summary>
            Value that is the bottom padding of the table's background
            </summary>
        </member>
        <member name="T:Nez.UI.Table.BackgroundRightValue">
            <summary>
            Value that is the right padding of the table's background
            </summary>
        </member>
        <member name="F:Nez.UI.Containers.TreeStyle.Over">
            Optional. 
        </member>
        <member name="F:Nez.UI.Containers.TreeStyle.Selection">
            Optional. 
        </member>
        <member name="F:Nez.UI.Containers.TreeStyle.Background">
            Optional. 
        </member>
        <member name="T:Nez.UI.VerticalGroup">
            <summary>
            A group that lays out its children on top of each other in a single column. This can be easier than using {@link Table} when
            elements need to be inserted in the middle of the group.
            
            The preferred width is the largest preferred width of any child. The preferred height is the sum of the children's preferred
            heights, plus spacing between them if set. The min size is the preferred size and the max size is 0.
            </summary>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetAlignment(Nez.UI.Align)">
            <summary>
            Sets the alignment of widgets within the vertical group. Set to {@link Align#center}, {@link Align#top},
            {@link Align#bottom}, {@link Align#left}, {@link Align#right}, or any combination of those
            </summary>
            <param name="align">Align.</param>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetReverse(System.Boolean)">
            <summary>
            If true, the children will be ordered from bottom to top rather than the default top to bottom.
            </summary>
            <param name="reverse">If set to <c>true</c> reverse.</param>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetSpacing(System.Single)">
            <summary>
            Sets the space between children
            </summary>
            <param name="spacing">Spacing.</param>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetPad(System.Single)">
            <summary>
            Sets the padTop, padLeft, padBottom, and padRight to the specified value
            </summary>
            <param name="pad">Pad.</param>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetRound(System.Boolean)">
            <summary>
            If true (the default), positions and sizes are rounded to integers.
            </summary>
            <param name="round">If set to <c>true</c> round.</param>
        </member>
        <member name="M:Nez.UI.VerticalGroup.SetFill(System.Single)">
            <summary>
            fill 0 will use pref width
            </summary>
            <param name="fill">Fill.</param>
        </member>
        <member name="T:Nez.UI.IDrawable">
            <summary>
            A drawable knows how to draw itself at a given rectangular size. It provides border sizes and a minimum size so that other code
            can determine how to size and position content.
            </summary>
        </member>
        <member name="T:Nez.UI.NinePatchDrawable">
             <summary>
             The drawable sizes are set when the ninepatch is set, but they are separate values. Eg, {@link Drawable#getLeftWidth()} could
             be set to more than {@link NinePatch#getLeftWidth()} in order to provide more space on the left than actually exists in the
             ninepatch.
            
             The min size is set to the ninepatch total size by default. It could be set to the left+right and top+bottom, excluding the
             middle size, to allow the drawable to be sized down as small as possible.
             </summary>
        </member>
        <member name="F:Nez.UI.NinePatchDrawable._finalRenderRect">
            <summary>
            full area in which we will be rendering
            </summary>
        </member>
        <member name="M:Nez.UI.NinePatchDrawable.#ctor(Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            creates a NinePatchDrawable using the full texture
            </summary>
            <param name="texture">Texture.</param>
            <param name="left">Left.</param>
            <param name="right">Right.</param>
            <param name="top">Top.</param>
            <param name="bottom">Bottom.</param>
        </member>
        <member name="M:Nez.UI.NinePatchDrawable.SetPadding(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            sets the padding on the NinePatchSprite
            </summary>
            <param name="left">Left.</param>
            <param name="right">Right.</param>
            <param name="top">Top.</param>
            <param name="bottom">Bottom.</param>
        </member>
        <member name="M:Nez.UI.NinePatchDrawable.NewTintedDrawable(Microsoft.Xna.Framework.Color)">
            <summary>
            returns a new drawable with the tint color specified
            </summary>
            <returns>The tinted drawable.</returns>
            <param name="tint">Tint.</param>
        </member>
        <member name="T:Nez.UI.SpriteDrawable">
            <summary>
            Drawable for a {@link Sprite}
            </summary>
        </member>
        <member name="P:Nez.UI.SpriteDrawable.FlipX">
            <summary>
            determines if the sprite should be rendered normally or flipped horizontally
            </summary>
            <value><c>true</c> if flip x; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:Nez.UI.SpriteDrawable.FlipY">
            <summary>
            determines if the sprite should be rendered normally or flipped vertically
            </summary>
            <value><c>true</c> if flip y; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.UI.SpriteDrawable.NewTintedDrawable(Microsoft.Xna.Framework.Color)">
            <summary>
            returns a new drawable with the tint color specified
            </summary>
            <returns>The tinted drawable.</returns>
            <param name="tint">Tint.</param>
        </member>
        <member name="T:Nez.UI.TiledDrawable">
            <summary>
            Draws a {@link Sprite} repeatedly to fill the area, instead of stretching it
            </summary>
        </member>
        <member name="M:Nez.UI.Skin.CreateDefaultSkin">
            <summary>
            creates a default Skin that can be used for quick mockups. Includes button, textu button, checkbox, progress bar and slider styles.
            </summary>
            <returns>The default skin.</returns>
        </member>
        <member name="M:Nez.UI.Skin.SetStylesForStyleClass``1(``0,System.Collections.Generic.Dictionary{System.String,System.Object},Nez.Systems.NezContentManager,System.String)">
            <summary>
            Recursively finds and sets all styles for a specific style config class that are within
            the dictionary passed in. This allows skins to contain nested, dynamic style declarations.
            For example, it allows a SelectBoxStyle to contain a listStyle that is declared inline
            (and not a reference).
            </summary>
            <param name="styleClass">The style config class instance that needs to be "filled out"</param>
            <param name="styleDict">A dictionary that represents one style name within the style config class (i.e. 'default').</param>
            <param name="styleName">The style name that the dictionary represents (i.e. 'default').</param>
            <typeparam name="T">The style config class type (i.e. SelectBoxStyle)</typeparam>
        </member>
        <member name="M:Nez.UI.Skin.AddSprites(Nez.Sprites.SpriteAtlas)">
            <summary>
            Adds all named Sprites from the atlas
            </summary>
            <param name="atlas">Atlas.</param>
        </member>
        <member name="M:Nez.UI.Skin.Add``1(System.String,``0)">
            <summary>
            adds the typed resource to this skin
            </summary>
        </member>
        <member name="M:Nez.UI.Skin.Add(System.String,System.Object,System.Type)">
            <summary>
            adds the typed resource to this skin
            </summary>
            <param name="name">Name.</param>
            <param name="resource">Resource.</param>
        </member>
        <member name="M:Nez.UI.Skin.Remove``1(System.String)">
            <summary>
            removes the typed resource from this skin
            </summary>
            <param name="name">Name.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.UI.Skin.Has``1(System.String)">
            <summary>
            checks to see if a typed resource exists with the given name
            </summary>
            <param name="name">Name.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.UI.Skin.Get``1">
            <summary>
            First checks for a resource named "default". If it cant find default it will return either the first resource of type T
            or default(T) if none are found.
            </summary>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.UI.Skin.Get``1(System.String)">
            <summary>
            Returns a named resource of the specified type or default(T) if it couldnt be found
            </summary>
            <param name="name">Name.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.UI.Skin.GetSpriteDrawable(System.String)">
            <summary>
            Returns a registered sprite drawable. If no sprite drawable is found but a Sprite exists with the name, a
            sprite drawable is created from the Sprite and stored in the skin
            </summary>
            <returns>The sprite drawable.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.UI.Skin.GetDrawable(System.String)">
            <summary>
            Returns a registered drawable. If no drawable is found but a Sprite/NinePatchSprite exists with the name, then the
            appropriate drawable is created and stored in the skin. If name is a color a PrimitiveDrawable will be created and stored.
            </summary>
            <returns>The drawable.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.UI.Skin.GetTiledDrawable(System.String)">
            <summary>
            Returns a registered tiled drawable. If no tiled drawable is found but a Sprite exists with the name, a tiled drawable is
            created from the Sprite and stored in the skin
            </summary>
            <returns>The tiled drawable.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.UI.Skin.GetNinePatchDrawable(System.String)">
            <summary>
            Returns a registered ninepatch. If no ninepatch is found but a Sprite exists with the name, a ninepatch is created from the
            Sprite and stored in the skin.
            </summary>
            <returns>The nine patch.</returns>
            <param name="name">Name.</param>
        </member>
        <member name="M:Nez.UI.Skin.NewTintedDrawable(System.String,Microsoft.Xna.Framework.Color)">
            <summary>
            Returns a tinted copy of a drawable found in the skin via getDrawable. Note that the new drawable is NOT
            added to the skin! Tinting is only supported on SpriteDrawables and NinePatchDrawables.
            </summary>
            <returns>The tinted drawable.</returns>
            <param name="name">Name.</param>
            <param name="tint">Tint.</param>
        </member>
        <member name="F:Nez.UI.Stage.IsFullScreen">
            <summary>
            if true, the rawMousePosition will be used else the scaledMousePosition will be used. If your UI is in screen space
            and non-scaled (using the Scene.IFinalRenderDelegate for example) then set this to true so input is not scaled.
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.GamepadActionButton">
            <summary>
            the button on the gamepad that activates the focused control
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardEmulatesGamepad">
            <summary>
            if true (default) keyboard arrow keys and the keyboardActionKey will emulate a gamepad
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardActionKey">
            <summary>
            the key that activates the focused control
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardActionKeys">
            <summary>
            the key(s) that activates the focused control
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardDownKeys">
            <summary>
            the key(s) that triggers "direction down" on the element with focus
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardUpKeys">
            <summary>
            the key(s) that triggers "direction up" on the element with focus
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardLeftKeys">
            <summary>
            the key(s) that triggers "direction left" on the element with focus
            </summary>
        </member>
        <member name="F:Nez.UI.Stage.KeyboardRightKeys">
            <summary>
            the key(s) that triggers "direction right" on the element with focus
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.AddElement``1(``0)">
            <summary>
            Adds an element to the root of the stage
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.DisableDebug(Nez.UI.Element,Nez.UI.Element)">
            <summary>
            Disables debug on all elements recursively except the specified element and any children
            </summary>
            <param name="element">element.</param>
            <param name="except">Except.</param>
        </member>
        <member name="M:Nez.UI.Stage.GetMousePosition">
            <summary>
            gets the appropriate mouse position (scaled vs raw) based on if this isFullScreen and if we have an entity
            </summary>
            <returns>The mouse position.</returns>
        </member>
        <member name="M:Nez.UI.Stage.UpdateInputMouse">
            <summary>
            Handle mouse input events.
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.UpdateInputTouch">
            <summary>
            Handle all the touch input events.
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.UpdateInputPoint(Microsoft.Xna.Framework.Vector2,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Nez.UI.Element@)">
            <summary>
            Process events for Mouse or Touch input.
            </summary>
            <param name="inputPos">location of cursor</param>
            <param name="inputPressed">down this frame</param>
            <param name="secondaryInputPressed">down this frame</param>
            <param name="inputReleased">up this frame</param>
            <param name="secondaryInputReleased">up this frame</param>
            <param name="inputMoved">cursor in a different location</param>
            <param name="lastOver">last element that the cursor was over, ref is saved here for next update</param>
        </member>
        <member name="M:Nez.UI.Stage.UpdatePrimaryInputDown(Microsoft.Xna.Framework.Vector2,Nez.UI.Element)">
            <summary>
            Mouse or touch is down this frame.
            </summary>
            <param name="inputPos">location of cursor</param>
            <param name="over">element under cursor</param>
        </member>
        <member name="M:Nez.UI.Stage.UpdateSecondaryInputDown(Microsoft.Xna.Framework.Vector2,Nez.UI.Element)">
            <summary>
            Right Mouse or touch is down this frame.
            </summary>
            <param name="inputPos">location of cursor</param>
            <param name="over">element under cursor</param>
        </member>
        <member name="M:Nez.UI.Stage.UpdateInputMoved(Microsoft.Xna.Framework.Vector2,Nez.UI.Element,Nez.UI.Element)">
            <summary>
            Mouse or touch is being moved.
            </summary>
            <param name="inputPos">location of cursor</param>
            <param name="over">element under cursor</param>
            <param name="lastOver">element that was previously under the cursor</param>
        </member>
        <member name="M:Nez.UI.Stage.UpdatePrimaryInputReleased(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Mouse or touch is being released this frame.
            </summary>
            <param name="inputPos">location under cursor</param>
        </member>
        <member name="M:Nez.UI.Stage.UpdateSecondaryInputReleased(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Right mouse click or touch is being released this frame.
            </summary>
            <param name="inputPos">location under cursor</param>
        </member>
        <member name="M:Nez.UI.Stage.HandleMouseWheel(Nez.UI.Element)">
            <summary>
            bubbles the onMouseScrolled event from mouseOverElement to all parents until one of them handles it
            </summary>
            <returns>The mouse wheel.</returns>
            <param name="mouseOverElement">Mouse over element.</param>
        </member>
        <member name="M:Nez.UI.Stage.RemoveInputFocusListener(Nez.UI.Element)">
            <summary>
            Removes the listener from being notified for all touchDragged and touchUp events for the specified pointer and button. Note
            the listener may never receive a touchUp event if this method is used.
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.IsKeyboardActionKeyPressed">
            <summary>
            Compares Keys[] first, then compares Keys 
            </summary>
            <returns><c>true</c>, if keys[] is not empty and any of the keys are pressed, otherwise if the KeyboardActionKey is pressed, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Stage.IsKeyboardActionKeyReleased">
            <summary>
            Compares Keys[] first, then compares Keys 
            </summary>
            <returns><c>true</c>, if keys[] is not empty and any of the keys are released, otherwise if the KeyboardActionKey is released, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.UI.Stage.ClearKeyRepeatTimer">
            <summary>
            stops and nulls the keyRepeatTimer if it is running
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.Dispose">
            <summary>
            this should be called when the Component is removed to ensure all objects are freed
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.GetRoot">
            <summary>
            Returns the root group which holds all elements in the stageCoords
            </summary>
            <returns>The root.</returns>
        </member>
        <member name="M:Nez.UI.Stage.GetWidth">
            <summary>
            The Stages world width
            </summary>
            <returns>The width.</returns>
        </member>
        <member name="M:Nez.UI.Stage.GetHeight">
            <summary>
            The Stages world height
            </summary>
            <returns>The height.</returns>
        </member>
        <member name="M:Nez.UI.Stage.SetDebugAll(System.Boolean)">
            <summary>
            If true, debug lines are shown for all elements
            </summary>
            <param name="debugAll">If set to <c>true</c> debug all.</param>
        </member>
        <member name="M:Nez.UI.Stage.SetDebugUnderMouse(System.Boolean)">
            <summary>
            If true, debug is enabled only for the element under the mouse. Can be combined with {@link #setDebugAll(bool)}
            </summary>
            <param name="debugUnderMouse">If set to <c>true</c> debug under mouse.</param>
        </member>
        <member name="M:Nez.UI.Stage.SetDebugParentUnderMouse(System.Boolean)">
            <summary>
            If true, debug is enabled only for the parent of the element under the mouse. Can be combined with {@link #setDebugAll(bool)}
            </summary>
            <param name="debugParentUnderMouse">If set to <c>true</c> debug parent under mouse.</param>
        </member>
        <member name="M:Nez.UI.Stage.SetDebugTableUnderMouse(Nez.UI.Table.TableDebug)">
            <summary>
            If not {@link TableDebug#none}, debug is enabled only for the first ascendant of the element under the mouse that is a table. Can
            be combined with {@link #setDebugAll(bool)}
            </summary>
            <param name="debugTableUnderMouse">Debug table under mouse.</param>
        </member>
        <member name="M:Nez.UI.Stage.SetDebugTableUnderMouse(System.Boolean)">
            <summary>
            If true, debug is enabled only for the first ascendant of the element under the mouse that is a table. Can be combined with
            {@link #setDebugAll(bool)}
            </summary>
            <param name="debugTableUnderMouse">If set to <c>true</c> debug table under mouse.</param>
        </member>
        <member name="M:Nez.UI.Stage.UnfocusAll">
            <summary>
            Removes the touch, keyboard, and scroll focused elements
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.SetKeyboardFocus(Nez.UI.IKeyboardListener)">
            <summary>
            Sets the element that will receive key events
            </summary>
            <param name="element">element.</param>
        </member>
        <member name="M:Nez.UI.Stage.SetGamepadFocusElement(Nez.UI.IGamepadFocusable)">
            <summary>
            sets the gamepad focus element and also turns on gamepad focus for this Stage. For gamepad focus to work you must set an initially
            focused element.
            </summary>
            <param name="focusable">Focusable.</param>
        </member>
        <member name="M:Nez.UI.Stage.DisableGamepadFocus">
            <summary>
            unset the gamepad focus element and turns off gamepad focus for this Stage.
            </summary>
        </member>
        <member name="M:Nez.UI.Stage.GetKeyboardFocus">
            <summary>
            Gets the element that will receive key events.
            </summary>
            <returns>The keyboard focus.</returns>
        </member>
        <member name="M:Nez.UI.Stage.ScreenToStageCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the screen coordinates to stage coordinates
            </summary>
            <returns>The to stage coordinates.</returns>
            <param name="screenCoords">Screen coords.</param>
        </member>
        <member name="M:Nez.UI.Stage.StageToScreenCoordinates(Microsoft.Xna.Framework.Vector2)">
            <summary>
            Transforms the stage coordinates to screen coordinates
            </summary>
            <returns>The to screen coordinates.</returns>
            <param name="stageCoords">Stage coords.</param>
        </member>
        <member name="M:Nez.UI.Stage.FindAllElementsOfType``1">
            <summary>
            finds all the Elements of type T in the Stage
            </summary>
            <returns>The all elements of type.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.UI.ArraySelection`1.Validate">
            <summary>
            Removes objects from the selection that are no longer in the items array. If getRequired() is true and there is
            no selected item, the first item is selected.
            </summary>
        </member>
        <member name="M:Nez.UI.Selection`1.SetElement(Nez.UI.Element)">
            <summary>
            An Element to fire ChangeEvent on when the selection changes, or null
            </summary>
            <returns>The element.</returns>
            <param name="element">element.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.Choose(`0)">
            <summary>
            Selects or deselects the specified item based on how the selection is configured, whether ctrl is currently pressed, etc.
            This is typically invoked by user interaction.
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.First">
            <summary>
            Returns the first selected item, or null
            </summary>
        </member>
        <member name="M:Nez.UI.Selection`1.Set(`0)">
            <summary>
            Sets the selection to only the specified item
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.Add(`0)">
            <summary>
            Adds the item to the selection
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.Changed">
            <summary>
            Called after the selection changes. The default implementation does nothing.
            </summary>
        </member>
        <member name="M:Nez.UI.Selection`1.FireChangeEvent">
            <summary>
            Fires a change event on the selection's Element, if any. Called internally when the selection changes, depending on
            setProgrammaticChangeEvents(bool)
            </summary>
        </member>
        <member name="M:Nez.UI.Selection`1.GetLastSelected">
            <summary>
            Makes a best effort to return the last item selected, else returns an arbitrary item or null if the selection is empty.
            </summary>
            <returns>The last selected.</returns>
        </member>
        <member name="M:Nez.UI.Selection`1.SetDisabled(System.Boolean)">
            <summary>
            If true, prevents choose(Object) from changing the selection. Default is false.
            </summary>
            <param name="isDisabled">Is disabled.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.SetToggle(System.Boolean)">
            <summary>
            If true, prevents choose(Object) from clearing the selection. Default is false.
            </summary>
            <param name="toggle">Toggle.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.SetMultiple(System.Boolean)">
            <summary>
            If true, allows choose(Object) to select multiple items. Default is false.
            </summary>
            <param name="multiple">Multiple.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.SetRequired(System.Boolean)">
            <summary>
            If true, prevents choose(Object) from selecting none. Default is false.
            </summary>
            <param name="required">Required.</param>
        </member>
        <member name="M:Nez.UI.Selection`1.SetProgrammaticChangeEvents(System.Boolean)">
            <summary>
            If false, only choose(Object) will fire a change event. Default is true.
            </summary>
            <param name="programmaticChangeEvents">Programmatic change events.</param>
        </member>
        <member name="F:Nez.UI.TooltipManager.InitialTime">
            <summary>
            Seconds from when an actor is hovered to when the tooltip is shown. Call {hideAll() after changing to reset internal state
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.SubsequentTime">
            <summary>
            Once a tooltip is shown, this is used instead of initialTime. Default is 0.
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.ResetTime">
            <summary>
            Seconds to use subsequentTime
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.Enabled">
            <summary>
            If false, tooltips will not be shown. Default is true.
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.Animations">
            <summary>
            If false, tooltips will be shown without animations. Default is true.
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.MaxWidth">
            <summary>
            The maximum width of a TextTooltip. The label will wrap if needed. Default is int.MaxValue.
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.OffsetX">
            <summary>
            The distance from the mouse position to offset the tooltip actor
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.OffsetY">
            <summary>
            The distance from the mouse position to offset the tooltip actor
            </summary>
        </member>
        <member name="F:Nez.UI.TooltipManager.EdgeDistance">
            <summary>
            The distance from the tooltip actor position to the edge of the screen where the actor will be shown on the other side of
            the mouse cursor.
            </summary>
        </member>
        <member name="M:Nez.UI.TooltipManager.HideWithoutRemoving(Nez.UI.Tooltip)">
            <summary>
            Hide the passed in tooltip without removing it from the _shownTooltips collection.
            </summary>
            <param name="tooltip">Tooltip to hide.</param>
            <returns>True if the tooltip was hidden; false otherwise.</returns>
        </member>
        <member name="M:Nez.UI.TooltipManager.ShowAction(Nez.UI.Tooltip)">
            <summary>
            Called when tooltip is shown. Default implementation sets actions to animate showing.
            </summary>
            <returns>The action.</returns>
            <param name="tooltip">Tooltip.</param>
        </member>
        <member name="M:Nez.UI.TooltipManager.HideAction(Nez.UI.Tooltip)">
            <summary>
            Called when tooltip is hidden. Default implementation sets actions to animate hiding and to remove the Element from the stage
            when the actions are complete.
            </summary>
            <returns>The action.</returns>
            <param name="tooltip">Tooltip.</param>
        </member>
        <member name="M:Nez.UI.TooltipManager.Instant">
            <summary>
            Shows all tooltips on hover without a delay for resetTime seconds.
            </summary>
        </member>
        <member name="F:Nez.UI.Button.ButtonBoundaryThreshold">
            <summary>
            the maximum distance outside the button the mouse can move when pressing it to cause it to be unfocused
            </summary>
        </member>
        <member name="M:Nez.UI.Button.Toggle">
            <summary>
            Toggles the checked state. This method changes the checked state, which fires a {@link onChangedEvent} (if programmatic change
            events are enabled), so can be used to simulate a button click.
            </summary>
        </member>
        <member name="M:Nez.UI.Button.GetStyle">
            <summary>
            Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is called.
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.Button.GetButtonGroup">
            <summary>
            May be null
            </summary>
            <returns>The button group.</returns>
        </member>
        <member name="T:Nez.UI.ButtonStyle">
            <summary>
            The style for a button
            </summary>
        </member>
        <member name="F:Nez.UI.ButtonStyle.Up">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.Down">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.Over">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.Checked">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.CheckedOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.Disabled">
            Optional. 
        </member>
        <member name="F:Nez.UI.ButtonStyle.PressedOffsetX">
            Optional. offsets children (labels for example). 
        </member>
        <member name="F:Nez.UI.ButtonStyle.PressedOffsetY">
            Optional. offsets children (labels for example). 
        </member>
        <member name="F:Nez.UI.ButtonStyle.UnpressedOffsetX">
            Optional. offsets children (labels for example). 
        </member>
        <member name="F:Nez.UI.ButtonStyle.UnpressedOffsetY">
            Optional. offsets children (labels for example). 
        </member>
        <member name="F:Nez.UI.ButtonStyle.CheckedOffsetX">
            Optional. offsets children (labels for example). 
        </member>
        <member name="F:Nez.UI.ButtonStyle.CheckedOffsetY">
            Optional. offsets children (labels for example). 
        </member>
        <member name="T:Nez.UI.ButtonGroup">
            <summary>
            Manages a group of buttons to enforce a minimum and maximum number of checked buttons. This enables "radio button"
            functionality and more. A button may only be in one group at a time.
            
            The {@link #canCheck(Button, boolean)} method can be overridden to control if a button check or uncheck is allowed.
            </summary>
        </member>
        <member name="M:Nez.UI.ButtonGroup.SetChecked(System.String)">
            <summary>
            Sets the first {@link TextButton} with the specified text to checked.
            </summary>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.UI.ButtonGroup.CanCheck(Nez.UI.Button,System.Boolean)">
            <summary>
            Called when a button is checked or unchecked. If overridden, generally changing button checked states should not be done
            from within this method.
            </summary>
            <returns>True if the new state should be allowed</returns>
            <param name="button">Button.</param>
            <param name="newState">New state.</param>
        </member>
        <member name="M:Nez.UI.ButtonGroup.UncheckAll">
            <summary>
            Sets all buttons' {@link Button#isChecked()} to false, regardless of {@link #setMinCheckCount(int)}.
            </summary>
        </member>
        <member name="M:Nez.UI.ButtonGroup.GetChecked">
            <summary>
            The first checked button, or null.
            </summary>
            <returns>The checked.</returns>
        </member>
        <member name="M:Nez.UI.ButtonGroup.GetCheckedIndex">
            <summary>
            The first checked button index, or -1
            </summary>
            <returns>The checked index.</returns>
        </member>
        <member name="M:Nez.UI.ButtonGroup.SetMinCheckCount(System.Int32)">
            <summary>
            Sets the minimum number of buttons that must be checked. Default is 1.
            </summary>
            <param name="minCheckCount">Minimum check count.</param>
        </member>
        <member name="M:Nez.UI.ButtonGroup.SetMaxCheckCount(System.Int32)">
            <summary>
            Sets the maximum number of buttons that can be checked. Set to -1 for no maximum. Default is 1.
            </summary>
            <param name="maxCheckCount">Max check count.</param>
        </member>
        <member name="M:Nez.UI.ButtonGroup.SetUncheckLast(System.Boolean)">
            <summary>
            If true, when the maximum number of buttons are checked and an additional button is checked, the last button to be checked
            is unchecked so that the maximum is not exceeded. If false, additional buttons beyond the maximum are not allowed to be
            checked. Default is true.
            </summary>
            <param name="uncheckLast">Uncheck last.</param>
        </member>
        <member name="T:Nez.UI.CheckBox">
            <summary>
            A checkbox is a button that contains an image indicating the checked or unchecked state and a label
            </summary>
        </member>
        <member name="M:Nez.UI.CheckBox.GetStyle">
            <summary>
            Returns the checkbox's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is called
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="T:Nez.UI.CheckBoxStyle">
            <summary>
            The style for a select box
            </summary>
        </member>
        <member name="F:Nez.UI.CheckBoxStyle.CheckboxOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.CheckBoxStyle.CheckboxOnDisabled">
            Optional. 
        </member>
        <member name="F:Nez.UI.CheckBoxStyle.CheckboxOffDisabled">
            Optional. 
        </member>
        <member name="T:Nez.UI.Dialog">
            <summary>
            Displays a dialog, which is a modal window containing a content table with a button table underneath it. Methods are provided
            to add a label to the content table and buttons to the button table, but any widgets can be added. When a button is clicked,
            {@link #result(Object)} is called and the dialog is removed from the stage.
            </summary>
        </member>
        <member name="M:Nez.UI.Dialog.AddText(System.String)">
            <summary>
            Adds a label to the content table
            </summary>
            <returns>The text.</returns>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.UI.Dialog.AddText(Nez.UI.Label)">
            <summary>
            Adds the given Label to the content table
            </summary>
            <param name="label">Label.</param>
        </member>
        <member name="M:Nez.UI.Dialog.AddButton(System.String,Nez.UI.TextButtonStyle)">
            Adds a text button to the button table.
            @param object The object that will be passed to {@link #result(Object)} if this button is clicked. May be null. 
        </member>
        <member name="M:Nez.UI.Dialog.AddButton(Nez.UI.Button)">
            Adds the given button to the button table.
            @param object The object that will be passed to {@link #result(Object)} if this button is clicked. May be null. 
        </member>
        <member name="M:Nez.UI.Dialog.Show(Nez.UI.Stage)">
            <summary>
            {@link #pack() Packs} the dialog and adds it to the stage
            </summary>
            <param name="stage">Stage.</param>
        </member>
        <member name="M:Nez.UI.Dialog.Hide">
            <summary>
            Hides the dialog
            </summary>
        </member>
        <member name="T:Nez.UI.IconButton">
            <summary>
            Button with a background and an icon
            </summary>
        </member>
        <member name="M:Nez.UI.Image.SetAlignment(Nez.UI.Align)">
             <summary>
            
             </summary>
             <param name="alignment">Alignment.</param>
        </member>
        <member name="T:Nez.UI.ImageButton">
            <summary>
            A button with a child {@link Image} to display an image. This is useful when the button must be larger than the image and the
            image centered on the button. If the image is the size of the button, a {@link Button} without any children can be used, where
            the {@link Button.ButtonStyle#up}, {@link Button.ButtonStyle#down}, and {@link Button.ButtonStyle#checked} nine patches define
            the image.
            </summary>
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageUp">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageDown">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageChecked">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageCheckedOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageButtonStyle.ImageDisabled">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageUp">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageDown">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageChecked">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageCheckedOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.ImageTextButtonStyle.ImageDisabled">
            Optional. 
        </member>
        <member name="M:Nez.UI.Label.GetStyle">
            <summary>
            Returns the button's style. Modifying the returned style may not have an effect until {@link #setStyle(ButtonStyle)} is called.
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.Label.SetBackground(Nez.UI.IDrawable)">
            <summary>
            background may be null to clear the background.
            </summary>
            <returns>this</returns>
            <param name="background">Background.</param>
        </member>
        <member name="M:Nez.UI.Label.SetAlignment(Nez.UI.Align)">
            <summary>
            alignment Aligns all the text within the label (default left center) and each line of text horizontally (default left)
            </summary>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.Label.SetAlignment(Nez.UI.Align,Nez.UI.Align)">
            <summary>
            labelAlign Aligns all the text within the label (default left center).
            lineAlign Aligns each line of text horizontally (default left).
            </summary>
            <param name="labelAlign">Label align.</param>
            <param name="lineAlign">Line align.</param>
        </member>
        <member name="M:Nez.UI.Label.SetEllipsis(System.String)">
            <summary>
            When non-null the text will be truncated "..." if it does not fit within the width of the label. Wrapping will not occur
            when ellipsis is enabled. Default is null.
            </summary>
            <param name="ellipsis">Ellipsis.</param>
        </member>
        <member name="M:Nez.UI.Label.SetEllipsis(System.Boolean)">
            <summary>
            When true the text will be truncated "..." if it does not fit within the width of the label. Wrapping will not occur when
            ellipsis is true. Default is false.
            </summary>
            <param name="ellipsis">Ellipsis.</param>
        </member>
        <member name="M:Nez.UI.Label.SetWrap(System.Boolean)">
            <summary>
            should the text be wrapped?
            </summary>
            <param name="shouldWrap">If set to <c>true</c> should wrap.</param>
        </member>
        <member name="T:Nez.UI.LabelStyle">
            <summary>
            the style for a label
            </summary>
        </member>
        <member name="T:Nez.UI.ListBox`1">
            <summary>
            displays textual items and highlights the currently selected item
            </summary>
        </member>
        <member name="M:Nez.UI.ListBox`1.GetStyle">
            <summary>
            Returns the list's style. Modifying the returned style may not have an effect until setStyle(ListStyle) is called
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.ListBox`1.GetSelected">
            <summary>
            Returns the first selected item, or null
            </summary>
            <returns>The selected.</returns>
        </member>
        <member name="M:Nez.UI.ListBox`1.SetSelected(`0)">
            <summary>
            Sets the selection to only the passed item, if it is a possible choice.
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.UI.ListBox`1.GetSelectedIndex">
            <summary>
            gets the index of the first selected item. The top item has an index of 0. Nothing selected has an index of -1.
            </summary>
            <returns>The selected index.</returns>
        </member>
        <member name="M:Nez.UI.ListBox`1.SetSelectedIndex(System.Int32)">
            <summary>
            Sets the selection to only the selected index
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.UI.ListBox`1.SetItems(System.Collections.Generic.IList{`0})">
            <summary>
            Sets the items visible in the list, clearing the selection if it is no longer valid. If a selection is
            ArraySelection#getRequired(), the first item is selected.
            </summary>
            <param name="newItems">New items.</param>
        </member>
        <member name="M:Nez.UI.ListBox`1.GetItems">
            <summary>
            Returns the internal items array. If modified, {@link #setItems(Array)} must be called to reflect the changes.
            </summary>
            <returns>The items.</returns>
        </member>
        <member name="F:Nez.UI.ListBoxStyle.HoverSelection">
            Optional 
        </member>
        <member name="F:Nez.UI.ListBoxStyle.Background">
            Optional 
        </member>
        <member name="M:Nez.UI.ProgressBar.GetStyle">
            <summary>
            Returns the progress bar's style. Modifying the returned style may not have an effect until
            {@link #setStyle(ProgressBarStyle)} is called.
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.ProgressBar.SetValue(System.Single,System.Boolean)">
            <summary>
            Sets the progress bar position, rounded to the nearest step size and clamped to the minimum and maximum values.
            </summary>
            <param name="value">Value.</param>
            <param name="ignoreSnap">If set to <c>true</c> we ignore value snapping.</param>
        </member>
        <member name="M:Nez.UI.ProgressBar.SetTotalSteps(System.Int32)">
            <summary>
            Sets stepSize to a value that will evenly divide this progress bar into specified amount of steps.
            </summary>
            <param name="totalSteps">Total amount of steps.</param>
        </member>
        <member name="M:Nez.UI.ProgressBar.Snap(System.Single)">
            <summary>
            Returns a snapped value
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="T:Nez.UI.ProgressBarStyle">
            <summary>
            The style for a progress bar
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.Background">
            <summary>
            The progress bar background, stretched only in one direction. Optional.
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.DisabledBackground">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.Knob">
            <summary>
            Optional, centered on the background.
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.DisabledKnob">
            <summary>
            Optional, centered on the background.
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.KnobBefore">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.KnobAfter">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.DisabledKnobBefore">
            <summary>
            Optional
            </summary>
        </member>
        <member name="F:Nez.UI.ProgressBarStyle.DisabledKnobAfter">
            <summary>
            Optional
            </summary>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetMaxListCount(System.Int32)">
            <summary>
            Set the max number of items to display when the select box is opened. Set to 0 (the default) to display as many as fit in
            the stage height.
            </summary>
            <returns>The max list count.</returns>
            <param name="maxListCount">Max list count.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.UI.SelectBox`1.GetMaxListCount" -->
        <member name="M:Nez.UI.SelectBox`1.GetStyle">
            <summary>
            Returns the select box's style. Modifying the returned style may not have an effect until setStyle(SelectBoxStyle)
            is called.
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetItems(`0[])">
            <summary>
            Set the backing Array that makes up the choices available in the SelectBox
            </summary>
            <returns>The items.</returns>
            <param name="newItems">New items.</param>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetItems(System.Collections.Generic.List{`0})">
            <summary>
            Sets the items visible in the select box
            </summary>
            <returns>The items.</returns>
            <param name="newItems">New items.</param>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetItems">
            <summary>
            Returns the internal items array. If modified, setItems(Array) must be called to reflect the changes.
            </summary>
            <returns>The items.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetSelection">
            <summary>
            Get the set of selected items, useful when multiple items are selected returns a Selection object containing the
            selected elements
            </summary>
            <returns>The selection.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetSelected">
            <summary>
            Returns the first selected item, or null. For multiple selections use SelectBox#getSelection()
            </summary>
            <returns>The selected.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetSelected(`0)">
            <summary>
            Sets the selection to only the passed item, if it is a possible choice, else selects the first item.
            </summary>
            <returns>The selected.</returns>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetSelectedIndex">
            <summary>
            returns The index of the first selected item. The top item has an index of 0. Nothing selected has an index of -1.
            </summary>
            <returns>The selected index.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetSelectedIndex(System.Int32)">
            <summary>
            Sets the selection to only the selected index
            </summary>
            <returns>The selected index.</returns>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetListBox">
            <summary>
            Returns the ListBox shown when the select box is open
            </summary>
            <returns>The list.</returns>
        </member>
        <member name="M:Nez.UI.SelectBox`1.SetScrollingDisabled(System.Boolean)">
            <summary>
            Disables scrolling of the list shown when the select box is open.
            </summary>
            <returns>The scrolling disabled.</returns>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.SelectBox`1.GetScrollPane">
            <summary>
            Returns the scroll pane containing the list that is shown when the select box is open.
            </summary>
            <returns>The scroll pane.</returns>
        </member>
        <member name="F:Nez.UI.SelectBoxStyle.DisabledFontColor">
            Optional 
        </member>
        <member name="F:Nez.UI.SelectBoxStyle.Background">
            Optional 
        </member>
        <member name="F:Nez.UI.SelectBoxStyle.BackgroundOver">
            Optional 
        </member>
        <member name="F:Nez.UI.SelectBoxStyle.BackgroundOpen">
            Optional 
        </member>
        <member name="F:Nez.UI.SelectBoxStyle.BackgroundDisabled">
            Optional 
        </member>
        <member name="F:Nez.UI.Slider.SliderBoundaryThreshold">
            <summary>
            the maximum distance outside the slider the mouse can move when pressing it to cause it to be unfocused
            </summary>
        </member>
        <member name="M:Nez.UI.Slider.#ctor(System.Single,System.Single,System.Single,System.Boolean,Nez.UI.SliderStyle)">
            <summary>
            Creates a new slider. It's width is determined by the given prefWidth parameter, its height is determined by the maximum of
             the height of either the slider {@link NinePatch} or slider handle {@link TextureRegion}. The min and max values determine
            the range the values of this slider can take on, the stepSize parameter specifies the distance between individual values.
            E.g. min could be 4, max could be 10 and stepSize could be 0.2, giving you a total of 30 values, 4.0 4.2, 4.4 and so on.
            </summary>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
            <param name="stepSize">Step size.</param>
            <param name="vertical">If set to <c>true</c> vertical.</param>
            <param name="background">Background.</param>
        </member>
        <member name="M:Nez.UI.Slider.GetStyle">
            <summary>
            Returns the slider's style. Modifying the returned style may not have an effect until {@link #setStyle(SliderStyle)} is called
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="F:Nez.UI.SliderStyle.KnobOver">
            Optional. 
        </member>
        <member name="F:Nez.UI.SliderStyle.KnobDown">
            Optional. 
        </member>
        <member name="T:Nez.UI.TextButtonStyle">
            <summary>
            The style for a text button
            </summary>
        </member>
        <member name="F:Nez.UI.TextButtonStyle.FontColor">
            Optional. 
        </member>
        <member name="T:Nez.UI.TextField">
             <summary>
             A single-line text input field.
            
             The preferred height of a text field is the height of the {@link TextFieldStyle#font} and {@link TextFieldStyle#background}.
             The preferred width of a text field is 150, a relatively arbitrary size.
            
             The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is
             pressed. Clipboard functionality is provided via the {@link Clipboard} interface.
            
             The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events
             generated by the keyboard to the text field. There are two standard implementations, one for the desktop and one for Android.
             The desktop keyboard is a stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard}
             implementation will bring up the default IME.
             </summary>
        </member>
        <member name="F:Nez.UI.TextField.TextFieldBoundaryThreshold">
            <summary>
            the maximum distance outside the TextField the mouse can move when pressing it to cause it to be unfocused
            </summary>
        </member>
        <member name="F:Nez.UI.TextField.ShouldIgnoreTextUpdatesWhileFocused">
            <summary>
            if true and setText is called it will be ignored
            </summary>
        </member>
        <member name="M:Nez.UI.TextField.SetOnlyFontChars(System.Boolean)">
            <summary>
            When false, text set by {@link #setText(String)} may contain characters not in the font, a space will be displayed instead.
            When true (the default), characters not in the font are stripped by setText. Characters not in the font are always stripped
            when typed or pasted.
            </summary>
            <param name="onlyFontChars">If set to <c>true</c> only font chars.</param>
        </member>
        <member name="M:Nez.UI.TextField.GetStyle">
            <summary>
            Returns the text field's style. Modifying the returned style may not have an effect until {@link #setStyle(TextFieldStyle)} is called
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="M:Nez.UI.TextField.DrawSelection(Nez.UI.IDrawable,Nez.Batcher,Nez.BitmapFonts.BitmapFont,System.Single,System.Single)">
            <summary>
            Draws selection rectangle
            </summary>
            <param name="selection">Selection.</param>
            <param name="batch">Batch.</param>
            <param name="font">Font.</param>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
        </member>
        <member name="M:Nez.UI.TextField.Copy">
            <summary>
            Copies the contents of this TextField to the {@link Clipboard} implementation set on this TextField
            </summary>
        </member>
        <member name="M:Nez.UI.TextField.Cut">
            <summary>
            Copies the selected contents of this TextField to the {@link Clipboard} implementation set on this TextField, then removes it
            </summary>
        </member>
        <member name="M:Nez.UI.TextField.Next(System.Boolean)">
            <summary>
            Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage
            up: If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
            </summary>
            <param name="up">Up.</param>
        </member>
        <member name="M:Nez.UI.TextField.AppendText(System.String)">
            <summary>
            if str is null, "" is used
            </summary>
            <param name="str">String.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetText(System.String)">
            <summary>
            str If null, "" is used
            </summary>
            <param name="str">String.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetTextForced(System.String)">
            <summary>
            force sets the text without validating or firing change events. Use at your own risk.
            </summary>
            <param name="str">String.</param>
        </member>
        <member name="M:Nez.UI.TextField.GetText">
            <summary>
            Never null, might be an empty string
            </summary>
            <returns>The text.</returns>
        </member>
        <member name="M:Nez.UI.TextField.ChangeText(System.String,System.String)">
            <summary>
            oldText May be null
            </summary>
            <param name="oldText">Old text.</param>
            <param name="newText">New text.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetProgrammaticChangeEvents(System.Boolean)">
            <summary>
            If false, methods that change the text will not fire {@link onTextChanged}, the event will be fired only when user changes the text
            </summary>
            <param name="programmaticChangeEvents">If set to <c>true</c> programmatic change events.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetSelection(System.Int32,System.Int32)">
            <summary>
            Sets the selected text
            </summary>
            <param name="selectionStart">Selection start.</param>
            <param name="selectionEnd">Selection end.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetCursorPosition(System.Int32)">
            <summary>
            Sets the cursor position and clears any selection
            </summary>
            <param name="cursorPosition">Cursor position.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetTextFieldFilter(Nez.UI.TextField.ITextFieldFilter)">
            <summary>
            filter May be null
            </summary>
            <param name="filter">Filter.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetFocusTraversal(System.Boolean)">
            <summary>
            If true (the default), tab/shift+tab will move to the next text field
            </summary>
            <param name="focusTraversal">If set to <c>true</c> focus traversal.</param>
        </member>
        <member name="M:Nez.UI.TextField.GetMessageText">
            <summary>
            May be null
            </summary>
            <returns>The message text.</returns>
        </member>
        <member name="M:Nez.UI.TextField.SetMessageText(System.String)">
            <summary>
            Sets the text that will be drawn in the text field if no text has been entered.
            </summary>
            <param name="messageText">Message text.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetAlignment(Nez.UI.Align)">
            <summary>
            Sets text horizontal alignment (left, center or right).
            </summary>
            <param name="alignment">Alignment.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetPasswordMode(System.Boolean)">
            <summary>
            If true, the text in this text field will be shown as bullet characters.
            </summary>
            <param name="passwordMode">Password mode.</param>
        </member>
        <member name="M:Nez.UI.TextField.SetPasswordCharacter(System.Char)">
            <summary>
            Sets the password character for the text field. The character must be present in the {@link BitmapFont}. Default is 149 (bullet)
            </summary>
            <param name="passwordCharacter">Password character.</param>
        </member>
        <member name="T:Nez.UI.TextField.ITextFieldFilter">
            <summary>
            Interface for filtering characters entered into the text field.
            </summary>
        </member>
        <member name="F:Nez.UI.TextFieldStyle.FocusedFontColor">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.DisabledFontColor">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.Background">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.FocusedBackground">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.DisabledBackground">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.Cursor">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.Selection">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.MessageFont">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextFieldStyle.MessageFontColor">
            Optional. 
        </member>
        <member name="F:Nez.UI.TextTooltipStyle.Background">
            Optional. 
        </member>
        <member name="T:Nez.UI.Tooltip">
            <summary>
            A listener that shows a tooltip Element when another Element is hovered over with the mouse.
            </summary>
        </member>
        <member name="M:Nez.UI.Tooltip.SetInstant(System.Boolean)">
            <summary>
            If true, this tooltip is shown without delay when hovered
            </summary>
            <param name="instant">Instant.</param>
        </member>
        <member name="M:Nez.UI.Tooltip.SetAlways(System.Boolean)">
            <summary>
            If true, this tooltip is shown even when tooltips are not TooltipManager#enabled
            </summary>
            <param name="always">Always.</param>
        </member>
        <member name="T:Nez.UI.Window">
             <summary>
             A table that can be dragged and resized. The top padding is used as the window's title height.
            
             The preferred size of a window is the preferred size of the title text and the children as laid out by the table. After adding
             children to the window, it can be convenient to call {@link #pack()} to size the window to the size of the children.
             </summary>
        </member>
        <member name="M:Nez.UI.Window.GetStyle">
            <summary>
            Returns the window's style. Modifying the returned style may not have an effect until {@link #setStyle(WindowStyle)} is called
            </summary>
            <returns>The style.</returns>
        </member>
        <member name="F:Nez.UI.WindowStyle.TitleFontScaleX">
            Optional. 
        </member>
        <member name="F:Nez.UI.WindowStyle.TitleFontScaleY">
            Optional. 
        </member>
        <member name="F:Nez.UI.WindowStyle.Background">
            Optional. 
        </member>
        <member name="F:Nez.UI.WindowStyle.TitleFontColor">
            Optional. 
        </member>
        <member name="F:Nez.UI.WindowStyle.StageBackground">
            Optional. 
        </member>
        <member name="T:Nez.IMGUI">
            <summary>
            IMGUI is a very simple class with only static methods designed to make sticking buttons, checkboxes, sliders and progress bars on screen
            in quick and dirty fashion. It is not designed to be a full and proper UI system.
            </summary>
        </member>
        <member name="M:Nez.IMGUI.BeginWindow(System.Single,System.Single,System.Single,System.Single,System.Boolean)">
            <summary>
            begins an IMGUI window specifying where and how large it should be. If you are not using IMGUI in world space (for example, inside
            a Scene with a scaled resolution policy) passing false for useRawMousePosition will use the Input.scaledMousePosition.
            </summary>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
            <param name="useRawMousePosition">If set to <c>true</c> use raw mouse position.</param>
        </member>
        <member name="M:Nez.IMGUI.Toggle(System.String,System.Boolean)">
            <summary>
            creates a checkbox/toggle
            </summary>
            <param name="text">Text.</param>
            <param name="isChecked">If set to <c>true</c> is checked.</param>
        </member>
        <member name="M:Nez.IMGUI.Slider(System.Single,System.String)">
            <summary>
            value should be between 0 and 1
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.IMGUI.ProgressBar(System.Single)">
            <summary>
            value should be between 0 and 1
            </summary>
            <returns>The bar.</returns>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.IMGUI.Header(System.String)">
            <summary>
            creates a full width header with text
            </summary>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.IMGUI.Space(System.Single)">
            <summary>
            adds some vertical space
            </summary>
            <param name="verticalSpace">Vertical space.</param>
        </member>
        <member name="T:Nez.Analysis.Alignment">
            <summary>
            Alignment for layout.
            </summary>
        </member>
        <member name="T:Nez.Analysis.Layout">
            <summary>
            Layout class that supports title safe area.
            </summary>
            <remarks>
            You have to support various resolutions when you develop multi-platform
            games. Also, you have to support title safe area for Xbox 360 games.
            
            This structure places given rectangle with specified alignment and margin
            based on layout area (client area) with safe area.
            
            Margin is percentage of client area size.
            
            Example:
            
            Place( region, 0.1f, 0.2f, Aligment.TopLeft );
            
            Place region at 10% from left side of the client area,
            20% from top of the client area.
            
            
            Place( region, 0.3f, 0.4f, Aligment.BottomRight );
            
            Place region at 30% from right side of client,
            40% from the bottom of the client area.
            
            
            You can individually specify client area and safe area.
            So, it is useful when you have split screen game which layout happens based
            on client and it takes care of the safe at same time.
            
            </remarks>
        </member>
        <member name="F:Nez.Analysis.Layout.ClientArea">
            <summary>
            Gets/Sets client area.
            </summary>
        </member>
        <member name="F:Nez.Analysis.Layout.SafeArea">
            <summary>
            Gets/Sets safe area.
            </summary>
        </member>
        <member name="M:Nez.Analysis.Layout.#ctor(Microsoft.Xna.Framework.Rectangle,Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Construct layout object by specify both client area and safe area.
            </summary>
            <param name="client">Client area</param>
            <param name="safeArea">safe area</param>
        </member>
        <member name="M:Nez.Analysis.Layout.#ctor(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Construct layout object by specify client area.
            Safe area becomes same size as client area.
            </summary>
            <param name="client">Client area</param>
        </member>
        <member name="M:Nez.Analysis.Layout.#ctor(Microsoft.Xna.Framework.Graphics.Viewport)">
            <summary>
            Construct layout object by specify viewport.
            Safe area becomes same as Viewpoert.TItleSafeArea.
            </summary>
        </member>
        <member name="M:Nez.Analysis.Layout.Place(Microsoft.Xna.Framework.Vector2,System.Single,System.Single,Nez.Analysis.Alignment)">
            <summary>
            Layouting specified region
            </summary>
            <param name="region">placing region</param>
            <returns>Placed position</returns>
        </member>
        <member name="M:Nez.Analysis.Layout.Place(Microsoft.Xna.Framework.Rectangle,System.Single,System.Single,Nez.Analysis.Alignment)">
            <summary>
            Layouting specified region
            </summary>
            <param name="region">placing rectangle</param>
            <returns>placed rectangle</returns>
        </member>
        <member name="T:Nez.Audio.AudioSource">
            <summary>
            plays a collection of SoundEffects randomly and optionally with random pitch
            </summary>
        </member>
        <member name="M:Nez.Audio.AudioSource.SetPitchRange(System.Single,System.Single)">
            <summary>
            if a pitch range is set every time play is called a random pitch will be used
            </summary>
            <returns>The pitch range.</returns>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Audio.AudioSource.SetPanRange(System.Single,System.Single)">
            <summary>
            if a pan range is set every time play is called a random pan will be used
            </summary>
            <returns>The pan range.</returns>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.Audio.AudioSource.AddSoundEffect(Microsoft.Xna.Framework.Audio.SoundEffect)">
            <summary>
            adds a SoundEffect to the AudioSource
            </summary>
            <returns>The sound effect.</returns>
            <param name="effect">Effect.</param>
        </member>
        <member name="T:Nez.FastList`1">
            <summary>
            very basic wrapper around an array that auto-expands it when it reaches capacity. Note that when iterating it should be done
            like this accessing the buffer directly but using the FastList.length field:
            
            for( var i = 0; i &lt;= list.length; i++ )
            	var item = list.buffer[i];
            </summary>
        </member>
        <member name="F:Nez.FastList`1.Buffer">
            <summary>
            direct access to the backing buffer. Do not use buffer.Length! Use FastList.length
            </summary>
        </member>
        <member name="F:Nez.FastList`1.Length">
            <summary>
            direct access to the length of the filled items in the buffer. Do not change.
            </summary>
        </member>
        <member name="P:Nez.FastList`1.Item(System.Int32)">
            <summary>
            provided for ease of access though it is recommended to just access the buffer directly.
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.FastList`1.Clear">
            <summary>
            clears the list and nulls out all items in the buffer
            </summary>
        </member>
        <member name="M:Nez.FastList`1.Reset">
            <summary>
            works just like clear except it does not null our all the items in the buffer. Useful when dealing with structs.
            </summary>
        </member>
        <member name="M:Nez.FastList`1.Add(`0)">
            <summary>
            adds the item to the list
            </summary>
        </member>
        <member name="M:Nez.FastList`1.Remove(`0)">
            <summary>
            removes the item from the list
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.FastList`1.RemoveAt(System.Int32)">
            <summary>
            removes the item at the given index from the list
            </summary>
        </member>
        <member name="M:Nez.FastList`1.RemoveAtWithSwap(System.Int32)">
            <summary>
            removes the item at the given index from the list but does NOT maintain list order
            </summary>
            <param name="index">Index.</param>
        </member>
        <member name="M:Nez.FastList`1.Contains(`0)">
            <summary>
            checks to see if item is in the FastList
            </summary>
            <param name="item">Item.</param>
        </member>
        <member name="M:Nez.FastList`1.EnsureCapacity(System.Int32)">
            <summary>
            if the buffer is at its max more space will be allocated to fit additionalItemCount
            </summary>
        </member>
        <member name="M:Nez.FastList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            adds all items from array
            </summary>
            <param name="array">Array.</param>
        </member>
        <member name="M:Nez.FastList`1.Sort">
            <summary>
            sorts all items in the buffer up to length
            </summary>
        </member>
        <member name="M:Nez.FastList`1.Sort(System.Collections.IComparer)">
            <summary>
            sorts all items in the buffer up to length
            </summary>
        </member>
        <member name="M:Nez.FastList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            sorts all items in the buffer up to length
            </summary>
        </member>
        <member name="T:Nez.ListPool`1">
            <summary>
            simple static class that can be used to pool Lists
            </summary>
        </member>
        <member name="M:Nez.ListPool`1.WarmCache(System.Int32)">
            <summary>
            warms up the cache filling it with a max of cacheCount objects
            </summary>
            <param name="cacheCount">new cache count</param>
        </member>
        <member name="M:Nez.ListPool`1.TrimCache(System.Int32)">
            <summary>
            trims the cache down to cacheCount items
            </summary>
            <param name="cacheCount">Cache count.</param>
        </member>
        <member name="M:Nez.ListPool`1.ClearCache">
            <summary>
            clears out the cache
            </summary>
        </member>
        <member name="M:Nez.ListPool`1.Obtain">
            <summary>
            pops an item off the stack if available creating a new item as necessary
            </summary>
        </member>
        <member name="M:Nez.ListPool`1.Free(System.Collections.Generic.List{`0})">
            <summary>
            pushes an item back on the stack
            </summary>
            <param name="obj">Object.</param>
        </member>
        <member name="T:Nez.Pair`1">
            <summary>
            simple DTO for managing a pair of objects
            </summary>
        </member>
        <member name="T:Nez.Pool`1">
            <summary>
            simple static class that can be used to pool any object
            </summary>
        </member>
        <member name="M:Nez.Pool`1.WarmCache(System.Int32)">
            <summary>
            warms up the cache filling it with a max of cacheCount objects
            </summary>
            <param name="cacheCount">new cache count</param>
        </member>
        <member name="M:Nez.Pool`1.TrimCache(System.Int32)">
            <summary>
            trims the cache down to cacheCount items
            </summary>
            <param name="cacheCount">Cache count.</param>
        </member>
        <member name="M:Nez.Pool`1.ClearCache">
            <summary>
            clears out the cache
            </summary>
        </member>
        <member name="M:Nez.Pool`1.Obtain">
            <summary>
            pops an item off the stack if available creating a new item as necessary
            </summary>
        </member>
        <member name="M:Nez.Pool`1.Free(`0)">
            <summary>
            pushes an item back on the stack
            </summary>
            <param name="obj">Object.</param>
        </member>
        <member name="T:Nez.IPoolable">
            <summary>
            Objects implementing this interface will have <see cref="M:Nez.IPoolable.Reset"/> called when passed to <see cref="!:Pool.Free"/>
            </summary>
        </member>
        <member name="M:Nez.IPoolable.Reset">
            <summary>
            Resets the object for reuse. Object references should be nulled and fields may be set to default values
            </summary>
        </member>
        <member name="T:Nez.ICoroutine">
            <summary>
            interface returned by startCoroutine which provides the ability to stop the coroutine mid-flight
            </summary>
        </member>
        <member name="M:Nez.ICoroutine.Stop">
            <summary>
            stops the Coroutine
            </summary>
        </member>
        <member name="M:Nez.ICoroutine.SetUseUnscaledDeltaTime(System.Boolean)">
            <summary>
            sets whether the Coroutine should use deltaTime or unscaledDeltaTime for timing
            </summary>
            <returns>The use unscaled delta time.</returns>
            <param name="useUnscaledDeltaTime">If set to <c>true</c> use unscaled delta time.</param>
        </member>
        <member name="M:Nez.Coroutine.WaitForSeconds(System.Single)">
            <summary>
            causes a Coroutine to pause for the specified duration. Yield on Coroutine.waitForSeconds in a coroutine to use.
            </summary>
            <returns>The for seconds.</returns>
            <param name="seconds">Seconds.</param>
        </member>
        <member name="T:Nez.WaitForSeconds">
            <summary>
            helper class for when a coroutine wants to pause for some duration. Returning Coroutine.waitForSeconds returns one of these
            to avoid having to return an int/float and paying the boxing penalty.
            </summary>
        </member>
        <member name="M:Nez.ArrayExt.Contains``1(``0[],``0)">
            <summary>
            checks to see if value exists in source
            </summary>
            <param name="source">Source.</param>
            <param name="value">Value.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ColorExt.Subtract(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color)">
            <summary>
            first - second
            </summary>
        </member>
        <member name="M:Nez.ColorExt.Lerp(Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            linearly interpolates Color from - to
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.ColorExt.Lerp(Microsoft.Xna.Framework.Color@,Microsoft.Xna.Framework.Color@,Microsoft.Xna.Framework.Color@,System.Single)">
            <summary>
            linearly interpolates Color from - to
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <param name="t">T.</param>
        </member>
        <member name="M:Nez.EdgeExt.IsMax(Nez.Edge)">
            <summary>
            returns true if the Edge is Right or Bottom
            </summary>
            <returns>The max.</returns>
            <param name="self">Self.</param>
        </member>
        <member name="M:Nez.EdgeExt.IsMin(Nez.Edge)">
            <summary>
            returns true if the Edge is Left or Top
            </summary>
            <returns>The minimum.</returns>
            <param name="self">Self.</param>
        </member>
        <member name="M:Nez.EdgeExt.IsHorizontal(Nez.Edge)">
            <summary>
            returns true if the Edge is Right or Left
            </summary>
            <returns>The horizontal.</returns>
            <param name="self">Self.</param>
        </member>
        <member name="M:Nez.EdgeExt.IsVertical(Nez.Edge)">
            <summary>
            returns true if the Edge is Top or Bottom
            </summary>
            <returns>The vertical.</returns>
            <param name="self">Self.</param>
        </member>
        <member name="M:Nez.GameServiceContainerExt.AddService``1(Microsoft.Xna.Framework.GameServiceContainer,``0)">
            <summary>
            Adds the service and returns the added service for method chaining
            </summary>
            <returns>The service.</returns>
            <param name="self">Self.</param>
            <param name="provider">Provider.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.GameServiceContainerExt.GetService``1(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>
            Gets the service
            </summary>
            <returns>The service.</returns>
            <param name="self">Self.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.GameServiceContainerExt.GetOrAddService``1(Microsoft.Xna.Framework.GameServiceContainer)">
            <summary>
            attempts to get the service and if it does not exist it will be created. Requires a parameterless
            constructor.
            </summary>
            <returns>The or add service.</returns>
            <param name="self">Self.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.IEnumerableExtensions.IEnumerableExt.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Jon Skeet's excellent reimplementation of LINQ Count.
            </summary>
            <typeparam name="TSource">The source type.</typeparam>
            <param name="source">The source IEnumerable.</param>
            <returns>The number of items in the source.</returns>
        </member>
        <member name="M:Nez.ListExt.Shuffle``1(System.Collections.Generic.IList{``0})">
            <summary>
            shuffles the list in place
            </summary>
            <param name="list">List.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ListExt.AddIfNotPresent``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            returns false if the item is already in the List and true if it was successfully added.
            </summary>
            <returns>The if not present.</returns>
            <param name="list">List.</param>
            <param name="item">Item.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ListExt.LastItem``1(System.Collections.Generic.IList{``0})">
            <summary>
            returns the last item in the list. List should have at least one item.
            </summary>
            <param name="list">List.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ListExt.RandomItem``1(System.Collections.Generic.IList{``0})">
            <summary>
            gets a random item from the list. Does not empty check the list!
            </summary>
            <returns>The item.</returns>
            <param name="list">List.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.ListExt.RandomItems``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            gets random items from the list. Does not empty check the list or verify that list count is greater than item count! The returned List can be put back in the pool via ListPool.free.
            </summary>
            <returns>The item.</returns>
            <param name="list">List.</param>
            <param name="itemCount">The number of random items to return from the list.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="M:Nez.MemberInfoExt.GetAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            for some reason, GetCustomAttributes doesnt actually filter properly and throws a "Multiple custom attributes
            of the same type found" Exception if there are multiple (but differnt) attriburtes. This method fixes that issue.
            </summary>
            <param name="self"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Nez.ObjectExt.Tween(System.Object,System.String,System.Int32,System.Single)">
            <summary>
            tweens an int field or property
            </summary>
        </member>
        <member name="M:Nez.ObjectExt.Tween(System.Object,System.String,System.Single,System.Single)">
            <summary>
            tweens a float field or property
            </summary>
        </member>
        <member name="M:Nez.ObjectExt.Tween(System.Object,System.String,Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            tweens a Color field or property
            </summary>
        </member>
        <member name="M:Nez.ObjectExt.Tween(System.Object,System.String,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            tweens a Vector2 field or property
            </summary>
        </member>
        <member name="M:Nez.ObjectExt.Tween(System.Object,System.String,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            tweens a Vector3 field or property
            </summary>
        </member>
        <member name="M:Nez.RectangleExt.GetSide(Microsoft.Xna.Framework.Rectangle,Nez.Edge)">
            <summary>
            gets the position of the specified side
            </summary>
            <returns>The side.</returns>
            <param name="edge">Side.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetRectEdgePortion(Microsoft.Xna.Framework.Rectangle,Nez.Edge,System.Int32)">
            <summary>
            gets a portion of the Rectangle with a width/height of size that is on the Edge of the Rectangle but still contained within it.
            </summary>
            <returns>The rect edge portion.</returns>
            <param name="rect">Rect.</param>
            <param name="edge">Edge.</param>
            <param name="size">Size.</param>
        </member>
        <member name="M:Nez.RectangleExt.FromFloats(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            returns a rectangle from the passed in floats
            </summary>
            <returns>The floats.</returns>
            <param name="x">The x coordinate.</param>
            <param name="y">The y coordinate.</param>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.RectangleExt.FromMinMaxPoints(Microsoft.Xna.Framework.Point,Microsoft.Xna.Framework.Point)">
            <summary>
            creates a Rectangle given min/max points (top-left, bottom-right points)
            </summary>
            <returns>The minimum max points.</returns>
            <param name="min">Minimum.</param>
            <param name="max">Max.</param>
        </member>
        <member name="M:Nez.RectangleExt.Union(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            calculates the union of the two Rectangles. The result will be a rectangle that encompasses the other two.
            </summary>
        </member>
        <member name="M:Nez.RectangleExt.Union(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Point@,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Update first to be the union of first and point
            </summary>
            <param name="first">First.</param>
            <param name="point">Point.</param>
            <param name="result">Result.</param>
        </member>
        <member name="M:Nez.RectangleExt.BoundsFromPolygonPoints(Microsoft.Xna.Framework.Vector2[])">
            <summary>
            given the points of a polygon calculates the bounds
            </summary>
            <returns>The from polygon points.</returns>
            <param name="points">Points.</param>
        </member>
        <member name="M:Nez.RectangleExt.Clone(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            clones and returns a new Rectangle with the same data as the current rectangle
            </summary>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.RectangleExt.Scale(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            scales the rect
            </summary>
            <param name="rect">Rect.</param>
            <param name="scale">Scale.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetSweptBroadphaseBounds(Microsoft.Xna.Framework.Rectangle@,System.Single,System.Single)">
            <summary>
            returns a Bounds the spans the current bounds and the provided delta positions
            </summary>
            <returns>The swept broadphase box.</returns>
        </member>
        <member name="M:Nez.RectangleExt.GetSweptBroadphaseBounds(Microsoft.Xna.Framework.Rectangle@,System.Int32,System.Int32)">
            <summary>
            returns a Bounds the spans the current bounds and the provided delta positions
            </summary>
            <returns>The swept broadphase box.</returns>
        </member>
        <member name="M:Nez.RectangleExt.Intersect(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            returns true if rect1 intersects rect2
            </summary>
        </member>
        <member name="M:Nez.RectangleExt.CollisionCheck(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Rectangle@,System.Single@,System.Single@)">
            <summary>
            returns true if the boxes are colliding
            moveX and moveY will return the movement that b1 must move to avoid the collision
            </summary>
            <param name="other">Other.</param>
            <param name="moveX">Move x.</param>
            <param name="moveY">Move y.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetIntersectionDepth(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            Calculates the signed depth of intersection between two rectangles.
            </summary>
            <returns>
            The amount of overlap between two intersecting rectangles. These depth values can be negative depending on which sides the rectangles
            intersect. This allows callers to determine the correct direction to push objects in order to resolve collisions.
            If the rectangles are not intersecting, Vector2.Zero is returned.
            </returns>
        </member>
        <member name="M:Nez.RectangleExt.GetClosestPointOnRectangleToPoint(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the closest point that is in or on the Rectangle to the given point
            </summary>
            <returns>The closest point on rectangle to point.</returns>
            <param name="rect">Rect.</param>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetClosestPointOnRectangleBorderToPoint(Microsoft.Xna.Framework.Rectangle@,Microsoft.Xna.Framework.Vector2)">
            <summary>
            gets the closest point that is on the rectangle border to the given point
            </summary>
            <returns>The closest point on rectangle border to point.</returns>
            <param name="rect">Rect.</param>
            <param name="point">Point.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetCenter(Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            gets the center point of the rectangle as a Vector2
            </summary>
            <returns>The center.</returns>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetCenter(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            gets the center point of the rectangle as a Vector2
            </summary>
            <returns>The center.</returns>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetHalfSize(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            gets the half size of the rect
            </summary>
            <returns>The half size.</returns>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetMax(Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            gets the max point of the rectangle, the bottom-right corner
            </summary>
            <returns>The max.</returns>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.RectangleExt.GetSize(Microsoft.Xna.Framework.Rectangle)">
            <summary>
            Gets the size of the Rectangle
            </summary>
        </member>
        <member name="M:Nez.RectangleExt.GetPosition(Microsoft.Xna.Framework.Rectangle@)">
            <summary>
            gets the position of the rectangle as a Vector2
            </summary>
            <returns>The position.</returns>
            <param name="rect">Rect.</param>
        </member>
        <member name="M:Nez.SpriteBatchExt.DrawPoints(Microsoft.Xna.Framework.Graphics.SpriteBatch,System.Collections.Generic.List{Microsoft.Xna.Framework.Vector2},Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
        </member>
        <member name="M:Nez.SpriteBatchExt.DrawPoints(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
        </member>
        <member name="M:Nez.SpriteBatchExt.DrawPoints(Microsoft.Xna.Framework.Graphics.SpriteBatch,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2[],Microsoft.Xna.Framework.Color,System.Boolean,System.Single)">
            <summary>
            Draws a list of connected points
            </summary>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
            <param name="closePoly">If set to <c>true</c> the first and last points will be connected.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Normalize(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            temporary workaround to Vector2.Normalize screwing up the 0,0 vector
            </summary>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Normalize(Microsoft.Xna.Framework.Vector2)">
            <summary>
            temporary workaround to Vector2.Normalize screwing up the 0,0 vector
            </summary>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Round(Microsoft.Xna.Framework.Vector2)">
            <summary>
            rounds the x and y values
            </summary>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Round(Microsoft.Xna.Framework.Vector2@)">
            <summary>
            rounds the x and y values in place
            </summary>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.HalfVector">
            <summary>
            returns a 0.5, 0.5 vector
            </summary>
            <returns>The vector.</returns>
        </member>
        <member name="M:Nez.Vector2Ext.Cross(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            compute the 2d pseudo cross product Dot( Perp( u ), v )
            </summary>
            <param name="u">U.</param>
            <param name="v">V.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Perpendicular(Microsoft.Xna.Framework.Vector2@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            returns the vector perpendicular to the passed in vectors
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Perpendicular(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the vector perpendicular to the passed in vectors
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Perpendicular(Microsoft.Xna.Framework.Vector2)">
            <summary>
            flips the x/y values and inverts the y to get the perpendicular
            </summary>
            <param name="original">Original.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Angle(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the angle between the two vectors in degrees
            </summary>
            <param name="from">From.</param>
            <param name="to">To.</param>
        </member>
        <member name="M:Nez.Vector2Ext.AngleBetween(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            returns the angle between left and right with self being the center point in degrees
            </summary>
            <param name="self">Self.</param>
            <param name="left">V left.</param>
            <param name="right">V right.</param>
        </member>
        <member name="M:Nez.Vector2Ext.GetRayIntersection(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            given two lines (ab and cd) finds the intersection point
            </summary>
            <returns>The ray intersection.</returns>
            <param name="a">The alpha component.</param>
            <param name="b">The blue component.</param>
            <param name="c">C.</param>
            <param name="d">D.</param>
        </member>
        <member name="M:Nez.Vector2Ext.RoundToPoint(Microsoft.Xna.Framework.Vector2)">
            <summary>
            rounds and converts a Vector2 to a Point
            </summary>
            <returns>The point.</returns>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.ToVector3(Microsoft.Xna.Framework.Vector2)">
            <summary>
            converts a Vector2 to a Vector3 with a 0 z-position
            </summary>
            <returns>The vector3.</returns>
            <param name="vec">Vec.</param>
        </member>
        <member name="M:Nez.Vector2Ext.IsTriangleCCW(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2)">
            <summary>
            checks if a triangle is CCW or CW
            </summary>
            <returns><c>true</c>, if triangle ccw was ised, <c>false</c> otherwise.</returns>
            <param name="a">The alpha component.</param>
            <param name="center">Center.</param>
            <param name="c">C.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Transform(Microsoft.Xna.Framework.Vector2,Nez.Matrix2D)">
            <summary>
            Creates a new <see cref="T:Microsoft.Xna.Framework.Vector2"/> that contains a transformation of 2d-vector by the specified <see cref="T:Microsoft.Xna.Framework.Matrix"/>.
            </summary>
            <param name="position">Source <see cref="T:Microsoft.Xna.Framework.Vector2"/>.</param>
            <param name="matrix">The transformation <see cref="T:Microsoft.Xna.Framework.Matrix"/>.</param>
            <returns>Transformed <see cref="T:Microsoft.Xna.Framework.Vector2"/>.</returns>
        </member>
        <member name="M:Nez.Vector2Ext.Transform(Microsoft.Xna.Framework.Vector2@,Nez.Matrix2D@,Microsoft.Xna.Framework.Vector2@)">
            <summary>
            Creates a new <see cref="T:Microsoft.Xna.Framework.Vector2"/> that contains a transformation of 2d-vector by the specified <see cref="T:Microsoft.Xna.Framework.Matrix"/>.
            </summary>
            <param name="position">Source <see cref="T:Microsoft.Xna.Framework.Vector2"/>.</param>
            <param name="matrix">The transformation <see cref="T:Microsoft.Xna.Framework.Matrix"/>.</param>
            <param name="result">Transformed <see cref="T:Microsoft.Xna.Framework.Vector2"/> as an output parameter.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Transform(Microsoft.Xna.Framework.Vector2[],System.Int32,Nez.Matrix2D@,Microsoft.Xna.Framework.Vector2[],System.Int32,System.Int32)">
            <summary>
            Apply transformation on vectors within array of <see cref="T:Microsoft.Xna.Framework.Vector2"/> by the specified <see cref="T:Microsoft.Xna.Framework.Matrix"/> and places the results in an another array.
            </summary>
            <param name="sourceArray">Source array.</param>
            <param name="sourceIndex">The starting index of transformation in the source array.</param>
            <param name="matrix">The transformation <see cref="T:Microsoft.Xna.Framework.Matrix"/>.</param>
            <param name="destinationArray">Destination array.</param>
            <param name="destinationIndex">The starting index in the destination array, where the first <see cref="T:Microsoft.Xna.Framework.Vector2"/> should be written.</param>
            <param name="length">The number of vectors to be transformed.</param>
        </member>
        <member name="M:Nez.Vector2Ext.Transform(Microsoft.Xna.Framework.Vector2[],Nez.Matrix2D@,Microsoft.Xna.Framework.Vector2[])">
            <summary>
            Apply transformation on all vectors within array of <see cref="T:Microsoft.Xna.Framework.Vector2"/> by the specified <see cref="T:Microsoft.Xna.Framework.Matrix"/> and places the results in an another array.
            </summary>
            <param name="sourceArray">Source array.</param>
            <param name="matrix">The transformation <see cref="T:Microsoft.Xna.Framework.Matrix"/>.</param>
            <param name="destinationArray">Destination array.</param>
        </member>
        <member name="M:Nez.Vector3Ext.ToVector2(Microsoft.Xna.Framework.Vector3)">
            <summary>
            returns a Vector2 ignoring the z component
            </summary>
            <returns>The vector2.</returns>
            <param name="vec">Vec.</param>
        </member>
        <member name="T:Nez.BatcherIFontExt">
            <summary>
            provides the full SpriteFont assortment of drawString methods
            </summary>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
            <param name="rotation">Rotation.</param>
            <param name="origin">Origin.</param>
            <param name="scale">Scale.</param>
            <param name="effects">Effects.</param>
            <param name="layerDepth">Layer depth.</param>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,System.Single,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
            <param name="rotation">Rotation.</param>
            <param name="origin">Origin.</param>
            <param name="scale">Scale.</param>
            <param name="effects">Effects.</param>
            <param name="layerDepth">Layer depth.</param>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.Text.StringBuilder,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
            <param name="rotation">Rotation.</param>
            <param name="origin">Origin.</param>
            <param name="scale">Scale.</param>
            <param name="effects">Effects.</param>
            <param name="layerDepth">Layer depth.</param>
        </member>
        <member name="M:Nez.BatcherIFontExt.DrawString(Nez.Batcher,Nez.IFont,System.String,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Color,System.Single,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Graphics.SpriteEffects,System.Single)">
            <summary>
            Submit a text string of sprites for drawing in the current batch.
            </summary>
            <param name="batcher">Batcher.</param>
            <param name="font">Font.</param>
            <param name="text">Text.</param>
            <param name="position">Position.</param>
            <param name="color">Color.</param>
            <param name="rotation">Rotation.</param>
            <param name="origin">Origin.</param>
            <param name="scale">Scale.</param>
            <param name="effects">Effects.</param>
            <param name="layerDepth">Layer depth.</param>
        </member>
        <member name="T:Nez.BatcherSpriteFontExt">
            <summary>
            helper methods for drawing text with NezSpriteFonts
            </summary>
        </member>
        <member name="T:Nez.FontCharacterSource">
            <summary>
            helper that wraps either a string or StringBuilder and provides a common API to read them for measuring/drawing
            </summary>
        </member>
        <member name="P:Nez.IFont.LineSpacing">
            <summary>
            line height of the font
            </summary>
            <value>The height of the line.</value>
        </member>
        <member name="M:Nez.IFont.MeasureString(System.String)">
            <summary>
            returns the size in pixels of text when rendered in this font
            </summary>
            <returns>The string.</returns>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.IFont.MeasureString(System.Text.StringBuilder)">
            <summary>
            returns the size in pixels of text when rendered in this font
            </summary>
            <returns>The string.</returns>
            <param name="text">Text.</param>
        </member>
        <member name="M:Nez.IFont.HasCharacter(System.Char)">
            <summary>
            returns true if the character exists in the font or false if it does not
            </summary>
            <returns><c>true</c>, if character was hased, <c>false</c> otherwise.</returns>
            <param name="c">C.</param>
        </member>
        <member name="F:Nez.NezSpriteFont._transformationMatrix">
            <summary>
            this sucker gets used a lot so we cache it to avoid having to create it every frame
            </summary>
        </member>
        <member name="M:Nez.NezSpriteFont.MeasureString(System.String)">
            <summary>
            Returns the size of a string when rendered in this font.
            </summary>
            <param name="text">The text to measure.</param>
            <returns>The size, in pixels, of 'text' when rendered in
            this font.</returns>
        </member>
        <member name="M:Nez.NezSpriteFont.MeasureString(System.Text.StringBuilder)">
            <summary>
            Returns the size of the contents of a StringBuilder when
            rendered in this font.
            </summary>
            <param name="text">The text to measure.</param>
            <returns>The size, in pixels, of 'text' when rendered in
            this font.</returns>
        </member>
        <member name="M:Nez.NezSpriteFont.TryGetFontRegionForChar(System.Char,Microsoft.Xna.Framework.Graphics.SpriteFont.Glyph@,System.Boolean)">
            <summary>
            gets the BitmapFontRegion for the given char optionally substituting the default region if it isnt present.
            </summary>
            <returns><c>true</c>, if get font region for char was tryed, <c>false</c> otherwise.</returns>
            <param name="c">C.</param>
            <param name="fontRegion">Font region.</param>
            <param name="useDefaultRegionIfNotPresent">If set to <c>true</c> use default region if not present.</param>
        </member>
        <member name="M:Nez.NezSpriteFont.HasCharacter(System.Char)">
            <summary>
            checks to see if a BitmapFontRegion exists for the char
            </summary>
            <returns><c>true</c>, if region exists for char was fonted, <c>false</c> otherwise.</returns>
            <param name="c">C.</param>
        </member>
        <member name="P:Nez.GlobalManager.Enabled">
            <summary>
            true if the GlobalManager is enabled. Changes in state result in OnEnabled/OnDisable being called.
            </summary>
            <value><c>true</c> if enabled; otherwise, <c>false</c>.</value>
        </member>
        <member name="M:Nez.GlobalManager.SetEnabled(System.Boolean)">
            <summary>
            enables/disables this GlobalManager
            </summary>
            <returns>The enabled.</returns>
            <param name="isEnabled">If set to <c>true</c> is enabled.</param>
        </member>
        <member name="M:Nez.GlobalManager.OnEnabled">
            <summary>
            called when this GlobalManager is enabled
            </summary>
        </member>
        <member name="M:Nez.GlobalManager.OnDisabled">
            <summary>
            called when the this GlobalManager is disabled
            </summary>
        </member>
        <member name="M:Nez.GlobalManager.Update">
            <summary>
            called each frame before Scene.update
            </summary>
        </member>
        <member name="T:Nez.ReflectionUtils">
            <summary>
            helper class to fetch property delegates
            </summary>
        </member>
        <member name="M:Nez.ReflectionUtils.SetterForProperty``1(System.Object,System.String)">
            <summary>
            either returns a super fast Delegate to set the given property or null if it couldn't be found
            via reflection
            </summary>
        </member>
        <member name="M:Nez.ReflectionUtils.GetterForProperty``1(System.Object,System.String)">
            <summary>
            either returns a super fast Delegate to get the given property or null if it couldn't be found
            via reflection
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.ReflectionUtils.GetAllSubclasses(System.Type,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Nez.ReflectionUtils.GetAllTypesAssignableFrom(System.Type,System.Boolean)" -->
        <member name="M:Nez.ReflectionUtils.IsGenericTypeOrSubclassOfGenericType(System.Type)">
            <summary>
            checks <paramref name="type"/> to see if it or any base class in the chain IsGenericType
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Nez.Screen.Width">
            <summary>
            width of the GraphicsDevice back buffer
            </summary>
            <value>The width.</value>
        </member>
        <member name="P:Nez.Screen.Height">
            <summary>
            height of the GraphicsDevice back buffer
            </summary>
            <value>The height.</value>
        </member>
        <member name="P:Nez.Screen.Size">
            <summary>
            gets the Screen's size as a Vector2
            </summary>
            <value>The screen size.</value>
        </member>
        <member name="P:Nez.Screen.Center">
            <summary>
            gets the Screen's center.null Note that this is the center of the backbuffer! If you are rendering to a smaller RenderTarget
            you will need to scale this value appropriately.
            </summary>
            <value>The center.</value>
        </member>
        <member name="M:Nez.Screen.SetSize(System.Int32,System.Int32)">
            <summary>
            sets the preferredBackBuffer then applies the changes
            </summary>
            <param name="width">Width.</param>
            <param name="height">Height.</param>
        </member>
        <member name="M:Nez.Storage.GetStorageRoot">
            <summary>
            attempts to come up with a root folder you can use to save your data accross all (non-console) platforms
            </summary>
            <returns>The storage root.</returns>
        </member>
        <member name="T:Nez.Time">
            <summary>
            provides frame timing information
            </summary>
        </member>
        <member name="F:Nez.Time.TotalTime">
            <summary>
            total time the game has been running
            </summary>
        </member>
        <member name="F:Nez.Time.DeltaTime">
            <summary>
            delta time from the previous frame to the current, scaled by timeScale
            </summary>
        </member>
        <member name="F:Nez.Time.UnscaledDeltaTime">
            <summary>
            unscaled version of deltaTime. Not affected by timeScale
            </summary>
        </member>
        <member name="F:Nez.Time.AltDeltaTime">
            <summary>
            secondary deltaTime for use when you need to scale two different deltas simultaneously
            </summary>
        </member>
        <member name="F:Nez.Time.TimeSinceSceneLoad">
            <summary>
            total time since the Scene was loaded
            </summary>
        </member>
        <member name="F:Nez.Time.TimeScale">
            <summary>
            time scale of deltaTime
            </summary>
        </member>
        <member name="F:Nez.Time.AltTimeScale">
            <summary>
            time scale of altDeltaTime
            </summary>
        </member>
        <member name="F:Nez.Time.FrameCount">
            <summary>
            total number of frames that have passed
            </summary>
        </member>
        <member name="F:Nez.Time.MaxDeltaTime">
            <summary>
            Maximum value that DeltaTime can be. This can be useful to prevent physics from breaking when dragging
            the game window or if your game hitches.
            </summary>
        </member>
        <member name="M:Nez.Time.CheckEvery(System.Single)">
            <summary>
            Allows to check in intervals. Should only be used with interval values above deltaTime,
            otherwise it will always return true.
            </summary>
        </member>
        <member name="M:Nez.ITimer.Stop">
            <summary>
            call stop to stop this timer from being run again. This has no effect on a non-repeating timer.
            </summary>
        </member>
        <member name="M:Nez.ITimer.Reset">
            <summary>
            resets the elapsed time of the timer to 0
            </summary>
        </member>
        <member name="M:Nez.ITimer.RemainingTime">
            <summary>
            Returns time reamaing on the timer
            </summary>
        </member>
        <member name="M:Nez.ITimer.GetContext``1">
            <summary>
            returns the context casted to T as a convenience
            </summary>
            <returns>The context.</returns>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:Nez.Timers.Timer">
            <summary>
            private class hiding the implementation of ITimer
            </summary>
        </member>
        <member name="M:Nez.Timers.Timer.Unload">
            <summary>
            nulls out the object references so the GC can pick them up if needed
            </summary>
        </member>
        <member name="T:Nez.Timers.TimerManager">
            <summary>
            allows delayed and repeated execution of an Action
            </summary>
        </member>
        <member name="M:Nez.Timers.TimerManager.Schedule(System.Single,System.Boolean,System.Object,System.Action{Nez.ITimer})">
            <summary>
            schedules a one-time or repeating timer that will call the passed in Action
            </summary>
            <param name="timeInSeconds">Time in seconds.</param>
            <param name="repeats">If set to <c>true</c> repeats.</param>
            <param name="context">Context.</param>
            <param name="onTime">On time.</param>
        </member>
        <member name="T:Nez.Triangulator">
            <summary>
            simple ear clipping triangulator. the final triangles will be present in the triangleIndices list
            </summary>
        </member>
        <member name="F:Nez.Triangulator.TriangleIndices">
            <summary>
            The indexes of triangle list entries for the list of points used in the last triangulate call.
            </summary>
        </member>
        <member name="M:Nez.Triangulator.Triangulate(Microsoft.Xna.Framework.Vector2[],System.Boolean)">
            <summary>
            Computes a triangle list that fully covers the area enclosed by the given set of points. If points are not CCW, pass false for
            the arePointsCCW parameter
            </summary>
            <param name="points">A list of points that defines an enclosing path.</param>
            <param name="count">The number of points in the path.</param>
        </member>
        <member name="T:Nez.Tweens.AbstractTweenable">
            <summary>
            AbstractTweenable serves as a base for any custom classes you might want to make that can be ticked. These differ from
            ITweens in that they dont implement the ITweenT interface. What does that mean? It just says that an AbstractTweenable
            is not just moving a value from start to finish. It can do anything at all that requires a tick each frame.
            
            The TweenChain is one example of AbstractTweenable for reference.
            </summary>
        </member>
        <member name="F:Nez.Tweens.AbstractTweenable._isCurrentlyManagedByTweenManager">
            <summary>
            AbstractTweenable are often kept around after they complete. This flag lets them know internally if they are currently
            being tweened by TweenManager so that they can re-add themselves if necessary.
            </summary>
        </member>
        <member name="T:Nez.Tweens.EaseHelper">
            <summary>
            helper with a single method that takes in an EaseType and applies that ease equation with the given
            duration and time parameters. We do this to avoid passing around Funcs which create bogs of trash for
            the garbage collector (function pointers please!)
            </summary>
        </member>
        <member name="M:Nez.Tweens.EaseHelper.OppositeEaseType(Nez.Tweens.EaseType)">
            <summary>
            returns the opposite EaseType of easeType
            </summary>
            <returns>The ease type.</returns>
            <param name="easeType">Ease type.</param>
        </member>
        <member name="T:Nez.Tweens.Easing">
            <summary>
            standard easing equations simplified by replacing the b and c params (begin and change values) with 0 and
            1 then reducing. This is done so that we can get back a raw value between 0 - 1 (except elastic/bounce which
            purposely go over the bounds) and then use that value to lerp anything.
            </summary>
        </member>
        <member name="T:Nez.Tweens.Lerps">
            <summary>
            series of static methods to handle all common tween type structs along with unclamped lerps for them.
            unclamped lerps are required for bounce, elastic or other tweens that exceed the 0 - 1 range.
            </summary>
        </member>
        <member name="M:Nez.Tweens.Lerps.LerpTowards(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            remainingFactorPerSecond is the percentage of the distance it covers every second. should be between 0 and 1.
            if it's 0.25 it means it covers 75% of the remaining distance every second independent of the framerate
            </summary>
            <returns>The towards.</returns>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <param name="remainingFactorPerSecond">Remaining factor per second.</param>
            <param name="deltaTime">Delta time.</param>
        </member>
        <member name="M:Nez.Tweens.Lerps.LerpDamp(System.Single,System.Single,System.Single)">
            <summary>
            A smoothing rate of zero will give you back the target value (i.e. no smoothing), and a rate of 1 is technically not allowed,
            but will just give you back the source value (i.e. infinite smoothing). Note that this is the opposite of the way a lerp
            parameter works, but if you so desire, you can just use additive inverse of the smoothing parameter inside the Pow.
            Smoothing rate dictates the proportion of source remaining after one second
            </summary>
            <param name="source">Source.</param>
            <param name="target">Target.</param>
            <param name="smoothing">Smoothing.</param>
            <param name="dt">Dt.</param>
        </member>
        <member name="M:Nez.Tweens.Lerps.FastSpring(System.Single,System.Single,System.Single@,System.Single,System.Single)">
            <summary>
            uses the semi-implicit euler method. faster, but not always stable.
            see http://allenchou.net/2015/04/game-math-more-on-numeric-springing/
            </summary>
            <returns>The spring.</returns>
            <param name="currentValue">Current value.</param>
            <param name="targetValue">Target value.</param>
            <param name="velocity">Velocity by reference. Be sure to reset it to 0 if changing the targetValue between calls</param>
            <param name="dampingRatio">lower values are less damped and higher values are more damped resulting in less springiness.
            should be between 0.01f, 1f to avoid unstable systems.</param>
            <param name="angularFrequency">An angular frequency of 2pi (radians per second) means the oscillation completes one
            full period over one second, i.e. 1Hz. should be less than 35 or so to remain stable</param>
        </member>
        <member name="M:Nez.Tweens.Lerps.StableSpring(System.Single,System.Single,System.Single@,System.Single,System.Single)">
            <summary>
            uses the implicit euler method. slower, but always stable.
            see http://allenchou.net/2015/04/game-math-more-on-numeric-springing/
            </summary>
            <returns>The spring.</returns>
            <param name="currentValue">Current value.</param>
            <param name="targetValue">Target value.</param>
            <param name="velocity">Velocity by reference. Be sure to reset it to 0 if changing the targetValue between calls</param>
            <param name="dampingRatio">lower values are less damped and higher values are more damped resulting in less springiness.
            should be between 0.01f, 1f to avoid unstable systems.</param>
            <param name="angularFrequency">An angular frequency of 2pi (radians per second) means the oscillation completes one
            full period over one second, i.e. 1Hz. should be less than 35 or so to remain stable</param>
        </member>
        <member name="M:Nez.Tweens.Lerps.FastSpring(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@,System.Single,System.Single)">
            <summary>
            uses the semi-implicit euler method. slower, but always stable.
            see http://allenchou.net/2015/04/game-math-more-on-numeric-springing/
            </summary>
            <returns>The spring.</returns>
            <param name="currentValue">Current value.</param>
            <param name="targetValue">Target value.</param>
            <param name="velocity">Velocity by reference. Be sure to reset it to 0 if changing the targetValue between calls</param>
            <param name="dampingRatio">lower values are less damped and higher values are more damped resulting in less springiness.
            should be between 0.01f, 1f to avoid unstable systems.</param>
            <param name="angularFrequency">An angular frequency of 2pi (radians per second) means the oscillation completes one
            full period over one second, i.e. 1Hz. should be less than 35 or so to remain stable</param>
        </member>
        <member name="M:Nez.Tweens.Lerps.StableSpring(Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2@,System.Single,System.Single)">
            <summary>
            uses the implicit euler method. faster, but not always stable.
            see http://allenchou.net/2015/04/game-math-more-on-numeric-springing/
            </summary>
            <returns>The spring.</returns>
            <param name="currentValue">Current value.</param>
            <param name="targetValue">Target value.</param>
            <param name="velocity">Velocity by reference. Be sure to reset it to 0 if changing the targetValue between calls</param>
            <param name="dampingRatio">lower values are less damped and higher values are more damped resulting in less springiness.
            should be between 0.01f, 1f to avoid unstable systems.</param>
            <param name="angularFrequency">An angular frequency of 2pi (radians per second) means the oscillation completes one
            full period over one second, i.e. 1Hz. should be less than 35 or so to remain stable</param>
        </member>
        <member name="T:Nez.Tweens.ITween`1">
            <summary>
            a series of strongly typed, chainable methods to setup various tween properties
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetEaseType(Nez.Tweens.EaseType)">
            <summary>
            sets the ease type used for this tween
            </summary>
            <returns>The ease type.</returns>
            <param name="easeType">Ease type.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetDelay(System.Single)">
            <summary>
            sets the delay before starting the tween
            </summary>
            <returns>The delay.</returns>
            <param name="delay">Delay.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetDuration(System.Single)">
            <summary>
            sets the tween duration
            </summary>
            <returns>The duration.</returns>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetTimeScale(System.Single)">
            <summary>
            sets the timeScale used for this tween. The timeScale will be multiplied with Time.deltaTime/Time.unscaledDeltaTime
            to get the actual delta time used for the tween.
            </summary>
            <returns>The time scale.</returns>
            <param name="timeScale">Time scale.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetIsTimeScaleIndependent">
            <summary>
            sets the tween to use Time.unscaledDeltaTime instead of Time.deltaTime
            </summary>
            <returns>The is time scale independant.</returns>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetCompletionHandler(System.Action{Nez.Tweens.ITween{`0}})">
            <summary>
            chainable. sets the action that should be called when the tween is complete.
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetLoops(Nez.Tweens.LoopType,System.Int32,System.Single)">
            <summary>
            chainable. set the loop type for the tween. a single pingpong loop means going from start-finish-start.
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetLoopCompletionHandler(System.Action{Nez.Tweens.ITween{`0}})">
            <summary>
            chainable. sets the action that should be called when a loop is complete. A loop is either when the first part of
            a ping-pong animation completes or when starting over when using a restart-from-beginning loop type. Note that ping-pong
            loops (which are really two part tweens) will not fire the loop completion handler on the last iteration. The normal
            tween completion handler will fire though
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetFrom(`0)">
            <summary>
            sets the start position for the tween
            </summary>
            <returns>The from.</returns>
            <param name="from">From.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.PrepareForReuse(`0,`0,System.Single)">
            <summary>
            prepares a tween for reuse by resetting its from/to values and duration
            </summary>
            <returns>The for reuse.</returns>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Nez.Tweens.ITween`1.SetRecycleTween(System.Boolean)" -->
        <member name="M:Nez.Tweens.ITween`1.SetIsRelative">
            <summary>
            helper that just sets the to value of the tween to be to + from making the tween relative
            to its current value.
            </summary>
            <returns>The is relative tween.</returns>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetContext(System.Object)">
            <summary>
            allows you to set any object reference retrievable via tween.context. This is handy for avoiding
            closure allocations for completion handler Actions. You can also search TweenManager for all tweens with a specific
            context.
            </summary>
            <returns>The context.</returns>
            <param name="context">Context.</param>
        </member>
        <member name="M:Nez.Tweens.ITween`1.SetNextTween(Nez.Tweens.ITweenable)">
            <summary>
            allows you to add a tween that will get run after this tween completes. Note that nextTween must be an ITweenable!
            Also note that all ITweenTs are ITweenable.
            </summary>
            <returns>The next tween.</returns>
            <param name="nextTween">Next tween.</param>
        </member>
        <member name="M:Nez.Tweens.ITweenable.Tick">
            <summary>
            called by TweenManager each frame like an internal Update
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenable.RecycleSelf">
            <summary>
            called by TweenManager when a tween is removed. Subclasses can optionally recycle themself. Subclasses
            should first check the _shouldRecycleTween bool in their implementation!
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenable.IsRunning">
            <summary>
            checks to see if a tween is running
            </summary>
            <returns><c>true</c>, if running was ised, <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Nez.Tweens.ITweenable.Start">
            <summary>
            starts the tween
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenable.Pause">
            <summary>
            pauses the tween
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenable.Resume">
            <summary>
            resumes the tween after a pause
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenable.Stop(System.Boolean)">
            <summary>
            stops the tween optionally bringing it to completion
            </summary>
            <param name="bringToCompletion">If set to <c>true</c> bring to completion.</param>
        </member>
        <member name="T:Nez.Tweens.ITweenControl">
            <summary>
            more specific tween playback controls here.
            </summary>
        </member>
        <member name="P:Nez.Tweens.ITweenControl.Context">
            <summary>
            handy property that you can use in any callbacks (such as a completion handler) to avoid allocations when using
            anonymous Actions
            </summary>
            <value>The context.</value>
        </member>
        <member name="M:Nez.Tweens.ITweenControl.JumpToElapsedTime(System.Single)">
            <summary>
            warps the tween to elapsedTime clamping it between 0 and duration. this will immediately update the tweened
            object whether it is paused, completed or running.
            </summary>
            <param name="elapsedTime">Elapsed time.</param>
        </member>
        <member name="M:Nez.Tweens.ITweenControl.WaitForCompletion">
            <summary>
            when called from StartCoroutine it will yield until the tween is complete
            </summary>
            <returns>The for completion.</returns>
        </member>
        <member name="M:Nez.Tweens.ITweenControl.GetTargetObject">
            <summary>
            gets the target of the tween or null for TweenTargets that arent necessarily all about a single object.
            its only real use is for TweenManager to find a list of tweens by target.
            </summary>
            <returns>The target object.</returns>
        </member>
        <member name="T:Nez.Tweens.ITweenTarget`1">
            <summary>
            any object that wants to be tweened needs to implement this. TweenManager internally likes to make a simple object
            that implements this interface and stores a reference to the object being tweened. That makes for tiny, simple,
            lightweight implementations that can be handed off to any TweenT
            </summary>
        </member>
        <member name="M:Nez.Tweens.ITweenTarget`1.SetTweenedValue(`0)">
            <summary>
            sets the final, tweened value on the object of your choosing.
            </summary>
            <param name="value">Value.</param>
        </member>
        <member name="M:Nez.Tweens.ITweenTarget`1.GetTargetObject">
            <summary>
            gets the target of the tween or null for TweenTargets that arent necessarily all about a single object.
            its only real use is for TweenManager to find a list of tweens by target.
            </summary>
            <returns>The target object.</returns>
        </member>
        <member name="T:Nez.Tweens.PropertyTarget`1">
            <summary>
            generic ITweenTarget used for all property tweens
            </summary>
        </member>
        <member name="F:Nez.Tweens.TransformSpringTween.DampingRatio">
            <summary>
            lower values are less damped and higher values are more damped resulting in less springiness.
            should be between 0.01f, 1f to avoid unstable systems.
            </summary>
        </member>
        <member name="F:Nez.Tweens.TransformSpringTween.AngularFrequency">
            <summary>
            An angular frequency of 2pi (radians per second) means the oscillation completes one
            full period over one second, i.e. 1Hz. should be less than 35 or so to remain stableThe angular frequency.
            </summary>
        </member>
        <member name="M:Nez.Tweens.TransformSpringTween.#ctor(Nez.Transform,Nez.Tweens.TransformTargetType,Microsoft.Xna.Framework.Vector2)">
            <summary>
            Initializes a new instance of the TransformSpringTween class.
            </summary>
        </member>
        <member name="M:Nez.Tweens.TransformSpringTween.SetTargetValue(Microsoft.Xna.Framework.Vector2)">
            <summary>
            you can call setTargetValue at any time to reset the target value to a new Vector2. If you have not called start to add the
            spring tween it will be called for you.
            </summary>
            <param name="targetValue">Target value.</param>
        </member>
        <member name="M:Nez.Tweens.TransformSpringTween.UpdateDampingRatioWithHalfLife(System.Single)">
            <summary>
            lambda should be the desired duration when the oscillation magnitude is reduced by 50%
            </summary>
            <param name="lambda">Lambda.</param>
        </member>
        <member name="T:Nez.Tweens.TransformTargetType">
            <summary>
            useful enum for any Transform related property tweens
            </summary>
        </member>
        <member name="T:Nez.Tweens.TransformVector2Tween">
            <summary>
            this is a special case since Transforms are by far the most tweened object. we encapsulate the Tween and the ITweenTarget
            in a single, cacheable class
            </summary>
        </member>
        <member name="M:Nez.Tweens.Tween`1.ReverseTween">
            <summary>
            reverses the current tween. if it was going forward it will be going backwards and vice versa.
            </summary>
        </member>
        <member name="M:Nez.Tweens.Tween`1.WaitForCompletion">
            <summary>
            when called via StartCoroutine this will continue until the tween completes
            </summary>
            <returns>The for completion.</returns>
        </member>
        <member name="M:Nez.Tweens.Tween`1.Initialize(Nez.Tweens.ITweenTarget{`0},`0,System.Single)">
            <summary>
            resets all state to defaults and sets the initial state based on the paramaters passed in. This method serves
            as an entry point so that Tween subclasses can call it and so that tweens can be recycled. When recycled,
            the constructor will not be called again so this method encapsulates what the constructor would be doing.
            </summary>
            <param name="target">Target.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.Tweens.Tween`1.HandleLooping(System.Single)">
            <summary>
            handles loop logic
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager.RemoveAllTweensOnLevelLoad">
            <summary>
            if true, the active tween list will be cleared when a new level loads
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager.CacheIntTweens">
            <summary>
            automatic caching of various types is supported here. Note that caching will only work when using extension methods to start
            the tweens or if you fetch a tween from the cache when doing custom tweens. See the extension method implementations for
            how to fetch a cached tween.
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager._activeTweens">
            <summary>
            internal list of all the currently active tweens
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager._tempTweens">
            <summary>
            stores tweens marked for removal
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager._isUpdating">
            <summary>
            flag indicating the tween update loop is running
            </summary>
        </member>
        <member name="F:Nez.Tweens.TweenManager._instance">
            <summary>
            facilitates exposing a static API for easy access
            </summary>
        </member>
        <member name="M:Nez.Tweens.TweenManager.AddTween(Nez.Tweens.ITweenable)">
            <summary>
            adds a tween to the active tweens list
            </summary>
            <param name="tween">Tween.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.RemoveTween(Nez.Tweens.ITweenable)">
            <summary>
            removes a tween from the active tweens list
            </summary>
            <param name="tween">Tween.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.StopAllTweens(System.Boolean)">
            <summary>
            stops all tweens optionlly bringing them all to completion
            </summary>
            <param name="bringToCompletion">If set to <c>true</c> bring to completion.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.AllTweensWithContext(System.Object)">
            <summary>
            returns all the tweens that have a specific context. Tweens are returned as ITweenable since that is all
            that TweenManager knows about.
            </summary>
            <returns>The tweens with context.</returns>
            <param name="context">Context.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.StopAllTweensWithContext(System.Object,System.Boolean)">
            <summary>
            stops all the tweens with a given context
            </summary>
            <returns>The tweens with context.</returns>
            <param name="context">Context.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.AllTweensWithTarget(System.Object)">
            <summary>
            returns all the tweens that have a specific target. Tweens are returned as ITweenControl since that is all
            that TweenManager knows about.
            </summary>
            <returns>The tweens with target.</returns>
            <param name="target">target.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.AllTweensWithTargetEntity(Nez.Entity)">
            <summary>
            returns all the tweens that target a specific entity. Tweens are returned as ITweenControl since that is all
            that TweenManager knows about.
            </summary>
            <returns>The tweens that target entity.</returns>
            <param name="target">target.</param>
        </member>
        <member name="M:Nez.Tweens.TweenManager.StopAllTweensWithTarget(System.Object,System.Boolean)">
            <summary>
            stops all the tweens that have a specific target
            that TweenManager knows about.
            </summary>
            <param name="target">target.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenPositionTo(Nez.Transform,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.position tween
            </summary>
            <returns>The kposition to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalPositionTo(Nez.Transform,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.localPosition tween
            </summary>
            <returns>The klocal position to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenScaleTo(Nez.Transform,System.Single,System.Single)">
            <summary>
            transform.scale tween
            </summary>
            <returns>The scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenScaleTo(Nez.Transform,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.scale tween
            </summary>
            <returns>The scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalScaleTo(Nez.Transform,System.Single,System.Single)">
            <summary>
            transform.localScale tween
            </summary>
            <returns>The klocal scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalScaleTo(Nez.Transform,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.localScale tween
            </summary>
            <returns>The klocal scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenRotationDegreesTo(Nez.Transform,System.Single,System.Single)">
            <summary>
            transform.rotation tween
            </summary>
            <returns>The rotation to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalRotationDegreesTo(Nez.Transform,System.Single,System.Single)">
            <summary>
            transform.localEulers tween
            </summary>
            <returns>The klocal eulers to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenPositionTo(Nez.Entity,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.position tween
            </summary>
            <returns>The kposition to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalPositionTo(Nez.Entity,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.localPosition tween
            </summary>
            <returns>The klocal position to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenScaleTo(Nez.Entity,System.Single,System.Single)">
            <summary>
            transform.scale tween
            </summary>
            <returns>The scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenScaleTo(Nez.Entity,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.scale tween
            </summary>
            <returns>The scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalScaleTo(Nez.Entity,System.Single,System.Single)">
            <summary>
            transform.localScale tween
            </summary>
            <returns>The klocal scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalScaleTo(Nez.Entity,Microsoft.Xna.Framework.Vector2,System.Single)">
            <summary>
            transform.localScale tween
            </summary>
            <returns>The klocal scale to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenRotationDegreesTo(Nez.Entity,System.Single,System.Single)">
            <summary>
            transform.rotation tween
            </summary>
            <returns>The rotation to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenLocalRotationDegreesTo(Nez.Entity,System.Single,System.Single)">
            <summary>
            transform.localEulers tween
            </summary>
            <returns>The klocal eulers to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="M:Nez.TweenExt.TweenColorTo(Nez.RenderableComponent,Microsoft.Xna.Framework.Color,System.Single)">
            <summary>
            RenderableComponent.color tween
            </summary>
            <returns>The color to.</returns>
            <param name="self">Self.</param>
            <param name="to">To.</param>
            <param name="duration">Duration.</param>
        </member>
        <member name="T:Nez.Utils">
            <summary>
            utility methods that don't yet have a proper home that makes sense
            </summary>
        </member>
        <member name="M:Nez.Utils.Swap``1(``0@,``0@)">
            <summary>
            swaps the two object types
            </summary>
            <param name="first">First.</param>
            <param name="second">Second.</param>
            <typeparam name="T">The 1st type parameter.</typeparam>
        </member>
        <member name="T:Nez3D.Model3D">
            <summary>
            Model3D represents a normal 3D Model but it is rendered by a standard Nez Camera on the same plane as all the 2D sprites. For this
            reason, the Model is inflated by a scale of 80 by default. This keeps the Model at approximately the same scale as 2D sprites. You
            can adjust this via the Vector3s present in this class (which replace the 2D Transform) and the 3D Camera fields (which are all
            suffixed with "3D").
            </summary>
        </member>
        <member name="T:System.Collections.Generic.Deque`1">
            <summary>
            sourced from: https://github.com/tejacques/Deque
            A generic Deque class. It can be thought of as a double-ended queue, hence Deque. This allows for
            an O(1) AddFront, AddBack, RemoveFront, RemoveBack. The Deque also has O(1) indexed lookup, as it is backed
            by a circular array.
            </summary>
            <typeparam name="T">
            The type of objects to store in the deque.
            </typeparam>
        </member>
        <member name="F:System.Collections.Generic.Deque`1.defaultCapacity">
            <summary>
            The default capacity of the deque.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.Deque`1.startOffset">
            <summary>
            The first element offset from the beginning of the data array.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.Deque`1.buffer">
            <summary>
            The circular array holding the items.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.#ctor">
            <summary>
            Creates a new instance of the Deque class with
            the default capacity.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.#ctor(System.Int32)">
            <summary>
            Creates a new instance of the Deque class with
            the specified capacity.
            </summary>
            <param name="capacity">The initial capacity of the Deque.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a new instance of the Deque class with the elements
            from the specified collection.
            </summary>
            <param name="collection">The co</param>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.Capacity">
            <summary>
            Gets or sets the total number of elements
            the internal array can hold without resizing.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.IsFull">
            <summary>
            Gets whether or not the Deque is filled to capacity.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.IsEmpty">
            <summary>
            Gets whether or not the Deque is empty.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the Deque.
            </summary>
            <returns>
            An iterator that can be used to iterate through the Deque.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the Deque.
            </summary>
            <returns>
            An iterator that can be used to iterate through the Deque.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>
            Gets a value indicating whether the Deque is read-only.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.Count">
            <summary>
            Gets the number of elements contained in the Deque.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Add(`0)">
            <summary>
            Adds an item to the Deque.
            </summary>
            <param name="item">The object to add to the Deque.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Clear">
            <summary>
            Removes all items from the Deque.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Contains(`0)">
            <summary>
            Determines whether the Deque contains a specific value.
            </summary>
            <param name="item">The object to locate in the Deque.</param>
            <returns>
            true if item is found in the Deque; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.CopyTo(`0[],System.Int32)">
            <summary>
                Copies the elements of the Deque to a System.Array,
                starting at a particular System.Array index.
            </summary>
            <param name="array">
                The one-dimensional System.Array that is the destination of
                the elements copied from the Deque. The System.Array must
                have zero-based indexing.
            </param>
            <param name="arrayIndex">
                The zero-based index in array at which copying begins.
            </param>
            <exception cref="T:System.ArgumentNullException">
                array is null.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                arrayIndex is less than 0.
            </exception>
            <exception cref="T:System.ArgumentException">
                The number of elements in the source Deque is greater than
                the available space from arrayIndex to the end of the
                destination array.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the Deque.
            </summary>
            <param name="item">The object to remove from the Deque.</param>
            <returns>
                true if item was successfully removed from the Deque;
                otherwise, false. This method also returns false if item
                is not found in the original
            </returns>
        </member>
        <member name="P:System.Collections.Generic.Deque`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">
                The zero-based index of the element to get or set.
            </param>
            <returns>The element at the specified index</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index"/> is not a valid index in this deque
            </exception>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the Deque at the specified index.
            </summary>
            <param name="index">
            The zero-based index at which item should be inserted.
            </param>
            <param name="item">The object to insert into the Deque.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not a valid index in the Deque.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific item in the deque.
            </summary>
            <param name="item">The object to locate in the deque.</param>
            <returns>
            The index of the item if found in the deque; otherwise, -1.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified index.
            </summary>
            <param name="index">
            The zero-based index of the item to remove.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is not a valid index in the Deque.
            </exception>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddFront(`0)">
            <summary>
            Adds the provided item to the front of the Deque.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddBack(`0)">
            <summary>
            Adds the provided item to the back of the Deque.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.RemoveFront">
            <summary>
            Removes an item from the front of the Deque and returns it.
            </summary>
            <returns>The item at the front of the Deque.</returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.RemoveBack">
            <summary>
            Removes an item from the back of the Deque and returns it.
            </summary>
            <returns>The item in the back of the Deque.</returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the Deque.
            </summary>
            <param name="collection">The collection to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddFrontRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the front of the Deque.
            </summary>
            <param name="collection">The collection to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddFrontRange(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Adds count items from a collection of items
            from a specified index to the Deque.
            </summary>
            <param name="collection">The collection to add.</param>
            <param name="fromIndex">
            The index in the collection to begin adding from.
            </param>
            <param name="count">
            The number of items in the collection to add.
            </param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddBackRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a collection of items to the back of the Deque.
            </summary>
            <param name="collection">The collection to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.AddBackRange(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Adds count items from a collection of items
            from a specified index to the back of the Deque.
            </summary>
            <param name="collection">The collection to add.</param>
            <param name="fromIndex">
            The index in the collection to begin adding from.
            </param>
            <param name="count">
            The number of items in the collection to add.
            </param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Inserts a collection of items into the Deque
            at the specified index.
            </summary>
            <param name="index">
            The index in the Deque to insert the collection.
            </param>
            <param name="collection">The collection to add.</param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32)">
            <summary>
            Inserts count items from a collection of items from a specified
            index into the Deque at the specified index.
            </summary>
            <param name="index">
            The index in the Deque to insert the collection.
            </param>
            <param name="collection">The collection to add.</param>
            <param name="fromIndex">
            The index in the collection to begin adding from.
            </param>
            <param name="count">
            The number of items in the colleciton to add.
            </param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.RemoveRange(System.Int32,System.Int32)">
            <summary>
                Removes a range of elements from the view.
            </summary>
            <param name="index">
                The index into the view at which the range begins.
            </param>
            <param name="count">
                The number of elements in the range. This must be greater
                than 0 and less than or equal to <see cref="P:System.Collections.Generic.Deque`1.Count"/>.
            </param>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Get(System.Int32)">
            <summary>
            Gets the value at the specified index of the Deque
            </summary>
            <param name="index">The index of the Deque.</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.Deque`1.Set(System.Int32,`0)">
            <summary>
            Sets the value at the specified index of the
            Deque to the given item.
            </summary>
            <param name="index">The index of the deque to set the item.</param>
            <param name="item">The item to set at the specified index.</param>
        </member>
        <member name="T:System.Collections.Generic.IPriorityQueue`1">
            <summary>
            The IPriorityQueue interface.  This is mainly here for purists, and in case I decide to add more implementations later.
            For speed purposes, it is actually recommended that you *don't* access the priority queue through this interface, since the JIT can
            (theoretically?) optimize method calls from concrete-types slightly better.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.Enqueue(`0,System.Int32)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            See implementation for how duplicates are handled.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.Contains(`0)">
            <summary>
            Returns whether the given node is in the queue.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            </summary>
        </member>
        <member name="M:System.Collections.Generic.IPriorityQueue`1.UpdatePriority(`0,System.Int32)">
            <summary>
            Call this method to change the priority of a node.  
            </summary>
        </member>
        <member name="P:System.Collections.Generic.IPriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            </summary>
        </member>
        <member name="P:System.Collections.Generic.IPriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            </summary>
        </member>
        <member name="T:System.Collections.Generic.PriorityQueue`1">
            <summary>
            An implementation of a min-Priority Queue using a heap.  Has O(1) .Contains()!
            See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
            </summary>
            <typeparam name="T">The values in the queue.  Must extend the FastPriorityQueueNode class</typeparam>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Instantiate a new Priority Queue
            </summary>
            <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`1.MaxSize">
            <summary>
            Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
            attempting to enqueue another item will cause undefined behavior.  O(1)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n) (So, don't do this often!)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Contains(`0)">
            <summary>
            Returns (in O(1)!) whether the given node is in the queue.  O(1)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Enqueue(`0,System.Int32)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            If the queue is full, the result is undefined.
            If the node is already enqueued, the result is undefined.
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.HasHigherPriority(`0,`0)">
            <summary>
            Returns true if 'higher' has higher priority than 'lower', false otherwise.
            Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, result is undefined
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Resize(System.Int32)">
            <summary>
            Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
            Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
            O(n)
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            If the queue is empty, behavior is undefined.
            O(1)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.UpdatePriority(`0,System.Int32)">
            <summary>
            This method must be called on a node every time its priority changes while it is in the queue.  
            <b>Forgetting to call this method will result in a corrupted queue!</b>
            Calling this method on a node not in the queue results in undefined behavior
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.Remove(`0)">
            <summary>
            Removes a node from the queue.  The node does not need to be the head of the queue.  
            If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.PriorityQueue`1.IsValidQueue">
            <summary>
            <b>Should not be called in production code.</b>
            Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueueNode.Priority">
            <summary>
            The Priority to insert this node at.  Must be set BEFORE adding a node to the queue
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueueNode.InsertionIndex">
            <summary>
            <b>Used by the priority queue - do not edit this value.</b>
            Represents the order the node was inserted in
            </summary>
        </member>
        <member name="P:System.Collections.Generic.PriorityQueueNode.QueueIndex">
            <summary>
            <b>Used by the priority queue - do not edit this value.</b>
            Represents the current position in the queue
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.GetExistingNode(`0)">
            <summary>
            Given an item of type T, returns the exist SimpleNode in the queue
            </summary>
        </member>
        <member name="P:System.Collections.Generic.SimplePriorityQueue`1.Count">
            <summary>
            Returns the number of nodes in the queue.
            O(1)
            </summary>
        </member>
        <member name="P:System.Collections.Generic.SimplePriorityQueue`1.First">
            <summary>
            Returns the head of the queue, without removing it (use Dequeue() for that).
            Throws an exception when the queue is empty.
            O(1)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.Clear">
            <summary>
            Removes every node from the queue.
            O(n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.Contains(`0)">
            <summary>
            Returns whether the given item is in the queue.
            O(n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.Dequeue">
            <summary>
            Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
            If queue is empty, throws an exception
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.Enqueue(`0,System.Int32)">
            <summary>
            Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
            This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.
            Duplicates are allowed.
            O(log n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.Remove(`0)">
            <summary>
            Removes an item from the queue.  The item does not need to be the head of the queue.  
            If the item is not in the queue, an exception is thrown.  If unsure, check Contains() first.
            If multiple copies of the item are enqueued, only the first one is removed. 
            O(n)
            </summary>
        </member>
        <member name="M:System.Collections.Generic.SimplePriorityQueue`1.UpdatePriority(`0,System.Int32)">
            <summary>
            Call this method to change the priority of an item.
            Calling this method on a item not in the queue will throw an exception.
            If the item is enqueued multiple times, only the first one will be updated.
            (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
            to update all of them, please wrap your items in a wrapper class so they can be distinguished).
            O(n)
            </summary>
        </member>
    </members>
</doc>
